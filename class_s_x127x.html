<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: SX127x Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_s_x127x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_x127x-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SX127x Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Base class for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> series. All derived classes for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> (e.g. <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> or <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes.  
 <a href="class_s_x127x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_x127x_8h_source.html">SX127x.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SX127x:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_x127x.png" usemap="#SX127x_map" alt=""/>
  <map id="SX127x_map" name="SX127x_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="103,0,196,24"/>
<area href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic..." alt="SX1272" shape="rect" coords="0,112,93,136"/>
<area href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,..." alt="SX1278" shape="rect" coords="206,112,299,136"/>
<area href="class_s_x1273.html" title="Derived class for SX1273 modules. Overrides some methods from SX1272 due to different parameter range..." alt="SX1273" shape="rect" coords="0,168,93,192"/>
<area href="class_s_x1276.html" title="Derived class for SX1276 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1276" shape="rect" coords="103,168,196,192"/>
<area href="class_s_x1277.html" title="Derived class for SX1277 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1277" shape="rect" coords="206,168,299,192"/>
<area href="class_s_x1279.html" title="Derived class for SX1279 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1279" shape="rect" coords="309,168,402,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac74c5914ca429a3892c66b9d98e3ea6c" id="r_ac74c5914ca429a3892c66b9d98e3ea6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac74c5914ca429a3892c66b9d98e3ea6c">SX127x</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:ac74c5914ca429a3892c66b9d98e3ea6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Called internally when creating new LoRa instance.  <br /></td></tr>
<tr class="separator:ac74c5914ca429a3892c66b9d98e3ea6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddbde7fd8eb06d38abfb658eee29bc1" id="r_a7ddbde7fd8eb06d38abfb658eee29bc1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7ddbde7fd8eb06d38abfb658eee29bc1">begin</a> (const uint8_t *chipVersions, uint8_t numVersions, uint8_t syncWord, uint16_t preambleLength)</td></tr>
<tr class="memdesc:a7ddbde7fd8eb06d38abfb658eee29bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method. Will be called with appropriate parameters when calling initialization method from derived class.  <br /></td></tr>
<tr class="separator:a7ddbde7fd8eb06d38abfb658eee29bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f510359be44fd633037810587f1ea2" id="r_a15f510359be44fd633037810587f1ea2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a15f510359be44fd633037810587f1ea2">reset</a> ()</td></tr>
<tr class="memdesc:a15f510359be44fd633037810587f1ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin. Should be implemented in derived class since <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a> and <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> implementations differ.  <br /></td></tr>
<tr class="separator:a15f510359be44fd633037810587f1ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fe001474583d490df1d0b38260bf8e" id="r_a66fe001474583d490df1d0b38260bf8e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a66fe001474583d490df1d0b38260bf8e">beginFSK</a> (const uint8_t *chipVersions, uint8_t numVersions, float freqDev, float rxBw, uint16_t preambleLength, bool enableOOK)</td></tr>
<tr class="memdesc:a66fe001474583d490df1d0b38260bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem. Will be called with appropriate parameters when calling FSK initialization method from derived class.  <br /></td></tr>
<tr class="separator:a66fe001474583d490df1d0b38260bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cb0d8810a5ce025d3bf5b51ca263d6" id="r_a75cb0d8810a5ce025d3bf5b51ca263d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a75cb0d8810a5ce025d3bf5b51ca263d6">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a75cb0d8810a5ce025d3bf5b51ca263d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Will transmit arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534" title="C-string transmit method.">PhysicalLayer::transmit</a>.  <br /></td></tr>
<tr class="separator:a75cb0d8810a5ce025d3bf5b51ca263d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d6b2d3cb8ce3ebb50adb35430dfd3c" id="r_a53d6b2d3cb8ce3ebb50adb35430dfd3c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a53d6b2d3cb8ce3ebb50adb35430dfd3c">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0) override</td></tr>
<tr class="memdesc:a53d6b2d3cb8ce3ebb50adb35430dfd3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Will attempt to receive arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8" title="Binary receive method. Must be implemented in module class.">PhysicalLayer::receive</a>.  <br /></td></tr>
<tr class="separator:a53d6b2d3cb8ce3ebb50adb35430dfd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae97e18744dc617bc9326cfbaad3a3" id="r_a13ae97e18744dc617bc9326cfbaad3a3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a13ae97e18744dc617bc9326cfbaad3a3">scanChannel</a> () override</td></tr>
<tr class="memdesc:a13ae97e18744dc617bc9326cfbaad3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for valid LoRa preamble in the current channel.  <br /></td></tr>
<tr class="separator:a13ae97e18744dc617bc9326cfbaad3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff85ee7979da08b4e66316f1ba2c6a9" id="r_a1ff85ee7979da08b4e66316f1ba2c6a9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1ff85ee7979da08b4e66316f1ba2c6a9">sleep</a> () override</td></tr>
<tr class="memdesc:a1ff85ee7979da08b4e66316f1ba2c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called.  <br /></td></tr>
<tr class="separator:a1ff85ee7979da08b4e66316f1ba2c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b8c5103128f122fbe489c6529ce41" id="r_a760b8c5103128f122fbe489c6529ce41"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a760b8c5103128f122fbe489c6529ce41">standby</a> () override</td></tr>
<tr class="memdesc:a760b8c5103128f122fbe489c6529ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to standby.  <br /></td></tr>
<tr class="separator:a760b8c5103128f122fbe489c6529ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa565bbff460e487672953dc05d335cb0" id="r_aa565bbff460e487672953dc05d335cb0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa565bbff460e487672953dc05d335cb0">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:aa565bbff460e487672953dc05d335cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to standby.  <br /></td></tr>
<tr class="separator:aa565bbff460e487672953dc05d335cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeeb9f7192e11a75b5dfb1ab8488e84" id="r_aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aefeeb9f7192e11a75b5dfb1ab8488e84">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct transmission mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac558d537c6364c4bc82c8f33e398f" id="r_aa7ac558d537c6364c4bc82c8f33e398f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa7ac558d537c6364c4bc82c8f33e398f">receiveDirect</a> () override</td></tr>
<tr class="memdesc:aa7ac558d537c6364c4bc82c8f33e398f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct reception mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:aa7ac558d537c6364c4bc82c8f33e398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0995088d37689a3c240a1af791df6cf1" id="r_a0995088d37689a3c240a1af791df6cf1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0995088d37689a3c240a1af791df6cf1">packetMode</a> ()</td></tr>
<tr class="memdesc:a0995088d37689a3c240a1af791df6cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables direct mode and enables packet mode, allowing the module to receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:a0995088d37689a3c240a1af791df6cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75bc48cc74a407370cd9f4bf95e9e30" id="r_ae75bc48cc74a407370cd9f4bf95e9e30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae75bc48cc74a407370cd9f4bf95e9e30">setDio0Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:ae75bc48cc74a407370cd9f4bf95e9e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO0 activates.  <br /></td></tr>
<tr class="separator:ae75bc48cc74a407370cd9f4bf95e9e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729b4f3f36096b5b15bae19c7876e823" id="r_a729b4f3f36096b5b15bae19c7876e823"><td class="memItemLeft" align="right" valign="top"><a id="a729b4f3f36096b5b15bae19c7876e823" name="a729b4f3f36096b5b15bae19c7876e823"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearDio0Action</b> ()</td></tr>
<tr class="memdesc:a729b4f3f36096b5b15bae19c7876e823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO0 activates. <br /></td></tr>
<tr class="separator:a729b4f3f36096b5b15bae19c7876e823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bce81839b105c464ebf922602e58b" id="r_a7b4bce81839b105c464ebf922602e58b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b4bce81839b105c464ebf922602e58b">setDio1Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:a7b4bce81839b105c464ebf922602e58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO1 activates.  <br /></td></tr>
<tr class="separator:a7b4bce81839b105c464ebf922602e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6532a25e1730973ac08146008adca5" id="r_a9b6532a25e1730973ac08146008adca5"><td class="memItemLeft" align="right" valign="top"><a id="a9b6532a25e1730973ac08146008adca5" name="a9b6532a25e1730973ac08146008adca5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearDio1Action</b> ()</td></tr>
<tr class="memdesc:a9b6532a25e1730973ac08146008adca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO1 activates. <br /></td></tr>
<tr class="separator:a9b6532a25e1730973ac08146008adca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae236a467095fb5364d0fc4a98d85f96e" id="r_ae236a467095fb5364d0fc4a98d85f96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae236a467095fb5364d0fc4a98d85f96e">setPacketReceivedAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ae236a467095fb5364d0fc4a98d85f96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:ae236a467095fb5364d0fc4a98d85f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbc4c256d37f9cdabf9e5f2ef16aa92" id="r_a6cbc4c256d37f9cdabf9e5f2ef16aa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6cbc4c256d37f9cdabf9e5f2ef16aa92">clearPacketReceivedAction</a> () override</td></tr>
<tr class="memdesc:a6cbc4c256d37f9cdabf9e5f2ef16aa92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a6cbc4c256d37f9cdabf9e5f2ef16aa92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530e8e19cfe4d96fe49ca4e6386b099" id="r_a3530e8e19cfe4d96fe49ca4e6386b099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3530e8e19cfe4d96fe49ca4e6386b099">setPacketSentAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a3530e8e19cfe4d96fe49ca4e6386b099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a3530e8e19cfe4d96fe49ca4e6386b099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec32a52b13752d75f3076a5868c312d" id="r_a2ec32a52b13752d75f3076a5868c312d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2ec32a52b13752d75f3076a5868c312d">clearPacketSentAction</a> () override</td></tr>
<tr class="memdesc:a2ec32a52b13752d75f3076a5868c312d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a2ec32a52b13752d75f3076a5868c312d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23c2b384ae8611d59e10ef6a14fe7e4" id="r_ac23c2b384ae8611d59e10ef6a14fe7e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac23c2b384ae8611d59e10ef6a14fe7e4">setChannelScanAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ac23c2b384ae8611d59e10ef6a14fe7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:ac23c2b384ae8611d59e10ef6a14fe7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce9beca21406e3556b3518370947ee2" id="r_a0ce9beca21406e3556b3518370947ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0ce9beca21406e3556b3518370947ee2">clearChannelScanAction</a> () override</td></tr>
<tr class="memdesc:a0ce9beca21406e3556b3518370947ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:a0ce9beca21406e3556b3518370947ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdfd8e2a2ad1eb7e59a73385847acb" id="r_a6fbdfd8e2a2ad1eb7e59a73385847acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fbdfd8e2a2ad1eb7e59a73385847acb">setFifoEmptyAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a6fbdfd8e2a2ad1eb7e59a73385847acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is empty.  <br /></td></tr>
<tr class="separator:a6fbdfd8e2a2ad1eb7e59a73385847acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6eb4363badc1c3450ad7a4d11af4b1" id="r_aaa6eb4363badc1c3450ad7a4d11af4b1"><td class="memItemLeft" align="right" valign="top"><a id="aaa6eb4363badc1c3450ad7a4d11af4b1" name="aaa6eb4363badc1c3450ad7a4d11af4b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFifoEmptyAction</b> ()</td></tr>
<tr class="memdesc:aaa6eb4363badc1c3450ad7a4d11af4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when FIFO is empty. <br /></td></tr>
<tr class="separator:aaa6eb4363badc1c3450ad7a4d11af4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9529ac87f62c32c9c5fac3dc6e08a9" id="r_a7b9529ac87f62c32c9c5fac3dc6e08a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b9529ac87f62c32c9c5fac3dc6e08a9">setFifoThreshold</a> (uint8_t threshold)</td></tr>
<tr class="memdesc:a7b9529ac87f62c32c9c5fac3dc6e08a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set FIFO threshold level. Be aware that threshold is also set in setFifoFullAction method. setFifoThreshold method must be called AFTER calling setFifoFullAction!  <br /></td></tr>
<tr class="separator:a7b9529ac87f62c32c9c5fac3dc6e08a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201c31366f32c41b801724fb662265c1" id="r_a201c31366f32c41b801724fb662265c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a201c31366f32c41b801724fb662265c1">setFifoFullAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a201c31366f32c41b801724fb662265c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is full.  <br /></td></tr>
<tr class="separator:a201c31366f32c41b801724fb662265c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f041e91ab2fbb6f05eef56b5addac71" id="r_a0f041e91ab2fbb6f05eef56b5addac71"><td class="memItemLeft" align="right" valign="top"><a id="a0f041e91ab2fbb6f05eef56b5addac71" name="a0f041e91ab2fbb6f05eef56b5addac71"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFifoFullAction</b> ()</td></tr>
<tr class="memdesc:a0f041e91ab2fbb6f05eef56b5addac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when FIFO is full. <br /></td></tr>
<tr class="separator:a0f041e91ab2fbb6f05eef56b5addac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dbd1697a415c6db3b47cd620c8c02e" id="r_a36dbd1697a415c6db3b47cd620c8c02e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a36dbd1697a415c6db3b47cd620c8c02e">fifoAdd</a> (uint8_t *data, int totalLen, int *remLen)</td></tr>
<tr class="memdesc:a36dbd1697a415c6db3b47cd620c8c02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is empty.  <br /></td></tr>
<tr class="separator:a36dbd1697a415c6db3b47cd620c8c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b193b71ddb6015d25b0a161809d75a" id="r_a25b193b71ddb6015d25b0a161809d75a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a25b193b71ddb6015d25b0a161809d75a">fifoGet</a> (volatile uint8_t *data, int totalLen, volatile int *rcvLen)</td></tr>
<tr class="memdesc:a25b193b71ddb6015d25b0a161809d75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is sufficiently full to read.  <br /></td></tr>
<tr class="separator:a25b193b71ddb6015d25b0a161809d75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9cec52b7fbd0c69cbd861dc17549f" id="r_a7fd9cec52b7fbd0c69cbd861dc17549f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7fd9cec52b7fbd0c69cbd861dc17549f">finishTransmit</a> () override</td></tr>
<tr class="memdesc:a7fd9cec52b7fbd0c69cbd861dc17549f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <br /></td></tr>
<tr class="separator:a7fd9cec52b7fbd0c69cbd861dc17549f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe1076252a366c3c4aa323fdff7d40c" id="r_abbe1076252a366c3c4aa323fdff7d40c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abbe1076252a366c3c4aa323fdff7d40c">startReceive</a> () override</td></tr>
<tr class="memdesc:abbe1076252a366c3c4aa323fdff7d40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:abbe1076252a366c3c4aa323fdff7d40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc840e8d6fe5e222f0143be17876745" id="r_abfc840e8d6fe5e222f0143be17876745"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abfc840e8d6fe5e222f0143be17876745">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:abfc840e8d6fe5e222f0143be17876745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData!  <br /></td></tr>
<tr class="separator:abfc840e8d6fe5e222f0143be17876745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaec05c056dacb2c2171eaa8521be4bb" id="r_acaec05c056dacb2c2171eaa8521be4bb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#acaec05c056dacb2c2171eaa8521be4bb">finishReceive</a> () override</td></tr>
<tr class="memdesc:acaec05c056dacb2c2171eaa8521be4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after reception is done.  <br /></td></tr>
<tr class="separator:acaec05c056dacb2c2171eaa8521be4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa5723724393576ed597509200e17d1" id="r_a6fa5723724393576ed597509200e17d1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fa5723724393576ed597509200e17d1">startChannelScan</a> () override</td></tr>
<tr class="memdesc:a6fa5723724393576ed597509200e17d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. DIO0 will be activated when LoRa preamble is detected. DIO1 will be activated if there's no preamble detected before timeout.  <br /></td></tr>
<tr class="separator:a6fa5723724393576ed597509200e17d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81189ce77541d78fc8feb99c2a3f35b2" id="r_a81189ce77541d78fc8feb99c2a3f35b2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a81189ce77541d78fc8feb99c2a3f35b2">getChannelScanResult</a> () override</td></tr>
<tr class="memdesc:a81189ce77541d78fc8feb99c2a3f35b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <br /></td></tr>
<tr class="separator:a81189ce77541d78fc8feb99c2a3f35b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c7f4584352a12390594395d9c29bde" id="r_ac5c7f4584352a12390594395d9c29bde"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5c7f4584352a12390594395d9c29bde">setSyncWord</a> (uint8_t syncWord)</td></tr>
<tr class="memdesc:ac5c7f4584352a12390594395d9c29bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa sync word. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:ac5c7f4584352a12390594395d9c29bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400575e3d83977bd250c5cb382fc7002" id="r_a400575e3d83977bd250c5cb382fc7002"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a400575e3d83977bd250c5cb382fc7002">setCurrentLimit</a> (uint8_t currentLimit)</td></tr>
<tr class="memdesc:a400575e3d83977bd250c5cb382fc7002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current limit for over current protection at transmitter amplifier. Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps.  <br /></td></tr>
<tr class="separator:a400575e3d83977bd250c5cb382fc7002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844499bace6ae001446d71bee2877656" id="r_a844499bace6ae001446d71bee2877656"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a844499bace6ae001446d71bee2877656">setPreambleLength</a> (size_t preambleLength) override</td></tr>
<tr class="memdesc:a844499bace6ae001446d71bee2877656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa or FSK preamble length. Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode.  <br /></td></tr>
<tr class="separator:a844499bace6ae001446d71bee2877656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b79dae55315cdf25e530db77eeb140f" id="r_a5b79dae55315cdf25e530db77eeb140f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5b79dae55315cdf25e530db77eeb140f">invertPreamble</a> (bool enable)</td></tr>
<tr class="memdesc:a5b79dae55315cdf25e530db77eeb140f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert FSK preamble polarity. The default (non-inverted) is 0x55, the inverted is 0xAA.  <br /></td></tr>
<tr class="separator:a5b79dae55315cdf25e530db77eeb140f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aa854a2668d70f4d3a374a49440362" id="r_af6aa854a2668d70f4d3a374a49440362"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af6aa854a2668d70f4d3a374a49440362">getFrequencyError</a> (bool autoCorrect=false)</td></tr>
<tr class="memdesc:af6aa854a2668d70f4d3a374a49440362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency error of the latest received packet.  <br /></td></tr>
<tr class="separator:af6aa854a2668d70f4d3a374a49440362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094ba2d9268340b7aba99afe5da0544" id="r_a5094ba2d9268340b7aba99afe5da0544"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5094ba2d9268340b7aba99afe5da0544">getAFCError</a> ()</td></tr>
<tr class="memdesc:a5094ba2d9268340b7aba99afe5da0544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current AFC error.  <br /></td></tr>
<tr class="separator:a5094ba2d9268340b7aba99afe5da0544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b3f7464303085d34191dd334c1976f" id="r_a47b3f7464303085d34191dd334c1976f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a47b3f7464303085d34191dd334c1976f">getSNR</a> () override</td></tr>
<tr class="memdesc:a47b3f7464303085d34191dd334c1976f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets signal-to-noise ratio of the latest received packet. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:a47b3f7464303085d34191dd334c1976f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25b685de0859b799488bf7729350b6" id="r_adc25b685de0859b799488bf7729350b6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adc25b685de0859b799488bf7729350b6">getDataRate</a> () const</td></tr>
<tr class="memdesc:adc25b685de0859b799488bf7729350b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data rate of the latest transmitted packet.  <br /></td></tr>
<tr class="separator:adc25b685de0859b799488bf7729350b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448ea8a6a6011a9cdddd4e09bd6c9679" id="r_a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a448ea8a6a6011a9cdddd4e09bd6c9679">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK frequency deviation from carrier frequency. Allowed values depend on bit rate setting and must be lower than 200 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc53b9f9d90647c5709cb974779cf53" id="r_a2cc53b9f9d90647c5709cb974779cf53"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cc53b9f9d90647c5709cb974779cf53">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a2cc53b9f9d90647c5709cb974779cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK receiver bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a2cc53b9f9d90647c5709cb974779cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef" id="r_a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">setAFCBandwidth</a> (float afcBw)</td></tr>
<tr class="memdesc:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK automatic frequency correction bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e" id="r_a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">setAFC</a> (bool isEnabled)</td></tr>
<tr class="memdesc:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables FSK automatic frequency correction(AFC)  <br /></td></tr>
<tr class="separator:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f67330124cefc07a462e77922453d0" id="r_ab0f67330124cefc07a462e77922453d0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab0f67330124cefc07a462e77922453d0">setAFCAGCTrigger</a> (uint8_t trigger)</td></tr>
<tr class="memdesc:ab0f67330124cefc07a462e77922453d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls trigger of AFC and AGC.  <br /></td></tr>
<tr class="separator:ab0f67330124cefc07a462e77922453d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf400f33e17c1679c0b55cd70bef90b0" id="r_aaf400f33e17c1679c0b55cd70bef90b0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aaf400f33e17c1679c0b55cd70bef90b0">setSyncWord</a> (uint8_t *syncWord, size_t len) override</td></tr>
<tr class="memdesc:aaf400f33e17c1679c0b55cd70bef90b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK sync word. Allowed sync words are up to 8 bytes long and can not contain null bytes. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:aaf400f33e17c1679c0b55cd70bef90b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99630d50672b43fc7162ba8f3293f95" id="r_ab99630d50672b43fc7162ba8f3293f95"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab99630d50672b43fc7162ba8f3293f95">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:ab99630d50672b43fc7162ba8f3293f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK node address. Calling this method will enable address filtering. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:ab99630d50672b43fc7162ba8f3293f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51ce6718153e4963128f25bb5aab40" id="r_abc51ce6718153e4963128f25bb5aab40"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abc51ce6718153e4963128f25bb5aab40">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:abc51ce6718153e4963128f25bb5aab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK broadcast address. Calling this method will enable address filtering. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:abc51ce6718153e4963128f25bb5aab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e9bbfd75f9cad26f9f72c34c4ada5" id="r_afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afe6e9bbfd75f9cad26f9f72c34c4ada5">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables FSK address filtering.  <br /></td></tr>
<tr class="separator:afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef0af19a6b8954f956a3c3ad4286ee" id="r_a24ef0af19a6b8954f956a3c3ad4286ee"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a24ef0af19a6b8954f956a3c3ad4286ee">setOOK</a> (bool enableOOK)</td></tr>
<tr class="memdesc:a24ef0af19a6b8954f956a3c3ad4286ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables OOK modulation instead of FSK.  <br /></td></tr>
<tr class="separator:a24ef0af19a6b8954f956a3c3ad4286ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b93142202167270db109d18b743c744" id="r_a8b93142202167270db109d18b743c744"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8b93142202167270db109d18b743c744">setOokThresholdType</a> (uint8_t type)</td></tr>
<tr class="memdesc:a8b93142202167270db109d18b743c744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the type of threshold in the OOK data slicer.  <br /></td></tr>
<tr class="separator:a8b93142202167270db109d18b743c744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f43d70b5f94e49e09b4c9f082f46d" id="r_aac2f43d70b5f94e49e09b4c9f082f46d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aac2f43d70b5f94e49e09b4c9f082f46d">setOokPeakThresholdDecrement</a> (uint8_t value)</td></tr>
<tr class="memdesc:aac2f43d70b5f94e49e09b4c9f082f46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of decrement of the RSSI threshold in the OOK demodulator.  <br /></td></tr>
<tr class="separator:aac2f43d70b5f94e49e09b4c9f082f46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff4e4e0afaebed727648e1400be538" id="r_a17ff4e4e0afaebed727648e1400be538"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a17ff4e4e0afaebed727648e1400be538">setOokFixedOrFloorThreshold</a> (uint8_t value)</td></tr>
<tr class="memdesc:a17ff4e4e0afaebed727648e1400be538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed threshold for the Data Slicer in OOK mode or floor threshold for the Data Slicer in OOK when Peak mode is used.  <br /></td></tr>
<tr class="separator:a17ff4e4e0afaebed727648e1400be538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ca43e6aad02815fa1507f0f0831c54" id="r_a48ca43e6aad02815fa1507f0f0831c54"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a48ca43e6aad02815fa1507f0f0831c54">setOokPeakThresholdStep</a> (uint8_t value)</td></tr>
<tr class="memdesc:a48ca43e6aad02815fa1507f0f0831c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each decrement of the RSSI threshold in the OOK demodulator.  <br /></td></tr>
<tr class="separator:a48ca43e6aad02815fa1507f0f0831c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1921e1d9fc1d888d2e73bb732e7db7aa" id="r_a1921e1d9fc1d888d2e73bb732e7db7aa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1921e1d9fc1d888d2e73bb732e7db7aa">enableBitSync</a> ()</td></tr>
<tr class="memdesc:a1921e1d9fc1d888d2e73bb732e7db7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bit synchronizer.  <br /></td></tr>
<tr class="separator:a1921e1d9fc1d888d2e73bb732e7db7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8025b05b8f4f2f2abb4cd803b06e2ebd" id="r_a8025b05b8f4f2f2abb4cd803b06e2ebd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8025b05b8f4f2f2abb4cd803b06e2ebd">disableBitSync</a> ()</td></tr>
<tr class="memdesc:a8025b05b8f4f2f2abb4cd803b06e2ebd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Bit synchronizer (not allowed in Packet mode).  <br /></td></tr>
<tr class="separator:a8025b05b8f4f2f2abb4cd803b06e2ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462fa74275e67c296328a01f361892d5" id="r_a462fa74275e67c296328a01f361892d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a462fa74275e67c296328a01f361892d5">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a462fa74275e67c296328a01f361892d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <br /></td></tr>
<tr class="separator:a462fa74275e67c296328a01f361892d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46011b39460e27227a99cc93fdd1484b" id="r_a46011b39460e27227a99cc93fdd1484b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a46011b39460e27227a99cc93fdd1484b">getLoRaRxHeaderInfo</a> (uint8_t *cr, bool *hasCRC)</td></tr>
<tr class="memdesc:a46011b39460e27227a99cc93fdd1484b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LoRa header information from last received packet. Only valid in explicit header mode.  <br /></td></tr>
<tr class="separator:a46011b39460e27227a99cc93fdd1484b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb42d9cd518e9f6408a40753c0be359" id="r_a6fb42d9cd518e9f6408a40753c0be359"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fb42d9cd518e9f6408a40753c0be359">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:a6fb42d9cd518e9f6408a40753c0be359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in FSK mode only.  <br /></td></tr>
<tr class="separator:a6fb42d9cd518e9f6408a40753c0be359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d39296b40e7282ef44d8f376065e92c" id="r_a1d39296b40e7282ef44d8f376065e92c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1d39296b40e7282ef44d8f376065e92c">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:a1d39296b40e7282ef44d8f376065e92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in FSK mode only.  <br /></td></tr>
<tr class="separator:a1d39296b40e7282ef44d8f376065e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ce24df39a164498977b0f532752f6" id="r_a655ce24df39a164498977b0f532752f6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a655ce24df39a164498977b0f532752f6">getNumSymbols</a> (size_t len, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc)</td></tr>
<tr class="memdesc:a655ce24df39a164498977b0f532752f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from bytes to LoRa symbols.  <br /></td></tr>
<tr class="separator:a655ce24df39a164498977b0f532752f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ecbc92c9d70f93211d21399d237d0" id="r_a9e7ecbc92c9d70f93211d21399d237d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9e7ecbc92c9d70f93211d21399d237d0">getTimeOnAir</a> (size_t len) override</td></tr>
<tr class="memdesc:a9e7ecbc92c9d70f93211d21399d237d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <br /></td></tr>
<tr class="separator:a9e7ecbc92c9d70f93211d21399d237d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cb7d326f6d7effb6301d730a24def1" id="r_a99cb7d326f6d7effb6301d730a24def1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a99cb7d326f6d7effb6301d730a24def1">calculateTimeOnAir</a> (ModemType_t modem, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc, size_t len) override</td></tr>
<tr class="memdesc:a99cb7d326f6d7effb6301d730a24def1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size.  <br /></td></tr>
<tr class="separator:a99cb7d326f6d7effb6301d730a24def1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4021380dc557114625dc51262cf90" id="r_adbc4021380dc557114625dc51262cf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adbc4021380dc557114625dc51262cf90">calculateRxTimeout</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeoutUs) override</td></tr>
<tr class="memdesc:adbc4021380dc557114625dc51262cf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time)  <br /></td></tr>
<tr class="separator:adbc4021380dc557114625dc51262cf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22de05835dda9ed287ec48f60ef91f55" id="r_a22de05835dda9ed287ec48f60ef91f55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a22de05835dda9ed287ec48f60ef91f55">getIrqFlags</a> () override</td></tr>
<tr class="memdesc:a22de05835dda9ed287ec48f60ef91f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read currently active IRQ flags.  <br /></td></tr>
<tr class="separator:a22de05835dda9ed287ec48f60ef91f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae42b94ab2ecf729f29f101222e97666" id="r_aae42b94ab2ecf729f29f101222e97666"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aae42b94ab2ecf729f29f101222e97666">setIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:aae42b94ab2ecf729f29f101222e97666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). NOTE: Unlike other modules that support IRQ abstraction (<a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, <a class="el" href="class_l_r11x0.html" title="Base class for LR11x0 series. All derived classes for LR11x0 (e.g. LR1110 or LR1120) inherit from thi...">LR11x0</a>, etc.), <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> cannot configure multiple IRQs to signal using the same DIOx pin. This method tries to configure IRQs in a "best effort" approach, and will skip conflicting flags. RADIOLIB_ERR_INVALID_IRQ will be returned in this case.  <br /></td></tr>
<tr class="separator:aae42b94ab2ecf729f29f101222e97666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3eae13a7f0558c1bc881abebd958242" id="r_aa3eae13a7f0558c1bc881abebd958242"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa3eae13a7f0558c1bc881abebd958242">clearIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:aa3eae13a7f0558c1bc881abebd958242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:aa3eae13a7f0558c1bc881abebd958242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab531ad461b250a060e92d9c744e79070" id="r_ab531ad461b250a060e92d9c744e79070"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab531ad461b250a060e92d9c744e79070">setCrcFiltering</a> (bool enable=true)</td></tr>
<tr class="memdesc:ab531ad461b250a060e92d9c744e79070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CRC filtering and generation.  <br /></td></tr>
<tr class="separator:ab531ad461b250a060e92d9c744e79070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3955f85f456edae772a51025a19029b" id="r_ad3955f85f456edae772a51025a19029b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ad3955f85f456edae772a51025a19029b">setRSSIConfig</a> (uint8_t smoothingSamples, int8_t offset=0)</td></tr>
<tr class="memdesc:ad3955f85f456edae772a51025a19029b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets RSSI measurement configuration in FSK mode.  <br /></td></tr>
<tr class="separator:ad3955f85f456edae772a51025a19029b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2d455012bd28d304589c8164390eb" id="r_abad2d455012bd28d304589c8164390eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abad2d455012bd28d304589c8164390eb">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:abad2d455012bd28d304589c8164390eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING.  <br /></td></tr>
<tr class="separator:abad2d455012bd28d304589c8164390eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2ddb517e474a699b4539653b3754d" id="r_ac5d2ddb517e474a699b4539653b3754d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5d2ddb517e474a699b4539653b3754d">getIRQFlags</a> ()</td></tr>
<tr class="memdesc:ac5d2ddb517e474a699b4539653b3754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads currently active IRQ flags, can be used to check which event caused an interrupt. In LoRa mode, this is the content of SX127X_REG_IRQ_FLAGS register. In FSK mode, this is the contents of SX127X_REG_IRQ_FLAGS_2 (MSB) and SX127X_REG_IRQ_FLAGS_1 (LSB) registers.  <br /></td></tr>
<tr class="separator:ac5d2ddb517e474a699b4539653b3754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6a5bd8f3257f98ee4f250cbdf8bdc" id="r_a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">getModemStatus</a> ()</td></tr>
<tr class="memdesc:a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads modem status. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bc32a555675879ad9e2a9e399dc6c1" id="r_a95bc32a555675879ad9e2a9e399dc6c1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a95bc32a555675879ad9e2a9e399dc6c1">getTempRaw</a> ()</td></tr>
<tr class="memdesc:a95bc32a555675879ad9e2a9e399dc6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uncalibrated temperature value. This function will change operating mode and should not be called during Tx, Rx or CAD.  <br /></td></tr>
<tr class="separator:a95bc32a555675879ad9e2a9e399dc6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca9edcae05060cce3ff7ee58faeb4e2" id="r_a8ca9edcae05060cce3ff7ee58faeb4e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8ca9edcae05060cce3ff7ee58faeb4e2">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a8ca9edcae05060cce3ff7ee58faeb4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.    <br /></td></tr>
<tr class="separator:a8ca9edcae05060cce3ff7ee58faeb4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9625a5246a45112267ce441ac2de254" id="r_ab9625a5246a45112267ce441ac2de254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab9625a5246a45112267ce441ac2de254">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:ab9625a5246a45112267ce441ac2de254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.    <br /></td></tr>
<tr class="separator:ab9625a5246a45112267ce441ac2de254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9877550ed7881be06d00ea190f230fb9" id="r_a9877550ed7881be06d00ea190f230fb9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9877550ed7881be06d00ea190f230fb9">randomByte</a> () override</td></tr>
<tr class="memdesc:a9877550ed7881be06d00ea190f230fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <br /></td></tr>
<tr class="separator:a9877550ed7881be06d00ea190f230fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5324d7d854e7a2f6768221d4f362cd" id="r_aee5324d7d854e7a2f6768221d4f362cd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aee5324d7d854e7a2f6768221d4f362cd">getChipVersion</a> ()</td></tr>
<tr class="memdesc:aee5324d7d854e7a2f6768221d4f362cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return SX1278_CHIP_VERSION (0x12) or SX1272_CHIP_VERSION (0x22) if <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> is connected and working.  <br /></td></tr>
<tr class="separator:aee5324d7d854e7a2f6768221d4f362cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363a436978ba990e1bf7d73f648ad7e9" id="r_a363a436978ba990e1bf7d73f648ad7e9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a363a436978ba990e1bf7d73f648ad7e9">invertIQ</a> (bool enable) override</td></tr>
<tr class="memdesc:a363a436978ba990e1bf7d73f648ad7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable inversion of the I and Q signals.  <br /></td></tr>
<tr class="separator:a363a436978ba990e1bf7d73f648ad7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a9004cc05ff8aba2e9610db31109d" id="r_a333a9004cc05ff8aba2e9610db31109d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a333a9004cc05ff8aba2e9610db31109d">getModem</a> (ModemType_t *modem) override</td></tr>
<tr class="memdesc:a333a9004cc05ff8aba2e9610db31109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modem currently in use by the radio.  <br /></td></tr>
<tr class="separator:a333a9004cc05ff8aba2e9610db31109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd7fb49a3b27707aff6636ff6dee550" id="r_a3bd7fb49a3b27707aff6636ff6dee550"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3bd7fb49a3b27707aff6636ff6dee550">stageMode</a> (RadioModeType_t mode, <a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *cfg) override</td></tr>
<tr class="memdesc:a3bd7fb49a3b27707aff6636ff6dee550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage mode of the radio to be launched later using launchMode.    <br /></td></tr>
<tr class="separator:a3bd7fb49a3b27707aff6636ff6dee550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b43314081e8b3eda95e0011d1e5b9" id="r_a538b43314081e8b3eda95e0011d1e5b9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a538b43314081e8b3eda95e0011d1e5b9">launchMode</a> () override</td></tr>
<tr class="memdesc:a538b43314081e8b3eda95e0011d1e5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch previously staged mode.    <br /></td></tr>
<tr class="separator:a538b43314081e8b3eda95e0011d1e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b99d1bc67ac2c81eeb11dd6793a8c5" id="r_ae4b99d1bc67ac2c81eeb11dd6793a8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae4b99d1bc67ac2c81eeb11dd6793a8c5">setDirectAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ae4b99d1bc67ac2c81eeb11dd6793a8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is received in direct mode.  <br /></td></tr>
<tr class="separator:ae4b99d1bc67ac2c81eeb11dd6793a8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e149fac59b3accbc9550bf605d6bbf0" id="r_a0e149fac59b3accbc9550bf605d6bbf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0e149fac59b3accbc9550bf605d6bbf0">readBit</a> (uint32_t pin) override</td></tr>
<tr class="memdesc:a0e149fac59b3accbc9550bf605d6bbf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <br /></td></tr>
<tr class="separator:a0e149fac59b3accbc9550bf605d6bbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f04a7e883057908df18f06c7f74c7e1" id="r_a7f04a7e883057908df18f06c7f74c7e1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7f04a7e883057908df18f06c7f74c7e1">setFHSSHoppingPeriod</a> (uint8_t freqHoppingPeriod)</td></tr>
<tr class="memdesc:a7f04a7e883057908df18f06c7f74c7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the hopping period and enables FHSS.  <br /></td></tr>
<tr class="separator:a7f04a7e883057908df18f06c7f74c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7600b8b0aac4d8a5e962d631145b617" id="r_ad7600b8b0aac4d8a5e962d631145b617"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ad7600b8b0aac4d8a5e962d631145b617">getFHSSHoppingPeriod</a> (void)</td></tr>
<tr class="memdesc:ad7600b8b0aac4d8a5e962d631145b617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets FHSS hopping period.  <br /></td></tr>
<tr class="separator:ad7600b8b0aac4d8a5e962d631145b617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56340d1bdc69b3efc64636be39445a9c" id="r_a56340d1bdc69b3efc64636be39445a9c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a56340d1bdc69b3efc64636be39445a9c">getFHSSChannel</a> (void)</td></tr>
<tr class="memdesc:a56340d1bdc69b3efc64636be39445a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the FHSS channel in use.  <br /></td></tr>
<tr class="separator:a56340d1bdc69b3efc64636be39445a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41089d9e5b45217d3e31ac22b5326b66" id="r_a41089d9e5b45217d3e31ac22b5326b66"><td class="memItemLeft" align="right" valign="top"><a id="a41089d9e5b45217d3e31ac22b5326b66" name="a41089d9e5b45217d3e31ac22b5326b66"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFHSSInt</b> (void)</td></tr>
<tr class="memdesc:a41089d9e5b45217d3e31ac22b5326b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the FHSS interrupt. <br /></td></tr>
<tr class="separator:a41089d9e5b45217d3e31ac22b5326b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d373bc93e99790912cebe8d5ae6403" id="r_af7d373bc93e99790912cebe8d5ae6403"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af7d373bc93e99790912cebe8d5ae6403">setDIOMapping</a> (uint32_t pin, uint32_t value) override</td></tr>
<tr class="memdesc:af7d373bc93e99790912cebe8d5ae6403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <br /></td></tr>
<tr class="separator:af7d373bc93e99790912cebe8d5ae6403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b85344084b800966a46ace59dcb5277" id="r_a7b85344084b800966a46ace59dcb5277"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b85344084b800966a46ace59dcb5277">setDIOPreambleDetect</a> (bool usePreambleDetect)</td></tr>
<tr class="memdesc:a7b85344084b800966a46ace59dcb5277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO mapping to use RSSI or Preamble Detect for pins that support it.  <br /></td></tr>
<tr class="separator:a7b85344084b800966a46ace59dcb5277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094d0f471aaa428167816d1ac30bb76" id="r_a5094d0f471aaa428167816d1ac30bb76"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5094d0f471aaa428167816d1ac30bb76">setRSSIThreshold</a> (float dbm)</td></tr>
<tr class="memdesc:a5094d0f471aaa428167816d1ac30bb76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RSSI value above which the RSSI interrupt is signaled.  <br /></td></tr>
<tr class="separator:a5094d0f471aaa428167816d1ac30bb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9aa18e13e8390ec437e249e1d2472" id="r_a9ca9aa18e13e8390ec437e249e1d2472"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9ca9aa18e13e8390ec437e249e1d2472">setLowBatteryThreshold</a> (int8_t level, uint32_t pin=RADIOLIB_NC)</td></tr>
<tr class="memdesc:a9ca9aa18e13e8390ec437e249e1d2472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set low battery indicator threshold.  <br /></td></tr>
<tr class="separator:a9ca9aa18e13e8390ec437e249e1d2472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada508497ee2e70170da3afe078e2fe0e" id="r_ada508497ee2e70170da3afe078e2fe0e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ada508497ee2e70170da3afe078e2fe0e">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ada508497ee2e70170da3afe078e2fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ada508497ee2e70170da3afe078e2fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608fabef91defa1e33e6a6787c68ce8" id="r_ae608fabef91defa1e33e6a6787c68ce8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae608fabef91defa1e33e6a6787c68ce8">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0)</td></tr>
<tr class="memdesc:ae608fabef91defa1e33e6a6787c68ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae608fabef91defa1e33e6a6787c68ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79757dbbd62e080c1bad2e608ab940c" id="r_af79757dbbd62e080c1bad2e608ab940c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af79757dbbd62e080c1bad2e608ab940c">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:af79757dbbd62e080c1bad2e608ab940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <br /></td></tr>
<tr class="separator:af79757dbbd62e080c1bad2e608ab940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18664ad615c5507ff1690baaca90b094" id="r_a18664ad615c5507ff1690baaca90b094"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a18664ad615c5507ff1690baaca90b094">startReceive</a> ()</td></tr>
<tr class="memdesc:a18664ad615c5507ff1690baaca90b094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets module to received mode using its default configuration.  <br /></td></tr>
<tr class="separator:a18664ad615c5507ff1690baaca90b094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93500dfbcfd39837e04c0f3eaa40d97" id="r_ae93500dfbcfd39837e04c0f3eaa40d97"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae93500dfbcfd39837e04c0f3eaa40d97">startReceive</a> (uint32_t timeout, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqFlags=RADIOLIB_IRQ_RX_DEFAULT_FLAGS, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqMask=RADIOLIB_IRQ_RX_DEFAULT_MASK, size_t len=0)</td></tr>
<tr class="memdesc:ae93500dfbcfd39837e04c0f3eaa40d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae93500dfbcfd39837e04c0f3eaa40d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300" id="r_a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer" id="r_afc972a84153977d6ccd9e116b6181ad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalLayer</b> ()</td></tr>
<tr class="memdesc:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer" id="r_a7af88f9f75c9778c29002c2b8238a239"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PhysicalLayer</b> ()=default</td></tr>
<tr class="memdesc:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer" id="r_a8a194b0fbb66b1a953288bf3b9478d6e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">setFrequency</a> (float freq)</td></tr>
<tr class="memdesc:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:a8a194b0fbb66b1a953288bf3b9478d6e inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd39ad84b45c6392087b12d59192d8c inherit pub_methods_class_physical_layer" id="r_aedd39ad84b45c6392087b12d59192d8c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">setBitRate</a> (float br)</td></tr>
<tr class="memdesc:aedd39ad84b45c6392087b12d59192d8c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK bit rate. Only available in FSK mode. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:aedd39ad84b45c6392087b12d59192d8c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba04366a0cf05ff3d8227c4f7c8e1e9 inherit pub_methods_class_physical_layer" id="r_aeba04366a0cf05ff3d8227c4f7c8e1e9"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">setDataShaping</a> (uint8_t sh)</td></tr>
<tr class="memdesc:aeba04366a0cf05ff3d8227c4f7c8e1e9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK data shaping. Only available in FSK mode. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:aeba04366a0cf05ff3d8227c4f7c8e1e9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer" id="r_ad2286dc78dbf8e3084f38e9159b99ae5"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">setOutputPower</a> (int8_t power)</td></tr>
<tr class="memdesc:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output power. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:ad2286dc78dbf8e3084f38e9159b99ae5 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1784cb227d04b3f2846625fda6797536 inherit pub_methods_class_physical_layer" id="r_a1784cb227d04b3f2846625fda6797536"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536">checkOutputPower</a> (int8_t power, int8_t *clipped)</td></tr>
<tr class="memdesc:a1784cb227d04b3f2846625fda6797536 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a1784cb227d04b3f2846625fda6797536 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer" id="r_ac5f1e0c24d8bf878f2c9fe729b6e1610"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac5f1e0c24d8bf878f2c9fe729b6e1610">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data rate. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer" id="r_a9c5c902d9f8ffe9866b7f178b14d34f6"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a9c5c902d9f8ffe9866b7f178b14d34f6">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer" id="r_aabc94ab27a9ee6daaafa9b47dde5f75b"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">getRSSI</a> ()</td></tr>
<tr class="memdesc:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator) of the last received packet.  <br /></td></tr>
<tr class="separator:aabc94ab27a9ee6daaafa9b47dde5f75b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer" id="r_ae602ebd46d60da8670c9f353cef695d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae602ebd46d60da8670c9f353cef695d9">getIrqMapped</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from radio-agnostic IRQ flags to radio-specific flags.  <br /></td></tr>
<tr class="separator:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer" id="r_a2c7dd4704e3df353265010710bd26e83"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a2c7dd4704e3df353265010710bd26e83">checkIrq</a> (RadioLibIrqType_t irq)</td></tr>
<tr class="memdesc:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a specific IRQ bit is set (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer" id="r_a8564f9834a0247e93e7620c23559ceb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8564f9834a0247e93e7620c23559ceb8">setIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on specific IRQ bit(s) (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer" id="r_af9a7e739e39705a72ffa8b63ec09bb15"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af9a7e739e39705a72ffa8b63ec09bb15">clearIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer" id="r_a82a52062d9259c2c546d7bf8072b7a72"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a82a52062d9259c2c546d7bf8072b7a72">startChannelScan</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer" id="r_af788cf83ceb0222cd0fa4a1323b9041b"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af788cf83ceb0222cd0fa4a1323b9041b">scanChannel</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer" id="r_acd9171bd71aa80fb86113b612c42de53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer" id="r_a76113e10481743094a1cd0280692b0a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer" id="r_a88a10657bd2215a11a2331f937414b55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer" id="r_a8e378fe136a498ea485a9c10f5e15aab"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer" id="r_ab57182d32646861ef0d865e2740d6b26"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer" id="r_a429796eb2e7ea86781a2e8ca42af43f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropSync</b> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer" id="r_a4d5b30493c8d7fcfb784e128362d596c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer" id="r_a77415bf4ed34be18c92c0cf4b2de7149"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a77415bf4ed34be18c92c0cf4b2de7149">setModem</a> (ModemType_t modem)</td></tr>
<tr class="memdesc:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters.  <br /></td></tr>
<tr class="separator:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer" id="r_aa949616080a463a82bb6ad5075a9e16e"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>freqStep</b></td></tr>
<tr class="memdesc:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency step of the synthesizer in Hz. <br /></td></tr>
<tr class="separator:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer" id="r_a1c04f8fba5eef96e59972004e8abc623"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxPacketLength</b></td></tr>
<tr class="memdesc:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of packet that can be received by the module. <br /></td></tr>
<tr class="separator:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> series. All derived classes for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> (e.g. <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> or <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac74c5914ca429a3892c66b9d98e3ea6c" name="ac74c5914ca429a3892c66b9d98e3ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c5914ca429a3892c66b9d98e3ea6c">&#9670;&#160;</a></span>SX127x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SX127x::SX127x </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. Called internally when creating new LoRa instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the LoRa chip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ddbde7fd8eb06d38abfb658eee29bc1" name="a7ddbde7fd8eb06d38abfb658eee29bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddbde7fd8eb06d38abfb658eee29bc1">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::begin </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>chipVersions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numVersions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method. Will be called with appropriate parameters when calling initialization method from derived class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipVersions</td><td>Array of possible values in SPI version register. Used to verify the connection and hardware version. </td></tr>
    <tr><td class="paramname">numVersions</td><td>Number of possible chip versions. </td></tr>
    <tr><td class="paramname">syncWord</td><td>LoRa sync word. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of LoRa transmission preamble in symbols. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a66fe001474583d490df1d0b38260bf8e" name="a66fe001474583d490df1d0b38260bf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fe001474583d490df1d0b38260bf8e">&#9670;&#160;</a></span>beginFSK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::beginFSK </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>chipVersions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numVersions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FSK modem. Will be called with appropriate parameters when calling FSK initialization method from derived class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipVersions</td><td>Array of possible values in SPI version register. Used to verify the connection and hardware version. </td></tr>
    <tr><td class="paramname">numVersions</td><td>Number of possible chip versions. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation of the FSK transmission in kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of FSK preamble in bits. </td></tr>
    <tr><td class="paramname">enableOOK</td><td>Flag to specify OOK mode. This modulation is similar to FSK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adbc4021380dc557114625dc51262cf90" name="adbc4021380dc557114625dc51262cf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc4021380dc557114625dc51262cf90">&#9670;&#160;</a></span>calculateRxTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> SX127x::calculateRxTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeoutUs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the timeout value for this specific module / series (in number of symbols or units of time) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeoutUs</td><td>Timeout in microseconds to listen for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Timeout value in a unit that is specific for the used module </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7f8d12a90158864a8ebc471b0ec89dc9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a99cb7d326f6d7effb6301d730a24def1" name="a99cb7d326f6d7effb6301d730a24def1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cb7d326f6d7effb6301d730a24def1">&#9670;&#160;</a></span>calculateTimeOnAir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> SX127x::calculateTimeOnAir </td>
          <td>(</td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_packet_config__t.html">PacketConfig_t</a>&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modem</td><td>Modem type. </td></tr>
    <tr><td class="paramname">dr</td><td>Data rate. </td></tr>
    <tr><td class="paramname">pc</td><td>Packet config. </td></tr>
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expected time-on-air in microseconds. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ac1974cb6218782c557a673aeb4a99928">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0ce9beca21406e3556b3518370947ee2" name="a0ce9beca21406e3556b3518370947ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce9beca21406e3556b3518370947ee2">&#9670;&#160;</a></span>clearChannelScanAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::clearChannelScanAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears interrupt service routine to call when a channel scan is finished. </p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a169a4d04c5c50d3336e274d70930d9f6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa3eae13a7f0558c1bc881abebd958242" name="aa3eae13a7f0558c1bc881abebd958242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3eae13a7f0558c1bc881abebd958242">&#9670;&#160;</a></span>clearIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::clearIrqFlags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>Module-specific IRQ flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ac282bb78da4f4da4661dce191cbd6d87">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6cbc4c256d37f9cdabf9e5f2ef16aa92" name="a6cbc4c256d37f9cdabf9e5f2ef16aa92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbc4c256d37f9cdabf9e5f2ef16aa92">&#9670;&#160;</a></span>clearPacketReceivedAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::clearPacketReceivedAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears interrupt service routine to call when a packet is received. </p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7edf27f03600b96f72f011fc82fa4ef9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2ec32a52b13752d75f3076a5868c312d" name="a2ec32a52b13752d75f3076a5868c312d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec32a52b13752d75f3076a5868c312d">&#9670;&#160;</a></span>clearPacketSentAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::clearPacketSentAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears interrupt service routine to call when a packet is sent. </p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a67ee4ec36f352d06dda0102260f6bfce">PhysicalLayer</a>.</p>

</div>
</div>
<a id="afe6e9bbfd75f9cad26f9f72c34c4ada5" name="afe6e9bbfd75f9cad26f9f72c34c4ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6e9bbfd75f9cad26f9f72c34c4ada5">&#9670;&#160;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables FSK address filtering. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a8025b05b8f4f2f2abb4cd803b06e2ebd" name="a8025b05b8f4f2f2abb4cd803b06e2ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8025b05b8f4f2f2abb4cd803b06e2ebd">&#9670;&#160;</a></span>disableBitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::disableBitSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable Bit synchronizer (not allowed in Packet mode). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1921e1d9fc1d888d2e73bb732e7db7aa" name="a1921e1d9fc1d888d2e73bb732e7db7aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1921e1d9fc1d888d2e73bb732e7db7aa">&#9670;&#160;</a></span>enableBitSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::enableBitSync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Bit synchronizer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a36dbd1697a415c6db3b47cd620c8c02e" name="a36dbd1697a415c6db3b47cd620c8c02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36dbd1697a415c6db3b47cd620c8c02e">&#9670;&#160;</a></span>fifoAdd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SX127x::fifoAdd </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>remLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the transmission buffer. </td></tr>
    <tr><td class="paramname">totalLen</td><td>Total number of bytes to transmit. </td></tr>
    <tr><td class="paramname">remLen</td><td>Pointer to a counter holding the number of bytes that have been transmitted so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when a complete packet is sent, false if more data is needed. </dd></dl>

</div>
</div>
<a id="a25b193b71ddb6015d25b0a161809d75a" name="a25b193b71ddb6015d25b0a161809d75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b193b71ddb6015d25b0a161809d75a">&#9670;&#160;</a></span>fifoGet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SX127x::fifoGet </td>
          <td>(</td>
          <td class="paramtype">volatile uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>totalLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>rcvLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when FIFO is sufficiently full to read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to a buffer that stores the receive data. </td></tr>
    <tr><td class="paramname">totalLen</td><td>Total number of bytes to receive. </td></tr>
    <tr><td class="paramname">rcvLen</td><td>Pointer to a counter holding the number of bytes that have been received so far. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True when a complete packet is received, false if more data is needed. </dd></dl>

</div>
</div>
<a id="acaec05c056dacb2c2171eaa8521be4bb" name="acaec05c056dacb2c2171eaa8521be4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaec05c056dacb2c2171eaa8521be4bb">&#9670;&#160;</a></span>finishReceive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::finishReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after reception is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8d8997a3fdeaede52d9354d3bf310bf4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7fd9cec52b7fbd0c69cbd861dc17549f" name="a7fd9cec52b7fbd0c69cbd861dc17549f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9cec52b7fbd0c69cbd861dc17549f">&#9670;&#160;</a></span>finishTransmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::finishTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after transmission is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1de26f68b939f5af79ec29cc34c7be18">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6fb42d9cd518e9f6408a40753c0be359" name="a6fb42d9cd518e9f6408a40753c0be359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb42d9cd518e9f6408a40753c0be359">&#9670;&#160;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5094ba2d9268340b7aba99afe5da0544" name="a5094ba2d9268340b7aba99afe5da0544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5094ba2d9268340b7aba99afe5da0544">&#9670;&#160;</a></span>getAFCError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getAFCError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets current AFC error. </p>
<dl class="section return"><dt>Returns</dt><dd>Frequency offset from RF in Hz if AFC is enabled and triggered, zero otherwise. </dd></dl>

</div>
</div>
<a id="a81189ce77541d78fc8feb99c2a3f35b2" name="a81189ce77541d78fc8feb99c2a3f35b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81189ce77541d78fc8feb99c2a3f35b2">&#9670;&#160;</a></span>getChannelScanResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::getChannelScanResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the channel scan result. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a63979795a7b53557560bb95b65480906">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aee5324d7d854e7a2f6768221d4f362cd" name="aee5324d7d854e7a2f6768221d4f362cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5324d7d854e7a2f6768221d4f362cd">&#9670;&#160;</a></span>getChipVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::getChipVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read version SPI register. Should return SX1278_CHIP_VERSION (0x12) or SX1272_CHIP_VERSION (0x22) if <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> is connected and working. </p>
<dl class="section return"><dt>Returns</dt><dd>Version register contents or <a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adc25b685de0859b799488bf7729350b6" name="adc25b685de0859b799488bf7729350b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25b685de0859b799488bf7729350b6">&#9670;&#160;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getDataRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get data rate of the latest transmitted packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Last packet data rate in bps (bits per second). </dd></dl>

</div>
</div>
<a id="a56340d1bdc69b3efc64636be39445a9c" name="a56340d1bdc69b3efc64636be39445a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56340d1bdc69b3efc64636be39445a9c">&#9670;&#160;</a></span>getFHSSChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::getFHSSChannel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the FHSS channel in use. </p>
<dl class="section return"><dt>Returns</dt><dd>6 bit channel number </dd></dl>

</div>
</div>
<a id="ad7600b8b0aac4d8a5e962d631145b617" name="ad7600b8b0aac4d8a5e962d631145b617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7600b8b0aac4d8a5e962d631145b617">&#9670;&#160;</a></span>getFHSSHoppingPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::getFHSSHoppingPeriod </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets FHSS hopping period. </p>
<dl class="section return"><dt>Returns</dt><dd>8 bit period </dd></dl>

</div>
</div>
<a id="af6aa854a2668d70f4d3a374a49440362" name="af6aa854a2668d70f4d3a374a49440362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aa854a2668d70f4d3a374a49440362">&#9670;&#160;</a></span>getFrequencyError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getFrequencyError </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoCorrect</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets frequency error of the latest received packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoCorrect</td><td>When set to true, frequency will be automatically corrected. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frequency error in Hz. </dd></dl>

</div>
</div>
<a id="ac5d2ddb517e474a699b4539653b3754d" name="ac5d2ddb517e474a699b4539653b3754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d2ddb517e474a699b4539653b3754d">&#9670;&#160;</a></span>getIRQFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t SX127x::getIRQFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads currently active IRQ flags, can be used to check which event caused an interrupt. In LoRa mode, this is the content of SX127X_REG_IRQ_FLAGS register. In FSK mode, this is the contents of SX127X_REG_IRQ_FLAGS_2 (MSB) and SX127X_REG_IRQ_FLAGS_1 (LSB) registers. </p>
<dl class="section return"><dt>Returns</dt><dd>IRQ flags. </dd></dl>

</div>
</div>
<a id="a22de05835dda9ed287ec48f60ef91f55" name="a22de05835dda9ed287ec48f60ef91f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22de05835dda9ed287ec48f60ef91f55">&#9670;&#160;</a></span>getIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SX127x::getIrqFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read currently active IRQ flags. </p>
<dl class="section return"><dt>Returns</dt><dd>IRQ flags. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1caeed34b2e2ff0355467507106a1a2">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a46011b39460e27227a99cc93fdd1484b" name="a46011b39460e27227a99cc93fdd1484b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46011b39460e27227a99cc93fdd1484b">&#9670;&#160;</a></span>getLoRaRxHeaderInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::getLoRaRxHeaderInfo </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>hasCRC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get LoRa header information from last received packet. Only valid in explicit header mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>Pointer to variable to store the coding rate. </td></tr>
    <tr><td class="paramname">hasCRC</td><td>Pointer to variable to store the CRC status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a333a9004cc05ff8aba2e9610db31109d" name="a333a9004cc05ff8aba2e9610db31109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333a9004cc05ff8aba2e9610db31109d">&#9670;&#160;</a></span>getModem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::getModem </td>
          <td>(</td>
          <td class="paramtype">ModemType_t *&#160;</td>
          <td class="paramname"><em>modem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get modem currently in use by the radio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modem</td><td>Pointer to a variable to save the retrieved configuration into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af061879bf694735297593c048d04a196">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2cf6a5bd8f3257f98ee4f250cbdf8bdc" name="a2cf6a5bd8f3257f98ee4f250cbdf8bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">&#9670;&#160;</a></span>getModemStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::getModemStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads modem status. Only available in LoRa mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Modem status. </dd></dl>

</div>
</div>
<a id="a655ce24df39a164498977b0f532752f6" name="a655ce24df39a164498977b0f532752f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ce24df39a164498977b0f532752f6">&#9670;&#160;</a></span>getNumSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getNumSymbols </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_packet_config__t.html">PacketConfig_t</a>&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert from bytes to LoRa symbols. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
    <tr><td class="paramname">dr</td><td>Data rate. </td></tr>
    <tr><td class="paramname">pc</td><td>Packet configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of LoRa symbols, including preamble, sync and possible header. </dd></dl>

</div>
</div>
<a id="a462fa74275e67c296328a01f361892d5" name="a462fa74275e67c296328a01f361892d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462fa74275e67c296328a01f361892d5">&#9670;&#160;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SX127x::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2fe95169b5cdc8cabe1f2af66cad6ef6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a47b3f7464303085d34191dd334c1976f" name="a47b3f7464303085d34191dd334c1976f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47b3f7464303085d34191dd334c1976f">&#9670;&#160;</a></span>getSNR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets signal-to-noise ratio of the latest received packet. Only available in LoRa mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Last packet signal-to-noise ratio (SNR). </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a95bc32a555675879ad9e2a9e399dc6c1" name="a95bc32a555675879ad9e2a9e399dc6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bc32a555675879ad9e2a9e399dc6c1">&#9670;&#160;</a></span>getTempRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t SX127x::getTempRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads uncalibrated temperature value. This function will change operating mode and should not be called during Tx, Rx or CAD. </p>
<dl class="section return"><dt>Returns</dt><dd>Uncalibrated temperature sensor reading. </dd></dl>

</div>
</div>
<a id="a9e7ecbc92c9d70f93211d21399d237d0" name="a9e7ecbc92c9d70f93211d21399d237d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7ecbc92c9d70f93211d21399d237d0">&#9670;&#160;</a></span>getTimeOnAir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> SX127x::getTimeOnAir </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get expected time-on-air for a given size of payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expected time-on-air in microseconds. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a50e730a894f60b58034507ad7730dd3c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a363a436978ba990e1bf7d73f648ad7e9" name="a363a436978ba990e1bf7d73f648ad7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363a436978ba990e1bf7d73f648ad7e9">&#9670;&#160;</a></span>invertIQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::invertIQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable inversion of the I and Q signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>IQ inversion enabled (true) or disabled (false); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a11b4c6d0bf3ae7b9ca04e9434180feab">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5b79dae55315cdf25e530db77eeb140f" name="a5b79dae55315cdf25e530db77eeb140f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b79dae55315cdf25e530db77eeb140f">&#9670;&#160;</a></span>invertPreamble()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::invertPreamble </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invert FSK preamble polarity. The default (non-inverted) is 0x55, the inverted is 0xAA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Preamble polarity in FSK mode - 0xAA when true, 0x55 when false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a538b43314081e8b3eda95e0011d1e5b9" name="a538b43314081e8b3eda95e0011d1e5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538b43314081e8b3eda95e0011d1e5b9">&#9670;&#160;</a></span>launchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::launchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch previously staged mode.   </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a>   </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a5c5977bc9f54f21665b022a99e6c87cc">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0995088d37689a3c240a1af791df6cf1" name="a0995088d37689a3c240a1af791df6cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0995088d37689a3c240a1af791df6cf1">&#9670;&#160;</a></span>packetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::packetMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables direct mode and enables packet mode, allowing the module to receive packets. Can only be activated in FSK mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a9877550ed7881be06d00ea190f230fb9" name="a9877550ed7881be06d00ea190f230fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9877550ed7881be06d00ea190f230fb9">&#9670;&#160;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0e149fac59b3accbc9550bf605d6bbf0" name="a0e149fac59b3accbc9550bf605d6bbf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e149fac59b3accbc9550bf605d6bbf0">&#9670;&#160;</a></span>readBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::readBit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to read and process data bit in direct reception mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin on which to read. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3563453988a83d22dd07d4691543a300" name="a3563453988a83d22dd07d4691543a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563453988a83d22dd07d4691543a300">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abfc840e8d6fe5e222f0143be17876745" name="abfc840e8d6fe5e222f0143be17876745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc840e8d6fe5e222f0143be17876745">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae608fabef91defa1e33e6a6787c68ce8" name="ae608fabef91defa1e33e6a6787c68ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae608fabef91defa1e33e6a6787c68ce8">&#9670;&#160;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Packet length, needed for some modules under special circumstances (e.g. LoRa implicit header mode). </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a53d6b2d3cb8ce3ebb50adb35430dfd3c" name="a53d6b2d3cb8ce3ebb50adb35430dfd3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d6b2d3cb8ce3ebb50adb35430dfd3c">&#9670;&#160;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Will attempt to receive arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8" title="Binary receive method. Must be implemented in module class.">PhysicalLayer::receive</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa7ac558d537c6364c4bc82c8f33e398f" name="aa7ac558d537c6364c4bc82c8f33e398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ac558d537c6364c4bc82c8f33e398f">&#9670;&#160;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct reception mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad9d1dbb2041e87af5a80e12f125a60e6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a15f510359be44fd633037810587f1ea2" name="a15f510359be44fd633037810587f1ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f510359be44fd633037810587f1ea2">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset method. Will reset the chip to the default state using RST pin. Should be implemented in derived class since <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a> and <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> implementations differ. </p>

<p>Reimplemented in <a class="el" href="class_s_x1272.html#a0978cc9ecbb7b9d3a017c133506e57ac">SX1272</a>, and <a class="el" href="class_s_x1278.html#a6d60902ac59b653a9eb83e82a932f7ad">SX1278</a>.</p>

</div>
</div>
<a id="a13ae97e18744dc617bc9326cfbaad3a3" name="a13ae97e18744dc617bc9326cfbaad3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ae97e18744dc617bc9326cfbaad3a3">&#9670;&#160;</a></span>scanChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::scanChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scan for valid LoRa preamble in the current channel. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abd9e39cc745acbf084cfa0d3f4d10718">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a41f8cfcc2cdeb25a8e5a03f1ba4edd1e" name="a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">&#9670;&#160;</a></span>setAFC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFC </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables FSK automatic frequency correction(AFC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isEnabled</td><td>AFC enabled or disabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab0f67330124cefc07a462e77922453d0" name="ab0f67330124cefc07a462e77922453d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f67330124cefc07a462e77922453d0">&#9670;&#160;</a></span>setAFCAGCTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFCAGCTrigger </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls trigger of AFC and AGC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>one from SX127X_RX_TRIGGER_NONE, SX127X_RX_TRIGGER_RSSI_INTERRUPT, SX127X_RX_TRIGGER_PREAMBLE_DETECT, SX127X_RX_TRIGGER_BOTH </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef" name="a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">&#9670;&#160;</a></span>setAFCBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFCBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>afcBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK automatic frequency correction bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">afcBw</td><td>Receiver AFC bandwidth to be set (in kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abc51ce6718153e4963128f25bb5aab40" name="abc51ce6718153e4963128f25bb5aab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc51ce6718153e4963128f25bb5aab40">&#9670;&#160;</a></span>setBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setBroadcastAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>broadAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK broadcast address. Calling this method will enable address filtering. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadAddr</td><td>Broadcast address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac23c2b384ae8611d59e10ef6a14fe7e4" name="ac23c2b384ae8611d59e10ef6a14fe7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23c2b384ae8611d59e10ef6a14fe7e4">&#9670;&#160;</a></span>setChannelScanAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setChannelScanAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a channel scan is finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab531ad461b250a060e92d9c744e79070" name="ab531ad461b250a060e92d9c744e79070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab531ad461b250a060e92d9c744e79070">&#9670;&#160;</a></span>setCrcFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setCrcFiltering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable CRC filtering and generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set or unset CRC filtering and generation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a400575e3d83977bd250c5cb382fc7002" name="a400575e3d83977bd250c5cb382fc7002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400575e3d83977bd250c5cb382fc7002">&#9670;&#160;</a></span>setCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>currentLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets current limit for over current protection at transmitter amplifier. Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentLimit</td><td>Current limit to be set (in mA). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae75bc48cc74a407370cd9f4bf95e9e30" name="ae75bc48cc74a407370cd9f4bf95e9e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75bc48cc74a407370cd9f4bf95e9e30">&#9670;&#160;</a></span>setDio0Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDio0Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when DIO0 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
    <tr><td class="paramname">dir</td><td>Signal change direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b4bce81839b105c464ebf922602e58b" name="a7b4bce81839b105c464ebf922602e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b4bce81839b105c464ebf922602e58b">&#9670;&#160;</a></span>setDio1Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDio1Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when DIO1 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
    <tr><td class="paramname">dir</td><td>Signal change direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7d373bc93e99790912cebe8d5ae6403" name="af7d373bc93e99790912cebe8d5ae6403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d373bc93e99790912cebe8d5ae6403">&#9670;&#160;</a></span>setDIOMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setDIOMapping </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure DIO pin mapping to get a given signal on a DIO pin (if available). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin number onto which a signal is to be placed. </td></tr>
    <tr><td class="paramname">value</td><td>The value that indicates which function to place on that pin. See chip datasheet for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7b85344084b800966a46ace59dcb5277" name="a7b85344084b800966a46ace59dcb5277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b85344084b800966a46ace59dcb5277">&#9670;&#160;</a></span>setDIOPreambleDetect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setDIOPreambleDetect </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>usePreambleDetect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure DIO mapping to use RSSI or Preamble Detect for pins that support it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usePreambleDetect</td><td>Whether to use PreambleDetect (true) or RSSI (false) on the pins that are mapped to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae4b99d1bc67ac2c81eeb11dd6793a8c5" name="ae4b99d1bc67ac2c81eeb11dd6793a8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b99d1bc67ac2c81eeb11dd6793a8c5">&#9670;&#160;</a></span>setDirectAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDirectAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when data bit is received in direct mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abad2d455012bd28d304589c8164390eb" name="abad2d455012bd28d304589c8164390eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad2d455012bd28d304589c8164390eb">&#9670;&#160;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acb45b2342400a03a914a91d2ac7fb488">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7f04a7e883057908df18f06c7f74c7e1" name="a7f04a7e883057908df18f06c7f74c7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f04a7e883057908df18f06c7f74c7e1">&#9670;&#160;</a></span>setFHSSHoppingPeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setFHSSHoppingPeriod </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>freqHoppingPeriod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the hopping period and enables FHSS. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqHoppingPeriod</td><td>Integer multiple of symbol periods between hops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6fbdfd8e2a2ad1eb7e59a73385847acb" name="a6fbdfd8e2a2ad1eb7e59a73385847acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbdfd8e2a2ad1eb7e59a73385847acb">&#9670;&#160;</a></span>setFifoEmptyAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setFifoEmptyAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when FIFO is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a201c31366f32c41b801724fb662265c1" name="a201c31366f32c41b801724fb662265c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201c31366f32c41b801724fb662265c1">&#9670;&#160;</a></span>setFifoFullAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setFifoFullAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when FIFO is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b9529ac87f62c32c9c5fac3dc6e08a9" name="a7b9529ac87f62c32c9c5fac3dc6e08a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9529ac87f62c32c9c5fac3dc6e08a9">&#9670;&#160;</a></span>setFifoThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setFifoThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set FIFO threshold level. Be aware that threshold is also set in setFifoFullAction method. setFifoThreshold method must be called AFTER calling setFifoFullAction! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>Threshold level in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a448ea8a6a6011a9cdddd4e09bd6c9679" name="a448ea8a6a6011a9cdddd4e09bd6c9679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448ea8a6a6011a9cdddd4e09bd6c9679">&#9670;&#160;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK frequency deviation from carrier frequency. Allowed values depend on bit rate setting and must be lower than 200 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>Frequency deviation to be set (in kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2f4f9b428d9ea9af886ca85e5088ed7b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aae42b94ab2ecf729f29f101222e97666" name="aae42b94ab2ecf729f29f101222e97666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae42b94ab2ecf729f29f101222e97666">&#9670;&#160;</a></span>setIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setIrqFlags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). NOTE: Unlike other modules that support IRQ abstraction (<a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, <a class="el" href="class_l_r11x0.html" title="Base class for LR11x0 series. All derived classes for LR11x0 (e.g. LR1110 or LR1120) inherit from thi...">LR11x0</a>, etc.), <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> cannot configure multiple IRQs to signal using the same DIOx pin. This method tries to configure IRQs in a "best effort" approach, and will skip conflicting flags. RADIOLIB_ERR_INVALID_IRQ will be returned in this case. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>Module-specific IRQ flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af88dcb54dc8e9a1edaf9f1c3e5ee2b74">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9ca9aa18e13e8390ec437e249e1d2472" name="a9ca9aa18e13e8390ec437e249e1d2472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca9aa18e13e8390ec437e249e1d2472">&#9670;&#160;</a></span>setLowBatteryThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setLowBatteryThreshold </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em> = <code>RADIOLIB_NC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set low battery indicator threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Battery threshold level (one of RADIOLIB_SX127X_LOW_BAT_THRESHOLD_*), or -1 to disable the detector. Disabled by default. Note that this will not attach any interrupts! </td></tr>
    <tr><td class="paramname">pin</td><td>DIO pin number which will be used to signal low battery. Only DIO0/4 can be used (in packet mode) or DIO3/4 (in continuous mode). Ignored when disabling the detector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab99630d50672b43fc7162ba8f3293f95" name="ab99630d50672b43fc7162ba8f3293f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99630d50672b43fc7162ba8f3293f95">&#9670;&#160;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK node address. Calling this method will enable address filtering. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a24ef0af19a6b8954f956a3c3ad4286ee" name="a24ef0af19a6b8954f956a3c3ad4286ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef0af19a6b8954f956a3c3ad4286ee">&#9670;&#160;</a></span>setOOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOOK </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables OOK modulation instead of FSK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableOOK</td><td>Enable (true) or disable (false) OOK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a17ff4e4e0afaebed727648e1400be538" name="a17ff4e4e0afaebed727648e1400be538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff4e4e0afaebed727648e1400be538">&#9670;&#160;</a></span>setOokFixedOrFloorThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokFixedOrFloorThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed threshold for the Data Slicer in OOK mode or floor threshold for the Data Slicer in OOK when Peak mode is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Threshold level in steps of 0.5 dB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aac2f43d70b5f94e49e09b4c9f082f46d" name="aac2f43d70b5f94e49e09b4c9f082f46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2f43d70b5f94e49e09b4c9f082f46d">&#9670;&#160;</a></span>setOokPeakThresholdDecrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokPeakThresholdDecrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period of decrement of the RSSI threshold in the OOK demodulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Use defines RADIOLIB_SX127X_OOK_PEAK_THRESH_DEC_X_X_CHIP </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a48ca43e6aad02815fa1507f0f0831c54" name="a48ca43e6aad02815fa1507f0f0831c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ca43e6aad02815fa1507f0f0831c54">&#9670;&#160;</a></span>setOokPeakThresholdStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokPeakThresholdStep </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of each decrement of the RSSI threshold in the OOK demodulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Step size: RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_0_5_DB (default), RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_1_0_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_1_5_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_2_0_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_3_0_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_4_0_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_5_0_DB, RADIOLIB_SX127X_OOK_PEAK_THRESH_STEP_6_0_DB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a8b93142202167270db109d18b743c744" name="a8b93142202167270db109d18b743c744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b93142202167270db109d18b743c744">&#9670;&#160;</a></span>setOokThresholdType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokThresholdType </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the type of threshold in the OOK data slicer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Threshold type: SX127X_OOK_THRESH_PEAK(default), SX127X_OOK_THRESH_FIXED, SX127X_OOK_THRESH_AVERAGE </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae236a467095fb5364d0fc4a98d85f96e" name="ae236a467095fb5364d0fc4a98d85f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae236a467095fb5364d0fc4a98d85f96e">&#9670;&#160;</a></span>setPacketReceivedAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setPacketReceivedAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aec928bb26f65752aa20cd236fbabb95c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3530e8e19cfe4d96fe49ca4e6386b099" name="a3530e8e19cfe4d96fe49ca4e6386b099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3530e8e19cfe4d96fe49ca4e6386b099">&#9670;&#160;</a></span>setPacketSentAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setPacketSentAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a32b512b34f6575b2109ae3c3f35d1369">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a844499bace6ae001446d71bee2877656" name="a844499bace6ae001446d71bee2877656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844499bace6ae001446d71bee2877656">&#9670;&#160;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>preambleLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets LoRa or FSK preamble length. Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set (in symbols when in LoRa mode or bits in FSK mode). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a85db1ff64e6c56e054f276c511194633">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a8ca9edcae05060cce3ff7ee58faeb4e2" name="a8ca9edcae05060cce3ff7ee58faeb4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca9edcae05060cce3ff7ee58faeb4e2">&#9670;&#160;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.   </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<p>When more than two pins or more control over the output values are needed, use the <a class="el" href="class_s_x127x.html#ab9625a5246a45112267ce441ac2de254" title="Some modules contain external RF switch controlled by pins. This function gives RadioLib control over...">setRfSwitchTable()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin. </td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9625a5246a45112267ce441ac2de254" name="ab9625a5246a45112267ce441ac2de254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9625a5246a45112267ce441ac2de254">&#9670;&#160;</a></span>setRfSwitchTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setRfSwitchTable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>pins</em>[Module::RFSWITCH_MAX_PINS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.   </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pins</td><td>A reference to an array of pins to control. This should always be an array of 3 elements. If you need less pins, use RADIOLIB_NC for the unused elements.</td></tr>
    <tr><td class="paramname">table</td><td>A reference to an array of pin values to use for each supported mode. Each element is an RfSwitchMode_T struct that lists the mode for which it applies and the values for each of the pins passed in the pins argument respectively.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>pins</code> array will be copied into the <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> object, so the original array can be deallocated after this call. However, a reference to the <code>table</code> array will be stored, so that array must remain valid as long RadioLib is being used.</p>
<p>The <code>mode</code> field in each table row should normally use any of the <code>MODE_*</code> constants from the <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf" title="Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios,...">Module::OpMode_t</a> enum. However, some radios support additional modes and will define their own OpMode_t enum.</p>
<p>The length of the table is variable (to support radios that add additional modes), so the table must always be terminated with the special END_OF_MODE_TABLE value.</p>
<p>Normally all modes should be listed in the table, but for some radios, modes can be omitted to indicate they are not supported (e.g. when a radio has a high power and low power TX mode but external circuitry only supports low power). If applicable, this is documented in the radio class itself.</p>
<h4>Example</h4>
<p>For example, on a board that has an RF switch with an enable pin connected to PA0 and a TX/RX select pin connected to PA1:</p>
<div class="fragment"><div class="line"><span class="comment">// In global scope, define the pin array and mode table</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t rfswitch_pins[] =</div>
<div class="line">                       {PA0,  PA1,  RADIOLIB_NC};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> rfswitch_table[] = {</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a>,  {LOW,  LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a>,    {HIGH, LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a>,    {HIGH, HIGH}},</div>
<div class="line">   Module::END_OF_MODE_TABLE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Then somewhere in setup, pass them to radiolib</span></div>
<div class="line">  radio.setRfSwitchTable(rfswitch_pins, rfswitch_table);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a></div><div class="ttdeci">@ MODE_TX</div><div class="ttdoc">Transmission mode.</div><div class="ttdef"><b>Definition</b> Module.h:119</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a></div><div class="ttdeci">@ MODE_IDLE</div><div class="ttdoc">Idle mode.</div><div class="ttdef"><b>Definition</b> Module.h:113</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a></div><div class="ttdeci">@ MODE_RX</div><div class="ttdoc">Receive mode.</div><div class="ttdef"><b>Definition</b> Module.h:116</div></div>
<div class="ttc" id="astruct_module_1_1_rf_switch_mode__t_html"><div class="ttname"><a href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a></div><div class="ttdoc">Description of RF switch pin states for a single mode. See setRfSwitchTable for details.</div><div class="ttdef"><b>Definition</b> Module.h:89</div></div>
</div><!-- fragment -->   
</div>
</div>
<a id="ad3955f85f456edae772a51025a19029b" name="ad3955f85f456edae772a51025a19029b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3955f85f456edae772a51025a19029b">&#9670;&#160;</a></span>setRSSIConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setRSSIConfig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>smoothingSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets RSSI measurement configuration in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smoothingSamples</td><td>Number of samples taken to average the RSSI result. numSamples = 2 ^ (1 + smoothingSamples), allowed values are in range 0 (2 samples) - 7 (256 samples) </td></tr>
    <tr><td class="paramname">offset</td><td>Signed RSSI offset that will be automatically compensated. 1 dB per LSB, defaults to 0, allowed values are in range -16 dB to +15 dB. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5094d0f471aaa428167816d1ac30bb76" name="a5094d0f471aaa428167816d1ac30bb76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5094d0f471aaa428167816d1ac30bb76">&#9670;&#160;</a></span>setRSSIThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setRSSIThreshold </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dbm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RSSI value above which the RSSI interrupt is signaled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dbm</td><td>A dBm value between -127.5 and 0 inclusive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2cc53b9f9d90647c5709cb974779cf53" name="a2cc53b9f9d90647c5709cb974779cf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc53b9f9d90647c5709cb974779cf53">&#9670;&#160;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK receiver bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth to be set (in kHz). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aaf400f33e17c1679c0b55cd70bef90b0" name="aaf400f33e17c1679c0b55cd70bef90b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf400f33e17c1679c0b55cd70bef90b0">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK sync word. Allowed sync words are up to 8 bytes long and can not contain null bytes. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Sync word array. </td></tr>
    <tr><td class="paramname">len</td><td>Sync word length (in bytes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a6c71cdc1238e1368274670758431a977">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ac5c7f4584352a12390594395d9c29bde" name="ac5c7f4584352a12390594395d9c29bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c7f4584352a12390594395d9c29bde">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa sync word. Only available in LoRa mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Sync word to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1ff85ee7979da08b4e66316f1ba2c6a9" name="a1ff85ee7979da08b4e66316f1ba2c6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff85ee7979da08b4e66316f1ba2c6a9">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the LoRa module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3bd7fb49a3b27707aff6636ff6dee550" name="a3bd7fb49a3b27707aff6636ff6dee550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd7fb49a3b27707aff6636ff6dee550">&#9670;&#160;</a></span>stageMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::stageMode </td>
          <td>(</td>
          <td class="paramtype">RadioModeType_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stage mode of the radio to be launched later using launchMode.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Radio mode to prepare. </td></tr>
    <tr><td class="paramname">cfg</td><td>Configuration of this mode (mode-dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a>   </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a06fa3b844c6028a78e29b7dff58c7c79">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a760b8c5103128f122fbe489c6529ce41" name="a760b8c5103128f122fbe489c6529ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b8c5103128f122fbe489c6529ce41">&#9670;&#160;</a></span>standby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the LoRa module to standby. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acbcaf6aefcb77a354797e66222fe5018">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa565bbff460e487672953dc05d335cb0" name="aa565bbff460e487672953dc05d335cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa565bbff460e487672953dc05d335cb0">&#9670;&#160;</a></span>standby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the LoRa module to standby. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Standby mode to be used. No effect, implemented only for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6fa5723724393576ed597509200e17d1" name="a6fa5723724393576ed597509200e17d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa5723724393576ed597509200e17d1">&#9670;&#160;</a></span>startChannelScan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::startChannelScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven channel activity detection method. DIO0 will be activated when LoRa preamble is detected. DIO1 will be activated if there's no preamble detected before timeout. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae30dfbb5445bb674898fc54f5f90b2f9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a18664ad615c5507ff1690baaca90b094" name="a18664ad615c5507ff1690baaca90b094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18664ad615c5507ff1690baaca90b094">&#9670;&#160;</a></span>startReceive() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets module to received mode using its default configuration. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abbe1076252a366c3c4aa323fdff7d40c" name="abbe1076252a366c3c4aa323fdff7d40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe1076252a366c3c4aa323fdff7d40c">&#9670;&#160;</a></span>startReceive() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae93500dfbcfd39837e04c0f3eaa40d97" name="ae93500dfbcfd39837e04c0f3eaa40d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93500dfbcfd39837e04c0f3eaa40d97">&#9670;&#160;</a></span>startReceive() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a>&#160;</td>
          <td class="paramname"><em>irqFlags</em> = <code>RADIOLIB_IRQ_RX_DEFAULT_FLAGS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a>&#160;</td>
          <td class="paramname"><em>irqMask</em> = <code>RADIOLIB_IRQ_RX_DEFAULT_MASK</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Raw timeout value. Some modules use this argument to specify operation mode (single vs. continuous receive). </td></tr>
    <tr><td class="paramname">irqFlags</td><td>Sets the IRQ flags. </td></tr>
    <tr><td class="paramname">irqMask</td><td>Sets the mask of IRQ flags that will trigger the radio interrupt pin. </td></tr>
    <tr><td class="paramname">len</td><td>Packet length, needed for some modules under special circumstances (e.g. LoRa implicit header mode). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae93500dfbcfd39837e04c0f3eaa40d97">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27" name="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&#160;</a></span>startTransmit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af79757dbbd62e080c1bad2e608ab940c" name="af79757dbbd62e080c1bad2e608ab940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79757dbbd62e080c1bad2e608ab940c">&#9670;&#160;</a></span>startTransmit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af79757dbbd62e080c1bad2e608ab940c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534" name="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&#160;</a></span>transmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ada508497ee2e70170da3afe078e2fe0e" name="ada508497ee2e70170da3afe078e2fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada508497ee2e70170da3afe078e2fe0e">&#9670;&#160;</a></span>transmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a75cb0d8810a5ce025d3bf5b51ca263d6" name="a75cb0d8810a5ce025d3bf5b51ca263d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cb0d8810a5ce025d3bf5b51ca263d6">&#9670;&#160;</a></span>transmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Will transmit arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534" title="C-string transmit method.">PhysicalLayer::transmit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aefeeb9f7192e11a75b5dfb1ab8488e84" name="aefeeb9f7192e11a75b5dfb1ab8488e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeeb9f7192e11a75b5dfb1ab8488e84">&#9670;&#160;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct transmission mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>24-bit raw frequency value to start transmitting at. Required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aa4c99ac794ee653c2061be4201724b65">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1d39296b40e7282ef44d8f376065e92c" name="a1d39296b40e7282ef44d8f376065e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d39296b40e7282ef44d8f376065e92c">&#9670;&#160;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLen</td><td>Maximum packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/SX127x/<a class="el" href="_s_x127x_8h_source.html">SX127x.h</a></li>
<li>src/modules/SX127x/<b>SX127x.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_x127x.html">SX127x</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
