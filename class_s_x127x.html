<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: SX127x Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_s_x127x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_x127x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SX127x Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> series. All derived classes for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> (e.g. <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> or <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes.  
 <a href="class_s_x127x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_x127x_8h_source.html">SX127x.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SX127x:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_x127x.png" usemap="#SX127x_map" alt=""/>
  <map id="SX127x_map" name="SX127x_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="154,0,247,24"/>
<area href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic..." alt="SX1272" shape="rect" coords="0,112,93,136"/>
<area href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,..." alt="SX1278" shape="rect" coords="309,112,402,136"/>
<area href="class_s_x1273.html" title="Derived class for SX1273 modules. Overrides some methods from SX1272 due to different parameter range..." alt="SX1273" shape="rect" coords="0,168,93,192"/>
<area href="class_r_f_m95.html" title="Derived class for RFM95 modules. Overrides some methods from SX1278 due to different parameter ranges..." alt="RFM95" shape="rect" coords="103,168,196,192"/>
<area href="class_r_f_m96.html" title="Derived class for RFM96 modules. Overrides some methods from SX1278 due to different parameter ranges..." alt="RFM96" shape="rect" coords="206,168,299,192"/>
<area href="class_s_x1276.html" title="Derived class for SX1276 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1276" shape="rect" coords="309,168,402,192"/>
<area href="class_s_x1277.html" title="Derived class for SX1277 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1277" shape="rect" coords="412,168,505,192"/>
<area href="class_s_x1279.html" title="Derived class for SX1279 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1279" shape="rect" coords="515,168,608,192"/>
<area href="class_r_f_m97.html" title="Derived class for RFM97 modules. Overrides some methods from RFM95 due to different parameter ranges." alt="RFM97" shape="rect" coords="103,224,196,248"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac74c5914ca429a3892c66b9d98e3ea6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac74c5914ca429a3892c66b9d98e3ea6c">SX127x</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:ac74c5914ca429a3892c66b9d98e3ea6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Called internally when creating new LoRa instance.  <a href="class_s_x127x.html#ac74c5914ca429a3892c66b9d98e3ea6c">More...</a><br /></td></tr>
<tr class="separator:ac74c5914ca429a3892c66b9d98e3ea6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da8218f69e3bf52df389a0480f8b430"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5da8218f69e3bf52df389a0480f8b430">begin</a> (uint8_t chipVersion, uint8_t syncWord, uint16_t preambleLength)</td></tr>
<tr class="memdesc:a5da8218f69e3bf52df389a0480f8b430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method. Will be called with appropriate parameters when calling initialization method from derived class.  <a href="class_s_x127x.html#a5da8218f69e3bf52df389a0480f8b430">More...</a><br /></td></tr>
<tr class="separator:a5da8218f69e3bf52df389a0480f8b430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3321ac4a7f65e73004202486db9b1d68"><td class="memItemLeft" align="right" valign="top"><a id="a3321ac4a7f65e73004202486db9b1d68"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3321ac4a7f65e73004202486db9b1d68">reset</a> ()=0</td></tr>
<tr class="memdesc:a3321ac4a7f65e73004202486db9b1d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin. Declared pure virtual since <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a> and <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> implementations differ. <br /></td></tr>
<tr class="separator:a3321ac4a7f65e73004202486db9b1d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78edb65673d9e88931a55b0672a9f3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#add78edb65673d9e88931a55b0672a9f3">beginFSK</a> (uint8_t chipVersion, float br, float freqDev, float rxBw, uint16_t preambleLength, bool enableOOK)</td></tr>
<tr class="memdesc:add78edb65673d9e88931a55b0672a9f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem. Will be called with appropriate parameters when calling FSK initialization method from derived class.  <a href="class_s_x127x.html#add78edb65673d9e88931a55b0672a9f3">More...</a><br /></td></tr>
<tr class="separator:add78edb65673d9e88931a55b0672a9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4ea3285922bf01cebd2c8a706d9a29"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9c4ea3285922bf01cebd2c8a706d9a29">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a9c4ea3285922bf01cebd2c8a706d9a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Will transmit arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f" title="Arduino Flash String transmit method.">PhysicalLayer::transmit</a>.  <a href="class_s_x127x.html#a9c4ea3285922bf01cebd2c8a706d9a29">More...</a><br /></td></tr>
<tr class="separator:a9c4ea3285922bf01cebd2c8a706d9a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe0d3f033a23ec2f3c2a407285d357c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adfe0d3f033a23ec2f3c2a407285d357c">receive</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:adfe0d3f033a23ec2f3c2a407285d357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Will attempt to receive arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36" title="Arduino String receive method.">PhysicalLayer::receive</a>.  <a href="class_s_x127x.html#adfe0d3f033a23ec2f3c2a407285d357c">More...</a><br /></td></tr>
<tr class="separator:adfe0d3f033a23ec2f3c2a407285d357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada007b90821258fe8c6ca7f8ae3efed5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ada007b90821258fe8c6ca7f8ae3efed5">scanChannel</a> ()</td></tr>
<tr class="memdesc:ada007b90821258fe8c6ca7f8ae3efed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for valid LoRa preamble in the current channel.  <a href="class_s_x127x.html#ada007b90821258fe8c6ca7f8ae3efed5">More...</a><br /></td></tr>
<tr class="separator:ada007b90821258fe8c6ca7f8ae3efed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44501ec8f8ac6084467b94516b1337df"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a44501ec8f8ac6084467b94516b1337df">sleep</a> ()</td></tr>
<tr class="memdesc:a44501ec8f8ac6084467b94516b1337df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called.  <a href="class_s_x127x.html#a44501ec8f8ac6084467b94516b1337df">More...</a><br /></td></tr>
<tr class="separator:a44501ec8f8ac6084467b94516b1337df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b8c5103128f122fbe489c6529ce41"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a760b8c5103128f122fbe489c6529ce41">standby</a> () override</td></tr>
<tr class="memdesc:a760b8c5103128f122fbe489c6529ce41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to standby.  <a href="class_s_x127x.html#a760b8c5103128f122fbe489c6529ce41">More...</a><br /></td></tr>
<tr class="separator:a760b8c5103128f122fbe489c6529ce41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aefeeb9f7192e11a75b5dfb1ab8488e84">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct transmission mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <a href="class_s_x127x.html#aefeeb9f7192e11a75b5dfb1ab8488e84">More...</a><br /></td></tr>
<tr class="separator:aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac558d537c6364c4bc82c8f33e398f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa7ac558d537c6364c4bc82c8f33e398f">receiveDirect</a> () override</td></tr>
<tr class="memdesc:aa7ac558d537c6364c4bc82c8f33e398f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct reception mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <a href="class_s_x127x.html#aa7ac558d537c6364c4bc82c8f33e398f">More...</a><br /></td></tr>
<tr class="separator:aa7ac558d537c6364c4bc82c8f33e398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0995088d37689a3c240a1af791df6cf1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0995088d37689a3c240a1af791df6cf1">packetMode</a> ()</td></tr>
<tr class="memdesc:a0995088d37689a3c240a1af791df6cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables direct mode and enables packet mode, allowing the module to receive packets. Can only be activated in FSK mode.  <a href="class_s_x127x.html#a0995088d37689a3c240a1af791df6cf1">More...</a><br /></td></tr>
<tr class="separator:a0995088d37689a3c240a1af791df6cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada53419d65f207f352124da7747c5960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ada53419d65f207f352124da7747c5960">setDio0Action</a> (void(*func)(void))</td></tr>
<tr class="memdesc:ada53419d65f207f352124da7747c5960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO0 activates.  <a href="class_s_x127x.html#ada53419d65f207f352124da7747c5960">More...</a><br /></td></tr>
<tr class="separator:ada53419d65f207f352124da7747c5960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729b4f3f36096b5b15bae19c7876e823"><td class="memItemLeft" align="right" valign="top"><a id="a729b4f3f36096b5b15bae19c7876e823"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a729b4f3f36096b5b15bae19c7876e823">clearDio0Action</a> ()</td></tr>
<tr class="memdesc:a729b4f3f36096b5b15bae19c7876e823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO0 activates. <br /></td></tr>
<tr class="separator:a729b4f3f36096b5b15bae19c7876e823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc844f7f3530f4076c8ea5f684c1b123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afc844f7f3530f4076c8ea5f684c1b123">setDio1Action</a> (void(*func)(void))</td></tr>
<tr class="memdesc:afc844f7f3530f4076c8ea5f684c1b123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO1 activates.  <a href="class_s_x127x.html#afc844f7f3530f4076c8ea5f684c1b123">More...</a><br /></td></tr>
<tr class="separator:afc844f7f3530f4076c8ea5f684c1b123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6532a25e1730973ac08146008adca5"><td class="memItemLeft" align="right" valign="top"><a id="a9b6532a25e1730973ac08146008adca5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9b6532a25e1730973ac08146008adca5">clearDio1Action</a> ()</td></tr>
<tr class="memdesc:a9b6532a25e1730973ac08146008adca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO1 activates. <br /></td></tr>
<tr class="separator:a9b6532a25e1730973ac08146008adca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2f1379573b7a7b5ee8125ea3752083"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adc2f1379573b7a7b5ee8125ea3752083">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:adc2f1379573b7a7b5ee8125ea3752083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method. Will start transmitting arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem.  <a href="class_s_x127x.html#adc2f1379573b7a7b5ee8125ea3752083">More...</a><br /></td></tr>
<tr class="separator:adc2f1379573b7a7b5ee8125ea3752083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8456d0f9abbce4d743f256f3e1e6c6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afe8456d0f9abbce4d743f256f3e1e6c6">startReceive</a> (uint8_t len=0, uint8_t mode=SX127X_RXCONTINUOUS)</td></tr>
<tr class="memdesc:afe8456d0f9abbce4d743f256f3e1e6c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. DIO0 will be activated when full valid packet is received.  <a href="class_s_x127x.html#afe8456d0f9abbce4d743f256f3e1e6c6">More...</a><br /></td></tr>
<tr class="separator:afe8456d0f9abbce4d743f256f3e1e6c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc840e8d6fe5e222f0143be17876745"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abfc840e8d6fe5e222f0143be17876745">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:abfc840e8d6fe5e222f0143be17876745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method. This method reads len characters.  <a href="class_s_x127x.html#abfc840e8d6fe5e222f0143be17876745">More...</a><br /></td></tr>
<tr class="separator:abfc840e8d6fe5e222f0143be17876745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c7f4584352a12390594395d9c29bde"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5c7f4584352a12390594395d9c29bde">setSyncWord</a> (uint8_t syncWord)</td></tr>
<tr class="memdesc:ac5c7f4584352a12390594395d9c29bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa sync word. Only available in LoRa mode.  <a href="class_s_x127x.html#ac5c7f4584352a12390594395d9c29bde">More...</a><br /></td></tr>
<tr class="separator:ac5c7f4584352a12390594395d9c29bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400575e3d83977bd250c5cb382fc7002"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a400575e3d83977bd250c5cb382fc7002">setCurrentLimit</a> (uint8_t currentLimit)</td></tr>
<tr class="memdesc:a400575e3d83977bd250c5cb382fc7002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current limit for over current protection at transmitter amplifier. Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps.  <a href="class_s_x127x.html#a400575e3d83977bd250c5cb382fc7002">More...</a><br /></td></tr>
<tr class="separator:a400575e3d83977bd250c5cb382fc7002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab608c45e0dcc44280df29580dc0a31ed"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab608c45e0dcc44280df29580dc0a31ed">setPreambleLength</a> (uint16_t preambleLength)</td></tr>
<tr class="memdesc:ab608c45e0dcc44280df29580dc0a31ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa or FSK preamble length. Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode.  <a href="class_s_x127x.html#ab608c45e0dcc44280df29580dc0a31ed">More...</a><br /></td></tr>
<tr class="separator:ab608c45e0dcc44280df29580dc0a31ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aa854a2668d70f4d3a374a49440362"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af6aa854a2668d70f4d3a374a49440362">getFrequencyError</a> (bool autoCorrect=false)</td></tr>
<tr class="memdesc:af6aa854a2668d70f4d3a374a49440362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency error of the latest received packet.  <a href="class_s_x127x.html#af6aa854a2668d70f4d3a374a49440362">More...</a><br /></td></tr>
<tr class="separator:af6aa854a2668d70f4d3a374a49440362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094ba2d9268340b7aba99afe5da0544"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5094ba2d9268340b7aba99afe5da0544">getAFCError</a> ()</td></tr>
<tr class="memdesc:a5094ba2d9268340b7aba99afe5da0544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current AFC error.  <a href="class_s_x127x.html#a5094ba2d9268340b7aba99afe5da0544">More...</a><br /></td></tr>
<tr class="separator:a5094ba2d9268340b7aba99afe5da0544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5069b39dc31b637ee561d5745e1deb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abc5069b39dc31b637ee561d5745e1deb">getSNR</a> ()</td></tr>
<tr class="memdesc:abc5069b39dc31b637ee561d5745e1deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets signal-to-noise ratio of the latest received packet.  <a href="class_s_x127x.html#abc5069b39dc31b637ee561d5745e1deb">More...</a><br /></td></tr>
<tr class="separator:abc5069b39dc31b637ee561d5745e1deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25b685de0859b799488bf7729350b6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adc25b685de0859b799488bf7729350b6">getDataRate</a> () const</td></tr>
<tr class="memdesc:adc25b685de0859b799488bf7729350b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data rate of the latest transmitted packet.  <a href="class_s_x127x.html#adc25b685de0859b799488bf7729350b6">More...</a><br /></td></tr>
<tr class="separator:adc25b685de0859b799488bf7729350b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606d839b3a992c681ac9ad7ca6020022"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a606d839b3a992c681ac9ad7ca6020022">setBitRate</a> (float br)</td></tr>
<tr class="memdesc:a606d839b3a992c681ac9ad7ca6020022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK bit rate. Allowed values range from 1.2 to 300 kbps. Only available in FSK mode.  <a href="class_s_x127x.html#a606d839b3a992c681ac9ad7ca6020022">More...</a><br /></td></tr>
<tr class="separator:a606d839b3a992c681ac9ad7ca6020022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a448ea8a6a6011a9cdddd4e09bd6c9679">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK frequency deviation from carrier frequency. Allowed values depend on bit rate setting and must be lower than 200 kHz. Only available in FSK mode.  <a href="class_s_x127x.html#a448ea8a6a6011a9cdddd4e09bd6c9679">More...</a><br /></td></tr>
<tr class="separator:a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc53b9f9d90647c5709cb974779cf53"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cc53b9f9d90647c5709cb974779cf53">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a2cc53b9f9d90647c5709cb974779cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK receiver bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <a href="class_s_x127x.html#a2cc53b9f9d90647c5709cb974779cf53">More...</a><br /></td></tr>
<tr class="separator:a2cc53b9f9d90647c5709cb974779cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">setAFCBandwidth</a> (float afcBw)</td></tr>
<tr class="memdesc:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK automatic frequency correction bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <a href="class_s_x127x.html#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">More...</a><br /></td></tr>
<tr class="separator:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">setAFC</a> (bool isEnabled)</td></tr>
<tr class="memdesc:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables FSK automatic frequency correction(AFC)  <a href="class_s_x127x.html#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">More...</a><br /></td></tr>
<tr class="separator:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f67330124cefc07a462e77922453d0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab0f67330124cefc07a462e77922453d0">setAFCAGCTrigger</a> (uint8_t trigger)</td></tr>
<tr class="memdesc:ab0f67330124cefc07a462e77922453d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls trigger of AFC and AGC.  <a href="class_s_x127x.html#ab0f67330124cefc07a462e77922453d0">More...</a><br /></td></tr>
<tr class="separator:ab0f67330124cefc07a462e77922453d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7afe338fd5b81122c369ecaf0c3ebc"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9b7afe338fd5b81122c369ecaf0c3ebc">setSyncWord</a> (uint8_t *syncWord, size_t len)</td></tr>
<tr class="memdesc:a9b7afe338fd5b81122c369ecaf0c3ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK sync word. Allowed sync words are up to 8 bytes long and can not contain null bytes. Only available in FSK mode.  <a href="class_s_x127x.html#a9b7afe338fd5b81122c369ecaf0c3ebc">More...</a><br /></td></tr>
<tr class="separator:a9b7afe338fd5b81122c369ecaf0c3ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99630d50672b43fc7162ba8f3293f95"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab99630d50672b43fc7162ba8f3293f95">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:ab99630d50672b43fc7162ba8f3293f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK node address. Calling this method will enable address filtering. Only available in FSK mode.  <a href="class_s_x127x.html#ab99630d50672b43fc7162ba8f3293f95">More...</a><br /></td></tr>
<tr class="separator:ab99630d50672b43fc7162ba8f3293f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51ce6718153e4963128f25bb5aab40"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abc51ce6718153e4963128f25bb5aab40">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:abc51ce6718153e4963128f25bb5aab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK broadcast address. Calling this method will enable address filtering. Only available in FSK mode.  <a href="class_s_x127x.html#abc51ce6718153e4963128f25bb5aab40">More...</a><br /></td></tr>
<tr class="separator:abc51ce6718153e4963128f25bb5aab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afe6e9bbfd75f9cad26f9f72c34c4ada5">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables FSK address filtering.  <a href="class_s_x127x.html#afe6e9bbfd75f9cad26f9f72c34c4ada5">More...</a><br /></td></tr>
<tr class="separator:afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef0af19a6b8954f956a3c3ad4286ee"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a24ef0af19a6b8954f956a3c3ad4286ee">setOOK</a> (bool enableOOK)</td></tr>
<tr class="memdesc:a24ef0af19a6b8954f956a3c3ad4286ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables OOK modulation instead of FSK.  <a href="class_s_x127x.html#a24ef0af19a6b8954f956a3c3ad4286ee">More...</a><br /></td></tr>
<tr class="separator:a24ef0af19a6b8954f956a3c3ad4286ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b93142202167270db109d18b743c744"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8b93142202167270db109d18b743c744">setOokThresholdType</a> (uint8_t type)</td></tr>
<tr class="memdesc:a8b93142202167270db109d18b743c744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the type of threshold in the OOK data slicer.  <a href="class_s_x127x.html#a8b93142202167270db109d18b743c744">More...</a><br /></td></tr>
<tr class="separator:a8b93142202167270db109d18b743c744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f43d70b5f94e49e09b4c9f082f46d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aac2f43d70b5f94e49e09b4c9f082f46d">setOokPeakThresholdDecrement</a> (uint8_t value)</td></tr>
<tr class="memdesc:aac2f43d70b5f94e49e09b4c9f082f46d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of decrement of the RSSI threshold in the OOK demodulator.  <a href="class_s_x127x.html#aac2f43d70b5f94e49e09b4c9f082f46d">More...</a><br /></td></tr>
<tr class="separator:aac2f43d70b5f94e49e09b4c9f082f46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff4e4e0afaebed727648e1400be538"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a17ff4e4e0afaebed727648e1400be538">setOokFixedOrFloorThreshold</a> (uint8_t value)</td></tr>
<tr class="memdesc:a17ff4e4e0afaebed727648e1400be538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed threshold for the Data Slicer in OOK mode or floor threshold for the Data Slicer in OOK when Peak mode is used.  <a href="class_s_x127x.html#a17ff4e4e0afaebed727648e1400be538">More...</a><br /></td></tr>
<tr class="separator:a17ff4e4e0afaebed727648e1400be538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462fa74275e67c296328a01f361892d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a462fa74275e67c296328a01f361892d5">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a462fa74275e67c296328a01f361892d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <a href="class_s_x127x.html#a462fa74275e67c296328a01f361892d5">More...</a><br /></td></tr>
<tr class="separator:a462fa74275e67c296328a01f361892d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8ce9f09d0f46a76a5e251786b6de7f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aaf8ce9f09d0f46a76a5e251786b6de7f">fixedPacketLengthMode</a> (uint8_t len=SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:aaf8ce9f09d0f46a76a5e251786b6de7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in FSK mode only.  <a href="class_s_x127x.html#aaf8ce9f09d0f46a76a5e251786b6de7f">More...</a><br /></td></tr>
<tr class="separator:aaf8ce9f09d0f46a76a5e251786b6de7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f753c0857e7b8b4b9f7f6e91c77f0fd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9f753c0857e7b8b4b9f7f6e91c77f0fd">variablePacketLengthMode</a> (uint8_t maxLen=SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:a9f753c0857e7b8b4b9f7f6e91c77f0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in FSK mode only.  <a href="class_s_x127x.html#a9f753c0857e7b8b4b9f7f6e91c77f0fd">More...</a><br /></td></tr>
<tr class="separator:a9f753c0857e7b8b4b9f7f6e91c77f0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3955f85f456edae772a51025a19029b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ad3955f85f456edae772a51025a19029b">setRSSIConfig</a> (uint8_t smoothingSamples, int8_t offset=0)</td></tr>
<tr class="memdesc:ad3955f85f456edae772a51025a19029b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets RSSI measurement configuration in FSK mode.  <a href="class_s_x127x.html#ad3955f85f456edae772a51025a19029b">More...</a><br /></td></tr>
<tr class="separator:ad3955f85f456edae772a51025a19029b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2d455012bd28d304589c8164390eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abad2d455012bd28d304589c8164390eb">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:abad2d455012bd28d304589c8164390eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING.  <a href="class_s_x127x.html#abad2d455012bd28d304589c8164390eb">More...</a><br /></td></tr>
<tr class="separator:abad2d455012bd28d304589c8164390eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2ddb517e474a699b4539653b3754d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5d2ddb517e474a699b4539653b3754d">getIRQFlags</a> ()</td></tr>
<tr class="memdesc:ac5d2ddb517e474a699b4539653b3754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads currently active IRQ flags, can be used to check which event caused an interrupt. In LoRa mode, this is the content of SX127X_REG_IRQ_FLAGS register. In FSK mode, this is the contents of SX127X_REG_IRQ_FLAGS_2 (MSB) and SX127X_REG_IRQ_FLAGS_1 (LSB) registers.  <a href="class_s_x127x.html#ac5d2ddb517e474a699b4539653b3754d">More...</a><br /></td></tr>
<tr class="separator:ac5d2ddb517e474a699b4539653b3754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">getModemStatus</a> ()</td></tr>
<tr class="memdesc:a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads modem status. Only available in LoRa mode.  <a href="class_s_x127x.html#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">More...</a><br /></td></tr>
<tr class="separator:a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bc32a555675879ad9e2a9e399dc6c1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a95bc32a555675879ad9e2a9e399dc6c1">getTempRaw</a> ()</td></tr>
<tr class="memdesc:a95bc32a555675879ad9e2a9e399dc6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uncalibrated temperature value. This function will change operating mode and should not be called during Tx, Rx or CAD.  <a href="class_s_x127x.html#a95bc32a555675879ad9e2a9e399dc6c1">More...</a><br /></td></tr>
<tr class="separator:a95bc32a555675879ad9e2a9e399dc6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9781180418c1ec9c365b74acbc98d8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae9781180418c1ec9c365b74acbc98d8a">setRfSwitchPins</a> (RADIOLIB_PIN_TYPE rxEn, RADIOLIB_PIN_TYPE txEn)</td></tr>
<tr class="memdesc:ae9781180418c1ec9c365b74acbc98d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by two pins. This function gives RadioLib control over those two pins to automatically switch Rx and Tx state. When using automatic RF switch control, DO NOT change the pin mode of rxEn or txEn from Arduino sketch!  <a href="class_s_x127x.html#ae9781180418c1ec9c365b74acbc98d8a">More...</a><br /></td></tr>
<tr class="separator:ae9781180418c1ec9c365b74acbc98d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cba1ff1e6bfd9b3034c97f3932e450"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a68cba1ff1e6bfd9b3034c97f3932e450">randomByte</a> ()</td></tr>
<tr class="memdesc:a68cba1ff1e6bfd9b3034c97f3932e450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <a href="class_s_x127x.html#a68cba1ff1e6bfd9b3034c97f3932e450">More...</a><br /></td></tr>
<tr class="separator:a68cba1ff1e6bfd9b3034c97f3932e450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5324d7d854e7a2f6768221d4f362cd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aee5324d7d854e7a2f6768221d4f362cd">getChipVersion</a> ()</td></tr>
<tr class="memdesc:aee5324d7d854e7a2f6768221d4f362cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return SX1278_CHIP_VERSION (0x12) or SX1272_CHIP_VERSION (0x22) if <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> is connected and working.  <a href="class_s_x127x.html#aee5324d7d854e7a2f6768221d4f362cd">More...</a><br /></td></tr>
<tr class="separator:aee5324d7d854e7a2f6768221d4f362cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6c61b16a39a2bbb5b94b3685caae04"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1f6c61b16a39a2bbb5b94b3685caae04">invertIQ</a> (bool invertIQ)</td></tr>
<tr class="memdesc:a1f6c61b16a39a2bbb5b94b3685caae04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables Invert the LoRa I and Q signals.  <a href="class_s_x127x.html#a1f6c61b16a39a2bbb5b94b3685caae04">More...</a><br /></td></tr>
<tr class="separator:a1f6c61b16a39a2bbb5b94b3685caae04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f409359eafa5988e8e4c2948735238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa3f409359eafa5988e8e4c2948735238">setDirectAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:aa3f409359eafa5988e8e4c2948735238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is receveid in direct mode.  <a href="class_s_x127x.html#aa3f409359eafa5988e8e4c2948735238">More...</a><br /></td></tr>
<tr class="separator:aa3f409359eafa5988e8e4c2948735238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071442611a32154e8b3db7981f242a53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a071442611a32154e8b3db7981f242a53">readBit</a> (RADIOLIB_PIN_TYPE pin)</td></tr>
<tr class="memdesc:a071442611a32154e8b3db7981f242a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <a href="class_s_x127x.html#a071442611a32154e8b3db7981f242a53">More...</a><br /></td></tr>
<tr class="separator:a071442611a32154e8b3db7981f242a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139a34e03a6fd5a781cd54da21d308f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab139a34e03a6fd5a781cd54da21d308f">transmit</a> (__FlashStringHelper *fstr, uint8_t addr=0)</td></tr>
<tr class="memdesc:ab139a34e03a6fd5a781cd54da21d308f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino Flash String transmit method.  <a href="class_s_x127x.html#ab139a34e03a6fd5a781cd54da21d308f">More...</a><br /></td></tr>
<tr class="separator:ab139a34e03a6fd5a781cd54da21d308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62c5a521aafc1e0525c58e9364482b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aeb62c5a521aafc1e0525c58e9364482b">transmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:aeb62c5a521aafc1e0525c58e9364482b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String transmit method.  <a href="class_s_x127x.html#aeb62c5a521aafc1e0525c58e9364482b">More...</a><br /></td></tr>
<tr class="separator:aeb62c5a521aafc1e0525c58e9364482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_s_x127x.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81565ee82ef9a7de9c5663c745f4ef7"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af81565ee82ef9a7de9c5663c745f4ef7">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0)=0</td></tr>
<tr class="memdesc:af81565ee82ef9a7de9c5663c745f4ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <a href="class_s_x127x.html#af81565ee82ef9a7de9c5663c745f4ef7">More...</a><br /></td></tr>
<tr class="separator:af81565ee82ef9a7de9c5663c745f4ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afb1b090348d9091bfa3a0b5ba3d85b36">receive</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String receive method.  <a href="class_s_x127x.html#afb1b090348d9091bfa3a0b5ba3d85b36">More...</a><br /></td></tr>
<tr class="separator:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2ad4c6a8ac267f8ac590260414ffcda3">receive</a> (uint8_t *data, size_t len)=0</td></tr>
<tr class="memdesc:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <a href="class_s_x127x.html#a2ad4c6a8ac267f8ac590260414ffcda3">More...</a><br /></td></tr>
<tr class="separator:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068e6e862c99e39d0261a7971dd56db"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af068e6e862c99e39d0261a7971dd56db">startTransmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:af068e6e862c99e39d0261a7971dd56db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_s_x127x.html#af068e6e862c99e39d0261a7971dd56db">More...</a><br /></td></tr>
<tr class="separator:af068e6e862c99e39d0261a7971dd56db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_s_x127x.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a41a1de0ebffe7b65de6fd8cceb9a5123">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0)=0</td></tr>
<tr class="memdesc:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <a href="class_s_x127x.html#a41a1de0ebffe7b65de6fd8cceb9a5123">More...</a><br /></td></tr>
<tr class="separator:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eed0e888a7c8742e89d2b850977de2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae8eed0e888a7c8742e89d2b850977de2">readData</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:ae8eed0e888a7c8742e89d2b850977de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_s_x127x.html#ae8eed0e888a7c8742e89d2b850977de2">More...</a><br /></td></tr>
<tr class="separator:ae8eed0e888a7c8742e89d2b850977de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6c756eb4b92855433ca389d73c632"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae8b6c756eb4b92855433ca389d73c632">readData</a> (uint8_t *data, size_t len)=0</td></tr>
<tr class="memdesc:ae8b6c756eb4b92855433ca389d73c632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_s_x127x.html#ae8b6c756eb4b92855433ca389d73c632">More...</a><br /></td></tr>
<tr class="separator:ae8b6c756eb4b92855433ca389d73c632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a5e02457f1d519cf81b1590a182321c62">PhysicalLayer</a> (float freqStep, size_t maxPacketLength)</td></tr>
<tr class="memdesc:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_physical_layer.html#a5e02457f1d519cf81b1590a182321c62">More...</a><br /></td></tr>
<tr class="separator:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f">transmit</a> (__FlashStringHelper *fstr, uint8_t addr=0)</td></tr>
<tr class="memdesc:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino Flash String transmit method.  <a href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f">More...</a><br /></td></tr>
<tr class="separator:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aeb62c5a521aafc1e0525c58e9364482b">transmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String transmit method.  <a href="class_physical_layer.html#aeb62c5a521aafc1e0525c58e9364482b">More...</a><br /></td></tr>
<tr class="separator:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36">receive</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String receive method.  <a href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36">More...</a><br /></td></tr>
<tr class="separator:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af068e6e862c99e39d0261a7971dd56db">startTransmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#af068e6e862c99e39d0261a7971dd56db">More...</a><br /></td></tr>
<tr class="separator:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae8eed0e888a7c8742e89d2b850977de2">readData</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_physical_layer.html#ae8eed0e888a7c8742e89d2b850977de2">More...</a><br /></td></tr>
<tr class="separator:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab643a814dce48f71a13bf6ea23f44cbd inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab643a814dce48f71a13bf6ea23f44cbd">setDataShaping</a> (uint8_t sh)=0</td></tr>
<tr class="memdesc:ab643a814dce48f71a13bf6ea23f44cbd inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK data shaping. Only available in FSK mode. Must be implemented in module class.  <a href="class_physical_layer.html#ab643a814dce48f71a13bf6ea23f44cbd">More...</a><br /></td></tr>
<tr class="separator:ab643a814dce48f71a13bf6ea23f44cbd inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">getFreqStep</a> () const</td></tr>
<tr class="memdesc:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the module frequency step size that was set in constructor.  <a href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">More...</a><br /></td></tr>
<tr class="separator:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <a href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">More...</a><br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <a href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">More...</a><br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <a href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">More...</a><br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <a href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">More...</a><br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <a href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">More...</a><br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a929662904e9af2611e098dc13b91c977">read</a> ()</td></tr>
<tr class="memdesc:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <a href="class_physical_layer.html#a929662904e9af2611e098dc13b91c977">More...</a><br /></td></tr>
<tr class="separator:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> series. All derived classes for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> (e.g. <a class="el" href="class_s_x1278.html" title="Derived class for SX1278 modules. Also used as base class for SX1276, SX1277, SX1279,...">SX1278</a> or <a class="el" href="class_s_x1272.html" title="Derived class for SX1272 modules. Also used as base class for SX1273. Both modules use the same basic...">SX1272</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac74c5914ca429a3892c66b9d98e3ea6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74c5914ca429a3892c66b9d98e3ea6c">&#9670;&nbsp;</a></span>SX127x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SX127x::SX127x </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. Called internally when creating new LoRa instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level SPI/UART methods to control the wireless module. Every module class c...">Module</a> that will be used to communicate with the LoRa chip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5da8218f69e3bf52df389a0480f8b430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da8218f69e3bf52df389a0480f8b430">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::begin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>chipVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method. Will be called with appropriate parameters when calling initialization method from derived class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipVersion</td><td>Value in SPI version register. Used to verify the connection and hardware version.</td></tr>
    <tr><td class="paramname">syncWord</td><td>LoRa sync word.</td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of LoRa transmission preamble in symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="add78edb65673d9e88931a55b0672a9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add78edb65673d9e88931a55b0672a9f3">&#9670;&nbsp;</a></span>beginFSK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::beginFSK </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>chipVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FSK modem. Will be called with appropriate parameters when calling FSK initialization method from derived class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipVersion</td><td>Value in SPI version register. Used to verify the connection and hardware version.</td></tr>
    <tr><td class="paramname">br</td><td>Bit rate of the FSK transmission in kbps (kilobits per second).</td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation of the FSK transmission in kHz.</td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz.</td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of FSK preamble in bits.</td></tr>
    <tr><td class="paramname">enableOOK</td><td>Flag to specify OOK mode. This modulation is similar to FSK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afe6e9bbfd75f9cad26f9f72c34c4ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6e9bbfd75f9cad26f9f72c34c4ada5">&#9670;&nbsp;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables FSK address filtering. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aaf8ce9f09d0f46a76a5e251786b6de7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf8ce9f09d0f46a76a5e251786b6de7f">&#9670;&nbsp;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>SX127X_MAX_PACKET_LENGTH_FSK</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5094ba2d9268340b7aba99afe5da0544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5094ba2d9268340b7aba99afe5da0544">&#9670;&nbsp;</a></span>getAFCError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getAFCError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets current AFC error. </p>
<dl class="section return"><dt>Returns</dt><dd>Frequency offset from RF in Hz if AFC is enabled and triggered, zero otherwise. </dd></dl>

</div>
</div>
<a id="aee5324d7d854e7a2f6768221d4f362cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5324d7d854e7a2f6768221d4f362cd">&#9670;&nbsp;</a></span>getChipVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::getChipVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read version SPI register. Should return SX1278_CHIP_VERSION (0x12) or SX1272_CHIP_VERSION (0x22) if <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> is connected and working. </p>
<dl class="section return"><dt>Returns</dt><dd>Version register contents or <a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adc25b685de0859b799488bf7729350b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25b685de0859b799488bf7729350b6">&#9670;&nbsp;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getDataRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get data rate of the latest transmitted packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Last packet data rate in bps (bits per second). </dd></dl>

</div>
</div>
<a id="af6aa854a2668d70f4d3a374a49440362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aa854a2668d70f4d3a374a49440362">&#9670;&nbsp;</a></span>getFrequencyError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getFrequencyError </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoCorrect</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets frequency error of the latest received packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">autoCorrect</td><td>When set to true, frequency will be automatically corrected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Frequency error in Hz. </dd></dl>

</div>
</div>
<a id="ac5d2ddb517e474a699b4539653b3754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d2ddb517e474a699b4539653b3754d">&#9670;&nbsp;</a></span>getIRQFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t SX127x::getIRQFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads currently active IRQ flags, can be used to check which event caused an interrupt. In LoRa mode, this is the content of SX127X_REG_IRQ_FLAGS register. In FSK mode, this is the contents of SX127X_REG_IRQ_FLAGS_2 (MSB) and SX127X_REG_IRQ_FLAGS_1 (LSB) registers. </p>
<dl class="section return"><dt>Returns</dt><dd>IRQ flags. </dd></dl>

</div>
</div>
<a id="a2cf6a5bd8f3257f98ee4f250cbdf8bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">&#9670;&nbsp;</a></span>getModemStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::getModemStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads modem status. Only available in LoRa mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Modem status. </dd></dl>

</div>
</div>
<a id="a462fa74275e67c296328a01f361892d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462fa74275e67c296328a01f361892d5">&#9670;&nbsp;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SX127x::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a0bd6046e068ef63e3f2b6bead48e02a7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abc5069b39dc31b637ee561d5745e1deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5069b39dc31b637ee561d5745e1deb">&#9670;&nbsp;</a></span>getSNR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX127x::getSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets signal-to-noise ratio of the latest received packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Last packet signal-to-noise ratio (SNR). </dd></dl>

</div>
</div>
<a id="a95bc32a555675879ad9e2a9e399dc6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bc32a555675879ad9e2a9e399dc6c1">&#9670;&nbsp;</a></span>getTempRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t SX127x::getTempRaw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads uncalibrated temperature value. This function will change operating mode and should not be called during Tx, Rx or CAD. </p>
<dl class="section return"><dt>Returns</dt><dd>Uncalibrated temperature sensor reading. </dd></dl>

</div>
</div>
<a id="a1f6c61b16a39a2bbb5b94b3685caae04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6c61b16a39a2bbb5b94b3685caae04">&#9670;&nbsp;</a></span>invertIQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::invertIQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invertIQ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables Invert the LoRa I and Q signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invertIQ</td><td>Enable (true) or disable (false) LoRa I and Q signals.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a0995088d37689a3c240a1af791df6cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0995088d37689a3c240a1af791df6cf1">&#9670;&nbsp;</a></span>packetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::packetMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables direct mode and enables packet mode, allowing the module to receive packets. Can only be activated in FSK mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a68cba1ff1e6bfd9b3034c97f3932e450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68cba1ff1e6bfd9b3034c97f3932e450">&#9670;&nbsp;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX127x::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a34543b885aa57ade08a4c659991e523e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a071442611a32154e8b3db7981f242a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071442611a32154e8b3db7981f242a53">&#9670;&nbsp;</a></span>readBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::readBit </td>
          <td>(</td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to read and process data bit in direct reception mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin on which to read. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_physical_layer.html#a9b720e7776ad7ea805932578907b0058">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae8eed0e888a7c8742e89d2b850977de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8eed0e888a7c8742e89d2b850977de2">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String to save the received data.</td></tr>
    <tr><td class="paramname">len</td><td>Expected number of characters in the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abfc840e8d6fe5e222f0143be17876745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc840e8d6fe5e222f0143be17876745">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. This method reads len characters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#ae8b6c756eb4b92855433ca389d73c632">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae8b6c756eb4b92855433ca389d73c632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b6c756eb4b92855433ca389d73c632">&#9670;&nbsp;</a></span>readData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afb1b090348d9091bfa3a0b5ba3d85b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1b090348d9091bfa3a0b5ba3d85b36">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino String receive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String to save the received data.</td></tr>
    <tr><td class="paramname">len</td><td>Expected number of characters in the message. Leave as 0 if expecting a unknown size packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adfe0d3f033a23ec2f3c2a407285d357c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe0d3f033a23ec2f3c2a407285d357c">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Will attempt to receive arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36" title="Arduino String receive method.">PhysicalLayer::receive</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a2ad4c6a8ac267f8ac590260414ffcda3">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2ad4c6a8ac267f8ac590260414ffcda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad4c6a8ac267f8ac590260414ffcda3">&#9670;&nbsp;</a></span>receive() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aa7ac558d537c6364c4bc82c8f33e398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ac558d537c6364c4bc82c8f33e398f">&#9670;&nbsp;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct reception mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a46b22145b33e97cf6065ed826799b6b4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ada007b90821258fe8c6ca7f8ae3efed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada007b90821258fe8c6ca7f8ae3efed5">&#9670;&nbsp;</a></span>scanChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::scanChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scan for valid LoRa preamble in the current channel. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">&#9670;&nbsp;</a></span>setAFC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFC </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isEnabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables FSK automatic frequency correction(AFC) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isEnabled</td><td>AFC enabled or disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab0f67330124cefc07a462e77922453d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f67330124cefc07a462e77922453d0">&#9670;&nbsp;</a></span>setAFCAGCTrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFCAGCTrigger </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls trigger of AFC and AGC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>one from SX127X_RX_TRIGGER_NONE, SX127X_RX_TRIGGER_RSSI_INTERRUPT, SX127X_RX_TRIGGER_PREAMBLE_DETECT, SX127X_RX_TRIGGER_BOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">&#9670;&nbsp;</a></span>setAFCBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setAFCBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>afcBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK automatic frequency correction bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>Receiver AFC bandwidth to be set (in kHz).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a606d839b3a992c681ac9ad7ca6020022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606d839b3a992c681ac9ad7ca6020022">&#9670;&nbsp;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK bit rate. Allowed values range from 1.2 to 300 kbps. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>Bit rate to be set (in kbps).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>fractional part of bit rate setting (not in OOK) </dd></dl>

</div>
</div>
<a id="abc51ce6718153e4963128f25bb5aab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc51ce6718153e4963128f25bb5aab40">&#9670;&nbsp;</a></span>setBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setBroadcastAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>broadAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK broadcast address. Calling this method will enable address filtering. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadAddr</td><td>Broadcast address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a400575e3d83977bd250c5cb382fc7002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400575e3d83977bd250c5cb382fc7002">&#9670;&nbsp;</a></span>setCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>currentLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets current limit for over current protection at transmitter amplifier. Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentLimit</td><td>Current limit to be set (in mA).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ada53419d65f207f352124da7747c5960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada53419d65f207f352124da7747c5960">&#9670;&nbsp;</a></span>setDio0Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDio0Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when DIO0 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc844f7f3530f4076c8ea5f684c1b123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc844f7f3530f4076c8ea5f684c1b123">&#9670;&nbsp;</a></span>setDio1Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDio1Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when DIO1 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3f409359eafa5988e8e4c2948735238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f409359eafa5988e8e4c2948735238">&#9670;&nbsp;</a></span>setDirectAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setDirectAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when data bit is receveid in direct mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_physical_layer.html#ab76fe7d3e0f453a807b205161c980086">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abad2d455012bd28d304589c8164390eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad2d455012bd28d304589c8164390eb">&#9670;&nbsp;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a7d3419227d201d6912b77784636d437d">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a448ea8a6a6011a9cdddd4e09bd6c9679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448ea8a6a6011a9cdddd4e09bd6c9679">&#9670;&nbsp;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK frequency deviation from carrier frequency. Allowed values depend on bit rate setting and must be lower than 200 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>Frequency deviation to be set (in kHz).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#ab9060e8ab7a2da192b3bf53b3501553b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab99630d50672b43fc7162ba8f3293f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99630d50672b43fc7162ba8f3293f95">&#9670;&nbsp;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK node address. Calling this method will enable address filtering. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a24ef0af19a6b8954f956a3c3ad4286ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ef0af19a6b8954f956a3c3ad4286ee">&#9670;&nbsp;</a></span>setOOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOOK </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables OOK modulation instead of FSK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableOOK</td><td>Enable (true) or disable (false) OOK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a17ff4e4e0afaebed727648e1400be538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ff4e4e0afaebed727648e1400be538">&#9670;&nbsp;</a></span>setOokFixedOrFloorThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokFixedOrFloorThreshold </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fixed threshold for the Data Slicer in OOK mode or floor threshold for the Data Slicer in OOK when Peak mode is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The actual value used by teh data slicer is (128 - value/2).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aac2f43d70b5f94e49e09b4c9f082f46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2f43d70b5f94e49e09b4c9f082f46d">&#9670;&nbsp;</a></span>setOokPeakThresholdDecrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokPeakThresholdDecrement </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Period of decrement of the RSSI threshold in the OOK demodulator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Use defines SX127X_OOK_PEAK_THRESH_DEC_X_X_CHIP</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a8b93142202167270db109d18b743c744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b93142202167270db109d18b743c744">&#9670;&nbsp;</a></span>setOokThresholdType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setOokThresholdType </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the type of threshold in the OOK data slicer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Threshold type: SX127X_OOK_THRESH_PEAK(default), SX127X_OOK_THRESH_FIXED, SX127X_OOK_THRESH_AVERAGE</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab608c45e0dcc44280df29580dc0a31ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab608c45e0dcc44280df29580dc0a31ed">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa or FSK preamble length. Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set (in symbols when in LoRa mode or bits in FSK mode).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae9781180418c1ec9c365b74acbc98d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9781180418c1ec9c365b74acbc98d8a">&#9670;&nbsp;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX127x::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by two pins. This function gives RadioLib control over those two pins to automatically switch Rx and Tx state. When using automatic RF switch control, DO NOT change the pin mode of rxEn or txEn from Arduino sketch! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin.</td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3955f85f456edae772a51025a19029b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3955f85f456edae772a51025a19029b">&#9670;&nbsp;</a></span>setRSSIConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setRSSIConfig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>smoothingSamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets RSSI measurement configuration in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">smoothingSamples</td><td>Number of samples taken to average the RSSI result. numSamples = 2 ^ (1 + smoothingSamples), allowed values are in range 0 (2 samples) - 7 (256 samples)</td></tr>
    <tr><td class="paramname">offset</td><td>Signed RSSI offset that will be automatically compensated. 1 dB per LSB, defaults to 0, allowed values are in range -16 dB to +15 dB.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2cc53b9f9d90647c5709cb974779cf53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc53b9f9d90647c5709cb974779cf53">&#9670;&nbsp;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK receiver bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth to be set (in kHz).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a9b7afe338fd5b81122c369ecaf0c3ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7afe338fd5b81122c369ecaf0c3ebc">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK sync word. Allowed sync words are up to 8 bytes long and can not contain null bytes. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Sync word array.</td></tr>
    <tr><td class="paramname">len</td><td>Sync word length (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac5c7f4584352a12390594395d9c29bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c7f4584352a12390594395d9c29bde">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa sync word. Only available in LoRa mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Sync word to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a44501ec8f8ac6084467b94516b1337df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44501ec8f8ac6084467b94516b1337df">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the LoRa module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a760b8c5103128f122fbe489c6529ce41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760b8c5103128f122fbe489c6529ce41">&#9670;&nbsp;</a></span>standby()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the LoRa module to standby. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a0e77da761a2cbb5c9535df0bdea993f9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="afe8456d0f9abbce4d743f256f3e1e6c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8456d0f9abbce4d743f256f3e1e6c6">&#9670;&nbsp;</a></span>startReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em> = <code>SX127X_RXCONTINUOUS</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. DIO0 will be activated when full valid packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Expected length of packet to be received. Required for LoRa spreading factor 6.</td></tr>
    <tr><td class="paramname">mode</td><td>Receive mode to be used. Defaults to RxContinuous.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af068e6e862c99e39d0261a7971dd56db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af068e6e862c99e39d0261a7971dd56db">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adc2f1379573b7a7b5ee8125ea3752083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2f1379573b7a7b5ee8125ea3752083">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::startTransmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. Will start transmitting arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a41a1de0ebffe7b65de6fd8cceb9a5123">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a41a1de0ebffe7b65de6fd8cceb9a5123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a1de0ebffe7b65de6fd8cceb9a5123">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab139a34e03a6fd5a781cd54da21d308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab139a34e03a6fd5a781cd54da21d308f">&#9670;&nbsp;</a></span>transmit() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino Flash String transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to Arduino Flash String that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&nbsp;</a></span>transmit() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aeb62c5a521aafc1e0525c58e9364482b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62c5a521aafc1e0525c58e9364482b">&#9670;&nbsp;</a></span>transmit() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino String transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a9c4ea3285922bf01cebd2c8a706d9a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c4ea3285922bf01cebd2c8a706d9a29">&#9670;&nbsp;</a></span>transmit() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Will transmit arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f" title="Arduino Flash String transmit method.">PhysicalLayer::transmit</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#af81565ee82ef9a7de9c5663c745f4ef7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af81565ee82ef9a7de9c5663c745f4ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81565ee82ef9a7de9c5663c745f4ef7">&#9670;&nbsp;</a></span>transmit() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aefeeb9f7192e11a75b5dfb1ab8488e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeeb9f7192e11a75b5dfb1ab8488e84">&#9670;&nbsp;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables direct transmission mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>24-bit raw frequency value to start transmitting at. Required for quick frequency shifts in RTTY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a4b04eb6155b06d8ef400131c647d54e7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9f753c0857e7b8b4b9f7f6e91c77f0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f753c0857e7b8b4b9f7f6e91c77f0fd">&#9670;&nbsp;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX127x::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>SX127X_MAX_PACKET_LENGTH_FSK</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Maximum packet length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/SX127x/<a class="el" href="_s_x127x_8h_source.html">SX127x.h</a></li>
<li>src/modules/SX127x/SX127x.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_x127x.html">SX127x</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
