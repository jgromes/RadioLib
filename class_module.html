<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: Module Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_module.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_module-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Module Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Implements all common low-level methods to control the wireless module. Every module class contains one private instance of this class.  
 <a href="class_module.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_module_8h_source.html">Module.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Module:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_module.png" usemap="#Module_map" alt=""/>
  <map id="Module_map" name="Module_map">
<area href="class_s_t_m32_w_lx___module.html" alt="STM32WLx_Module" shape="rect" coords="0,56,125,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_module_1_1_rf_switch_mode__t.html">RfSwitchMode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Description of RF switch pin states for a single mode. See <a class="el" href="class_module.html#ac308fa817a5c36c5dc724a0d15cefd4d">setRfSwitchTable</a> for details.  <a href="struct_module_1_1_rf_switch_mode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_module_1_1_s_p_i_config__t.html">SPIConfig_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI configuration structure.  <a href="struct_module_1_1_s_p_i_config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a67b3a63420d762ecba9448671c99bf" id="r_a5a67b3a63420d762ecba9448671c99bf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf">OpMode_t</a> { <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa81cdd8986054c2ae5657eb5dfd536770">MODE_END_OF_TABLE</a> = 0
, <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">MODE_IDLE</a>
, <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">MODE_RX</a>
, <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">MODE_TX</a>
 }</td></tr>
<tr class="memdesc:a5a67b3a63420d762ecba9448671c99bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios, but some radios define their own constants to be used instead.  <a href="class_module.html#a5a67b3a63420d762ecba9448671c99bf">More...</a><br /></td></tr>
<tr class="separator:a5a67b3a63420d762ecba9448671c99bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e5dd089a3117f6499b818b426e2e0d" id="r_af5e5dd089a3117f6499b818b426e2e0d"><td class="memItemLeft" align="right" valign="top"><a id="af5e5dd089a3117f6499b818b426e2e0d" name="af5e5dd089a3117f6499b818b426e2e0d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>BitWidth_t</b> { <b>BITS_0</b> = 0
, <b>BITS_8</b> = 8
, <b>BITS_16</b> = 16
, <b>BITS_32</b> = 32
 }</td></tr>
<tr class="separator:af5e5dd089a3117f6499b818b426e2e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9393088249856eab568126aeb2493e4a" id="r_a9393088249856eab568126aeb2493e4a"><td class="memItemLeft" align="right" valign="top"><a id="a9393088249856eab568126aeb2493e4a" name="a9393088249856eab568126aeb2493e4a"></a>
typedef int16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>SPIparseStatusCb_t</b>) (uint8_t in)</td></tr>
<tr class="memdesc:a9393088249856eab568126aeb2493e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for parsing SPI status. <br /></td></tr>
<tr class="separator:a9393088249856eab568126aeb2493e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad7bef7d380d3b6b88dca99bd35d640" id="r_a1ad7bef7d380d3b6b88dca99bd35d640"><td class="memItemLeft" align="right" valign="top"><a id="a1ad7bef7d380d3b6b88dca99bd35d640" name="a1ad7bef7d380d3b6b88dca99bd35d640"></a>
typedef int16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>SPIcheckStatusCb_t</b>) (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:a1ad7bef7d380d3b6b88dca99bd35d640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback for validation SPI status. <br /></td></tr>
<tr class="separator:a1ad7bef7d380d3b6b88dca99bd35d640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a817178405f125e068e88bad62aeb6f3b" id="r_a817178405f125e068e88bad62aeb6f3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a817178405f125e068e88bad62aeb6f3b">Module</a> (<a class="el" href="class_radio_lib_hal.html">RadioLibHal</a> *<a class="el" href="class_module.html#a4483f0a39a523dd1b37b467d81418f7d">hal</a>, uint32_t cs, uint32_t irq, uint32_t rst, uint32_t gpio=RADIOLIB_NC)</td></tr>
<tr class="memdesc:a817178405f125e068e88bad62aeb6f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> constructor.  <br /></td></tr>
<tr class="separator:a817178405f125e068e88bad62aeb6f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919baf2e46c357ebfcdbc1025b6c551e" id="r_a919baf2e46c357ebfcdbc1025b6c551e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a919baf2e46c357ebfcdbc1025b6c551e">Module</a> (const <a class="el" href="class_module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a919baf2e46c357ebfcdbc1025b6c551e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a919baf2e46c357ebfcdbc1025b6c551e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea888758b4a7784082d513a1e7849a4" id="r_a4ea888758b4a7784082d513a1e7849a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4ea888758b4a7784082d513a1e7849a4">operator=</a> (const <a class="el" href="class_module.html">Module</a> &amp;mod)</td></tr>
<tr class="memdesc:a4ea888758b4a7784082d513a1e7849a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for assignment operator.  <br /></td></tr>
<tr class="separator:a4ea888758b4a7784082d513a1e7849a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1956ac81429ec1f61f83dbc081cf18c" id="r_ad1956ac81429ec1f61f83dbc081cf18c"><td class="memItemLeft" align="right" valign="top"><a id="ad1956ac81429ec1f61f83dbc081cf18c" name="ad1956ac81429ec1f61f83dbc081cf18c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="memdesc:ad1956ac81429ec1f61f83dbc081cf18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize low-level module control. <br /></td></tr>
<tr class="separator:ad1956ac81429ec1f61f83dbc081cf18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45bd514a1f2859d9a867c8f9b13eb332" id="r_a45bd514a1f2859d9a867c8f9b13eb332"><td class="memItemLeft" align="right" valign="top"><a id="a45bd514a1f2859d9a867c8f9b13eb332" name="a45bd514a1f2859d9a867c8f9b13eb332"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>term</b> ()</td></tr>
<tr class="memdesc:a45bd514a1f2859d9a867c8f9b13eb332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate low-level module control. <br /></td></tr>
<tr class="separator:a45bd514a1f2859d9a867c8f9b13eb332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369e916626c821ecec85f25d5b46d752" id="r_a369e916626c821ecec85f25d5b46d752"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a369e916626c821ecec85f25d5b46d752">SPIgetRegValue</a> (uint32_t reg, uint8_t msb=7, uint8_t lsb=0)</td></tr>
<tr class="memdesc:a369e916626c821ecec85f25d5b46d752"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI read method that automatically masks unused bits. This method is the preferred SPI read mechanism.  <br /></td></tr>
<tr class="separator:a369e916626c821ecec85f25d5b46d752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed95fba2ee72d7a2a21f98dd63ae4ad1" id="r_aed95fba2ee72d7a2a21f98dd63ae4ad1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#aed95fba2ee72d7a2a21f98dd63ae4ad1">SPIsetRegValue</a> (uint32_t reg, uint8_t value, uint8_t msb=7, uint8_t lsb=0, uint8_t checkInterval=2, uint8_t checkMask=0xFF, bool force=false)</td></tr>
<tr class="memdesc:aed95fba2ee72d7a2a21f98dd63ae4ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite-safe SPI write method with verification. This method is the preferred SPI write mechanism.  <br /></td></tr>
<tr class="separator:aed95fba2ee72d7a2a21f98dd63ae4ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac993ab8e2ea0f5aa93339d1f6ffb54ee" id="r_ac993ab8e2ea0f5aa93339d1f6ffb54ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac993ab8e2ea0f5aa93339d1f6ffb54ee">SPIreadRegisterBurst</a> (uint32_t reg, size_t numBytes, uint8_t *inBytes)</td></tr>
<tr class="memdesc:ac993ab8e2ea0f5aa93339d1f6ffb54ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI burst read method.  <br /></td></tr>
<tr class="separator:ac993ab8e2ea0f5aa93339d1f6ffb54ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab250eb929068e0c890e16e8e6d7cd7e6" id="r_ab250eb929068e0c890e16e8e6d7cd7e6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab250eb929068e0c890e16e8e6d7cd7e6">SPIreadRegister</a> (uint32_t reg)</td></tr>
<tr class="memdesc:ab250eb929068e0c890e16e8e6d7cd7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI basic read method. Use of this method is reserved for special cases, SPIgetRegValue should be used instead.  <br /></td></tr>
<tr class="separator:ab250eb929068e0c890e16e8e6d7cd7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10809e942c686b4e605269e58bd637b9" id="r_a10809e942c686b4e605269e58bd637b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a10809e942c686b4e605269e58bd637b9">SPIwriteRegisterBurst</a> (uint32_t reg, const uint8_t *data, size_t numBytes)</td></tr>
<tr class="memdesc:a10809e942c686b4e605269e58bd637b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI burst write method.  <br /></td></tr>
<tr class="separator:a10809e942c686b4e605269e58bd637b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ca6b4cae98f7d935191a569d519913" id="r_a60ca6b4cae98f7d935191a569d519913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a60ca6b4cae98f7d935191a569d519913">SPIwriteRegister</a> (uint32_t reg, uint8_t data)</td></tr>
<tr class="memdesc:a60ca6b4cae98f7d935191a569d519913"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI basic write method. Use of this method is reserved for special cases, SPIsetRegValue should be used instead.  <br /></td></tr>
<tr class="separator:a60ca6b4cae98f7d935191a569d519913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfbddb1ff044f8b1865aac89246445d" id="r_a2bfbddb1ff044f8b1865aac89246445d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a2bfbddb1ff044f8b1865aac89246445d">SPItransfer</a> (uint16_t cmd, uint32_t reg, const uint8_t *dataOut, uint8_t *dataIn, size_t numBytes)</td></tr>
<tr class="memdesc:a2bfbddb1ff044f8b1865aac89246445d"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI single transfer method.  <br /></td></tr>
<tr class="separator:a2bfbddb1ff044f8b1865aac89246445d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efa7ae78cab1d7f43005e965923f769" id="r_a5efa7ae78cab1d7f43005e965923f769"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5efa7ae78cab1d7f43005e965923f769">SPIcheckStream</a> ()</td></tr>
<tr class="memdesc:a5efa7ae78cab1d7f43005e965923f769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check the result of last SPI stream transfer.  <br /></td></tr>
<tr class="separator:a5efa7ae78cab1d7f43005e965923f769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacceb57ecfecb09150c135b2b44436f" id="r_adacceb57ecfecb09150c135b2b44436f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#adacceb57ecfecb09150c135b2b44436f">SPIreadStream</a> (uint16_t cmd, uint8_t *data, size_t numBytes, bool waitForGpio=true, bool verify=true)</td></tr>
<tr class="memdesc:adacceb57ecfecb09150c135b2b44436f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform a read transaction with SPI stream.  <br /></td></tr>
<tr class="separator:adacceb57ecfecb09150c135b2b44436f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4af5fc5fd60e0aadb8a69606e511946" id="r_ad4af5fc5fd60e0aadb8a69606e511946"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ad4af5fc5fd60e0aadb8a69606e511946">SPIreadStream</a> (const uint8_t *cmd, uint8_t cmdLen, uint8_t *data, size_t numBytes, bool waitForGpio=true, bool verify=true)</td></tr>
<tr class="memdesc:ad4af5fc5fd60e0aadb8a69606e511946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform a read transaction with SPI stream.  <br /></td></tr>
<tr class="separator:ad4af5fc5fd60e0aadb8a69606e511946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e6e0c4e792a5ef7b3bb040947666a6" id="r_a47e6e0c4e792a5ef7b3bb040947666a6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a47e6e0c4e792a5ef7b3bb040947666a6">SPIwriteStream</a> (uint16_t cmd, const uint8_t *data, size_t numBytes, bool waitForGpio=true, bool verify=true)</td></tr>
<tr class="memdesc:a47e6e0c4e792a5ef7b3bb040947666a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform a write transaction with SPI stream.  <br /></td></tr>
<tr class="separator:a47e6e0c4e792a5ef7b3bb040947666a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5594e8024d34d2d168413ae5c28e73b" id="r_af5594e8024d34d2d168413ae5c28e73b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#af5594e8024d34d2d168413ae5c28e73b">SPIwriteStream</a> (const uint8_t *cmd, uint8_t cmdLen, const uint8_t *data, size_t numBytes, bool waitForGpio=true, bool verify=true)</td></tr>
<tr class="memdesc:af5594e8024d34d2d168413ae5c28e73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to perform a write transaction with SPI stream.  <br /></td></tr>
<tr class="separator:af5594e8024d34d2d168413ae5c28e73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3f89fc63a82eb5fd55a7ddd72318fe" id="r_a2b3f89fc63a82eb5fd55a7ddd72318fe"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a2b3f89fc63a82eb5fd55a7ddd72318fe">SPItransferStream</a> (const uint8_t *cmd, uint8_t cmdLen, bool write, const uint8_t *dataOut, uint8_t *dataIn, size_t numBytes, bool waitForGpio)</td></tr>
<tr class="memdesc:a2b3f89fc63a82eb5fd55a7ddd72318fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI single transfer method for modules with stream-type SPI interface (<a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, <a class="el" href="class_s_x128x.html" title="Base class for SX128x series. All derived classes for SX128x (e.g. SX1280 or SX1281) inherit from thi...">SX128x</a> etc.).  <br /></td></tr>
<tr class="separator:a2b3f89fc63a82eb5fd55a7ddd72318fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61bc5066c356e2d0d79f08a2bd0fbc9" id="r_ab61bc5066c356e2d0d79f08a2bd0fbc9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ab61bc5066c356e2d0d79f08a2bd0fbc9">getIrq</a> () const</td></tr>
<tr class="memdesc:ab61bc5066c356e2d0d79f08a2bd0fbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access method to get the pin number of interrupt/GPIO.  <br /></td></tr>
<tr class="separator:ab61bc5066c356e2d0d79f08a2bd0fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cddbf3aebec9717a1a381dd81ad398" id="r_ad6cddbf3aebec9717a1a381dd81ad398"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ad6cddbf3aebec9717a1a381dd81ad398">getRst</a> () const</td></tr>
<tr class="memdesc:ad6cddbf3aebec9717a1a381dd81ad398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access method to get the pin number of hardware reset pin.  <br /></td></tr>
<tr class="separator:ad6cddbf3aebec9717a1a381dd81ad398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec27f0ba5e0009ea9661a5110526b52" id="r_a4ec27f0ba5e0009ea9661a5110526b52"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a4ec27f0ba5e0009ea9661a5110526b52">getGpio</a> () const</td></tr>
<tr class="memdesc:a4ec27f0ba5e0009ea9661a5110526b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access method to get the pin number of second interrupt/GPIO.  <br /></td></tr>
<tr class="separator:a4ec27f0ba5e0009ea9661a5110526b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3adea64acab11c47c804afc74bd4f3" id="r_a7d3adea64acab11c47c804afc74bd4f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7d3adea64acab11c47c804afc74bd4f3">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a7d3adea64acab11c47c804afc74bd4f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.  <br /></td></tr>
<tr class="separator:a7d3adea64acab11c47c804afc74bd4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac308fa817a5c36c5dc724a0d15cefd4d" id="r_ac308fa817a5c36c5dc724a0d15cefd4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#ac308fa817a5c36c5dc724a0d15cefd4d">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:ac308fa817a5c36c5dc724a0d15cefd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.  <br /></td></tr>
<tr class="separator:ac308fa817a5c36c5dc724a0d15cefd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5699a937b62ba41387567b4d679b9377" id="r_a5699a937b62ba41387567b4d679b9377"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">RfSwitchMode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a5699a937b62ba41387567b4d679b9377">findRfSwitchMode</a> (uint8_t mode) const</td></tr>
<tr class="memdesc:a5699a937b62ba41387567b4d679b9377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a mode in the RfSwitchTable.  <br /></td></tr>
<tr class="separator:a5699a937b62ba41387567b4d679b9377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbed643f082286012bf44bba22381ae6" id="r_afbed643f082286012bf44bba22381ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#afbed643f082286012bf44bba22381ae6">setRfSwitchState</a> (uint8_t mode)</td></tr>
<tr class="memdesc:afbed643f082286012bf44bba22381ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set RF switch state.  <br /></td></tr>
<tr class="separator:afbed643f082286012bf44bba22381ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df4c687249c07af2594a5f7ad0a946f" id="r_a7df4c687249c07af2594a5f7ad0a946f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a7df4c687249c07af2594a5f7ad0a946f">waitForMicroseconds</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> start, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> len)</td></tr>
<tr class="memdesc:a7df4c687249c07af2594a5f7ad0a946f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for time to elapse, either using the microsecond timer, or the TimerFlag. Note that in interrupt timing mode, it is up to the user to set up the timing interrupt!  <br /></td></tr>
<tr class="separator:a7df4c687249c07af2594a5f7ad0a946f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4483f0a39a523dd1b37b467d81418f7d" id="r_a4483f0a39a523dd1b37b467d81418f7d"><td class="memItemLeft" align="right" valign="top"><a id="a4483f0a39a523dd1b37b467d81418f7d" name="a4483f0a39a523dd1b37b467d81418f7d"></a>
<a class="el" href="class_radio_lib_hal.html">RadioLibHal</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>hal</b> = NULL</td></tr>
<tr class="memdesc:a4483f0a39a523dd1b37b467d81418f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hardware abstraction layer to be used. <br /></td></tr>
<tr class="separator:a4483f0a39a523dd1b37b467d81418f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4fc4101fb3f134152b458c447b8ecb" id="r_a3a4fc4101fb3f134152b458c447b8ecb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_module_1_1_s_p_i_config__t.html">SPIConfig_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_module.html#a3a4fc4101fb3f134152b458c447b8ecb">spiConfig</a></td></tr>
<tr class="memdesc:a3a4fc4101fb3f134152b458c447b8ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI configuration structure. The default configuration corresponds to register-access modules, such as <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a>.  <br /></td></tr>
<tr class="separator:a3a4fc4101fb3f134152b458c447b8ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0c11551e12579bbabf57b19e12555b3c" id="r_a0c11551e12579bbabf57b19e12555b3c"><td class="memItemLeft" align="right" valign="top"><a id="a0c11551e12579bbabf57b19e12555b3c" name="a0c11551e12579bbabf57b19e12555b3c"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><b>RFSWITCH_MAX_PINS</b> = 5</td></tr>
<tr class="memdesc:a0c11551e12579bbabf57b19e12555b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of pins supported by the RF switch code. Note: It is not recommended to use this constant in your sketch when defining a rfswitch pins array, to prevent issues when this value is ever increased and such an array gets extra zero elements (that will be interpreted as pin 0). <br /></td></tr>
<tr class="separator:a0c11551e12579bbabf57b19e12555b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements all common low-level methods to control the wireless module. Every module class contains one private instance of this class. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5a67b3a63420d762ecba9448671c99bf" name="a5a67b3a63420d762ecba9448671c99bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a67b3a63420d762ecba9448671c99bf">&#9670;&#160;</a></span>OpMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf">Module::OpMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios, but some radios define their own constants to be used instead. </p>
<p>See <a class="el" href="class_module.html#ac308fa817a5c36c5dc724a0d15cefd4d">setRfSwitchTable</a> for details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5a67b3a63420d762ecba9448671c99bfa81cdd8986054c2ae5657eb5dfd536770" name="a5a67b3a63420d762ecba9448671c99bfa81cdd8986054c2ae5657eb5dfd536770"></a>MODE_END_OF_TABLE&#160;</td><td class="fielddoc"><p>End of table marker, use END_OF_MODE_TABLE constant instead. Value is zero to ensure zero-initialized mode ends the table. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671" name="a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"></a>MODE_IDLE&#160;</td><td class="fielddoc"><p>Idle mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f" name="a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"></a>MODE_RX&#160;</td><td class="fielddoc"><p>Receive mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571" name="a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"></a>MODE_TX&#160;</td><td class="fielddoc"><p>Transmission mode. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a817178405f125e068e88bad62aeb6f3b" name="a817178405f125e068e88bad62aeb6f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817178405f125e068e88bad62aeb6f3b">&#9670;&#160;</a></span>Module() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module::Module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_radio_lib_hal.html">RadioLibHal</a> *&#160;</td>
          <td class="paramname"><em>hal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>gpio</em> = <code>RADIOLIB_NC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hal</td><td>A Hardware abstraction layer instance. An ArduinoHal instance for example. </td></tr>
    <tr><td class="paramname">cs</td><td>Pin to be used as chip select. </td></tr>
    <tr><td class="paramname">irq</td><td>Pin to be used as interrupt/GPIO. </td></tr>
    <tr><td class="paramname">rst</td><td>Pin to be used as hardware reset for the module. </td></tr>
    <tr><td class="paramname">gpio</td><td>Pin to be used as additional interrupt/GPIO. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a919baf2e46c357ebfcdbc1025b6c551e" name="a919baf2e46c357ebfcdbc1025b6c551e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919baf2e46c357ebfcdbc1025b6c551e">&#9670;&#160;</a></span>Module() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Module::Module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td><a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> instance to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5699a937b62ba41387567b4d679b9377" name="a5699a937b62ba41387567b4d679b9377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5699a937b62ba41387567b4d679b9377">&#9670;&#160;</a></span>findRfSwitchMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> * Module::findRfSwitchMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a mode in the RfSwitchTable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="struct_module_1_1_rf_switch_mode__t.html" title="Description of RF switch pin states for a single mode. See setRfSwitchTable for details.">RfSwitchMode_t</a> struct in the table that matches the passed mode. Returns nullptr if no rfswitch pins are configured, or the passed mode is not listed in the table. </dd></dl>

</div>
</div>
<a id="a4ec27f0ba5e0009ea9661a5110526b52" name="a4ec27f0ba5e0009ea9661a5110526b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec27f0ba5e0009ea9661a5110526b52">&#9670;&#160;</a></span>getGpio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Module::getGpio </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access method to get the pin number of second interrupt/GPIO. </p>
<dl class="section return"><dt>Returns</dt><dd>Pin number of second interrupt/GPIO configured in the constructor. </dd></dl>

</div>
</div>
<a id="ab61bc5066c356e2d0d79f08a2bd0fbc9" name="ab61bc5066c356e2d0d79f08a2bd0fbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61bc5066c356e2d0d79f08a2bd0fbc9">&#9670;&#160;</a></span>getIrq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Module::getIrq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access method to get the pin number of interrupt/GPIO. </p>
<dl class="section return"><dt>Returns</dt><dd>Pin number of interrupt/GPIO configured in the constructor. </dd></dl>

</div>
</div>
<a id="ad6cddbf3aebec9717a1a381dd81ad398" name="ad6cddbf3aebec9717a1a381dd81ad398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cddbf3aebec9717a1a381dd81ad398">&#9670;&#160;</a></span>getRst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Module::getRst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access method to get the pin number of hardware reset pin. </p>
<dl class="section return"><dt>Returns</dt><dd>Pin number of hardware reset pin configured in the constructor. </dd></dl>

</div>
</div>
<a id="a4ea888758b4a7784082d513a1e7849a4" name="a4ea888758b4a7784082d513a1e7849a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea888758b4a7784082d513a1e7849a4">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_module.html">Module</a> &amp; Module::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>rvalue <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d3adea64acab11c47c804afc74bd4f3" name="a7d3adea64acab11c47c804afc74bd4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3adea64acab11c47c804afc74bd4f3">&#9670;&#160;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH. </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<p>When more than two pins or more control over the output values are needed, use the <a class="el" href="class_module.html#ac308fa817a5c36c5dc724a0d15cefd4d" title="Some modules contain external RF switch controlled by pins. This function gives RadioLib control over...">setRfSwitchTable()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin. </td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbed643f082286012bf44bba22381ae6" name="afbed643f082286012bf44bba22381ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbed643f082286012bf44bba22381ae6">&#9670;&#160;</a></span>setRfSwitchState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::setRfSwitchState </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set RF switch state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The mode to set. This must be one of the MODE_ constants, or a radio-specific constant. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac308fa817a5c36c5dc724a0d15cefd4d" name="ac308fa817a5c36c5dc724a0d15cefd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac308fa817a5c36c5dc724a0d15cefd4d">&#9670;&#160;</a></span>setRfSwitchTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::setRfSwitchTable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>pins</em>[RFSWITCH_MAX_PINS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">RfSwitchMode_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes. </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pins</td><td>A reference to an array of pins to control. This should always be an array of 3 elements. If you need less pins, use RADIOLIB_NC for the unused elements.</td></tr>
    <tr><td class="paramname">table</td><td>A reference to an array of pin values to use for each supported mode. Each element is an RfSwitchMode_T struct that lists the mode for which it applies and the values for each of the pins passed in the pins argument respectively.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>pins</code> array will be copied into the <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> object, so the original array can be deallocated after this call. However, a reference to the <code>table</code> array will be stored, so that array must remain valid as long RadioLib is being used.</p>
<p>The <code>mode</code> field in each table row should normally use any of the <code>MODE_*</code> constants from the <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf" title="Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios,...">Module::OpMode_t</a> enum. However, some radios support additional modes and will define their own OpMode_t enum.</p>
<p>The length of the table is variable (to support radios that add additional modes), so the table must always be terminated with the special END_OF_MODE_TABLE value.</p>
<p>Normally all modes should be listed in the table, but for some radios, modes can be omitted to indicate they are not supported (e.g. when a radio has a high power and low power TX mode but external circuitry only supports low power). If applicable, this is documented in the radio class itself.</p>
<h4>Example</h4>
<p>For example, on a board that has an RF switch with an enable pin connected to PA0 and a TX/RX select pin connected to PA1:</p>
<div class="fragment"><div class="line"><span class="comment">// In global scope, define the pin array and mode table</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t rfswitch_pins[] =</div>
<div class="line">                       {PA0,  PA1,  RADIOLIB_NC};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> rfswitch_table[] = {</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a>,  {LOW,  LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a>,    {HIGH, LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a>,    {HIGH, HIGH}},</div>
<div class="line">   Module::END_OF_MODE_TABLE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Then somewhere in setup, pass them to radiolib</span></div>
<div class="line">  radio.setRfSwitchTable(rfswitch_pins, rfswitch_table);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a></div><div class="ttdeci">@ MODE_TX</div><div class="ttdoc">Transmission mode.</div><div class="ttdef"><b>Definition</b> Module.h:119</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a></div><div class="ttdeci">@ MODE_IDLE</div><div class="ttdoc">Idle mode.</div><div class="ttdef"><b>Definition</b> Module.h:113</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a></div><div class="ttdeci">@ MODE_RX</div><div class="ttdoc">Receive mode.</div><div class="ttdef"><b>Definition</b> Module.h:116</div></div>
<div class="ttc" id="astruct_module_1_1_rf_switch_mode__t_html"><div class="ttname"><a href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a></div><div class="ttdoc">Description of RF switch pin states for a single mode. See setRfSwitchTable for details.</div><div class="ttdef"><b>Definition</b> Module.h:89</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5efa7ae78cab1d7f43005e965923f769" name="a5efa7ae78cab1d7f43005e965923f769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5efa7ae78cab1d7f43005e965923f769">&#9670;&#160;</a></span>SPIcheckStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIcheckStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to check the result of last SPI stream transfer. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a369e916626c821ecec85f25d5b46d752" name="a369e916626c821ecec85f25d5b46d752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369e916626c821ecec85f25d5b46d752">&#9670;&#160;</a></span>SPIgetRegValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIgetRegValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msb</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lsb</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI read method that automatically masks unused bits. This method is the preferred SPI read mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to read. </td></tr>
    <tr><td class="paramname">msb</td><td>Most significant bit of the register variable. Bits above this one will be masked out. </td></tr>
    <tr><td class="paramname">lsb</td><td>Least significant bit of the register variable. Bits below this one will be masked out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Masked register value or status code. </dd></dl>

</div>
</div>
<a id="ab250eb929068e0c890e16e8e6d7cd7e6" name="ab250eb929068e0c890e16e8e6d7cd7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab250eb929068e0c890e16e8e6d7cd7e6">&#9670;&#160;</a></span>SPIreadRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Module::SPIreadRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI basic read method. Use of this method is reserved for special cases, SPIgetRegValue should be used instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Value that was read from register. </dd></dl>

</div>
</div>
<a id="ac993ab8e2ea0f5aa93339d1f6ffb54ee" name="ac993ab8e2ea0f5aa93339d1f6ffb54ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac993ab8e2ea0f5aa93339d1f6ffb54ee">&#9670;&#160;</a></span>SPIreadRegisterBurst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::SPIreadRegisterBurst </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>inBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI burst read method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to read. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes that will be read. </td></tr>
    <tr><td class="paramname">inBytes</td><td>Pointer to array that will hold the read data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4af5fc5fd60e0aadb8a69606e511946" name="ad4af5fc5fd60e0aadb8a69606e511946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4af5fc5fd60e0aadb8a69606e511946">&#9670;&#160;</a></span>SPIreadStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIreadStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForGpio</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform a read transaction with SPI stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI operation command. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>SPI command length in bytes. </td></tr>
    <tr><td class="paramname">data</td><td>Data that will be transferred from slave to master. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">waitForGpio</td><td>Whether to wait for some GPIO at the end of transfer (e.g. BUSY line on SX126x/SX128x). </td></tr>
    <tr><td class="paramname">verify</td><td>Whether to verify the result of the transaction after it is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adacceb57ecfecb09150c135b2b44436f" name="adacceb57ecfecb09150c135b2b44436f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacceb57ecfecb09150c135b2b44436f">&#9670;&#160;</a></span>SPIreadStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIreadStream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForGpio</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform a read transaction with SPI stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI operation command. </td></tr>
    <tr><td class="paramname">data</td><td>Data that will be transferred from slave to master. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">waitForGpio</td><td>Whether to wait for some GPIO at the end of transfer (e.g. BUSY line on SX126x/SX128x). </td></tr>
    <tr><td class="paramname">verify</td><td>Whether to verify the result of the transaction after it is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aed95fba2ee72d7a2a21f98dd63ae4ad1" name="aed95fba2ee72d7a2a21f98dd63ae4ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed95fba2ee72d7a2a21f98dd63ae4ad1">&#9670;&#160;</a></span>SPIsetRegValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIsetRegValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msb</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>lsb</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>checkInterval</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>checkMask</em> = <code>0xFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite-safe SPI write method with verification. This method is the preferred SPI write mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to write. </td></tr>
    <tr><td class="paramname">value</td><td>Single byte value that will be written to the SPI register. </td></tr>
    <tr><td class="paramname">msb</td><td>Most significant bit of the register variable. Bits above this one will not be affected by the write operation. </td></tr>
    <tr><td class="paramname">lsb</td><td>Least significant bit of the register variable. Bits below this one will not be affected by the write operation. </td></tr>
    <tr><td class="paramname">checkInterval</td><td>Number of milliseconds between register writing and verification reading. Some registers need up to 10ms to process the change. </td></tr>
    <tr><td class="paramname">checkMask</td><td>Mask of bits to check, only bits set to 1 will be verified. </td></tr>
    <tr><td class="paramname">force</td><td>Write new value even if the old value is the same. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2bfbddb1ff044f8b1865aac89246445d" name="a2bfbddb1ff044f8b1865aac89246445d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfbddb1ff044f8b1865aac89246445d">&#9670;&#160;</a></span>SPItransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::SPItransfer </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI single transfer method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI access command (read/write/burst/...). </td></tr>
    <tr><td class="paramname">reg</td><td>Address of SPI register to transfer to/from. </td></tr>
    <tr><td class="paramname">dataOut</td><td>Data that will be transferred from master to slave. </td></tr>
    <tr><td class="paramname">dataIn</td><td>Data that was transferred from slave to master. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b3f89fc63a82eb5fd55a7ddd72318fe" name="a2b3f89fc63a82eb5fd55a7ddd72318fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3f89fc63a82eb5fd55a7ddd72318fe">&#9670;&#160;</a></span>SPItransferStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPItransferStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>dataOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForGpio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI single transfer method for modules with stream-type SPI interface (<a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, <a class="el" href="class_s_x128x.html" title="Base class for SX128x series. All derived classes for SX128x (e.g. SX1280 or SX1281) inherit from thi...">SX128x</a> etc.). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI operation command. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>SPI command length in bytes. </td></tr>
    <tr><td class="paramname">write</td><td>Set to true for write commands, false for read commands. </td></tr>
    <tr><td class="paramname">dataOut</td><td>Data that will be transferred from master to slave. </td></tr>
    <tr><td class="paramname">dataIn</td><td>Data that was transferred from slave to master. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">waitForGpio</td><td>Whether to wait for some GPIO at the end of transfer (e.g. BUSY line on SX126x/SX128x). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a60ca6b4cae98f7d935191a569d519913" name="a60ca6b4cae98f7d935191a569d519913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ca6b4cae98f7d935191a569d519913">&#9670;&#160;</a></span>SPIwriteRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::SPIwriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI basic write method. Use of this method is reserved for special cases, SPIsetRegValue should be used instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to write. </td></tr>
    <tr><td class="paramname">data</td><td>Value that will be written to the register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10809e942c686b4e605269e58bd637b9" name="a10809e942c686b4e605269e58bd637b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10809e942c686b4e605269e58bd637b9">&#9670;&#160;</a></span>SPIwriteRegisterBurst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::SPIwriteRegisterBurst </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI burst write method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>Address of SPI register to write. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to array that holds the data that will be written. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes that will be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5594e8024d34d2d168413ae5c28e73b" name="af5594e8024d34d2d168413ae5c28e73b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5594e8024d34d2d168413ae5c28e73b">&#9670;&#160;</a></span>SPIwriteStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIwriteStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cmdLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForGpio</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform a write transaction with SPI stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI operation command. </td></tr>
    <tr><td class="paramname">cmdLen</td><td>SPI command length in bytes. </td></tr>
    <tr><td class="paramname">data</td><td>Data that will be transferred from master to slave. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">waitForGpio</td><td>Whether to wait for some GPIO at the end of transfer (e.g. BUSY line on SX126x/SX128x). </td></tr>
    <tr><td class="paramname">verify</td><td>Whether to verify the result of the transaction after it is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a47e6e0c4e792a5ef7b3bb040947666a6" name="a47e6e0c4e792a5ef7b3bb040947666a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e6e0c4e792a5ef7b3bb040947666a6">&#9670;&#160;</a></span>SPIwriteStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Module::SPIwriteStream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForGpio</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to perform a write transaction with SPI stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>SPI operation command. </td></tr>
    <tr><td class="paramname">data</td><td>Data that will be transferred from master to slave. </td></tr>
    <tr><td class="paramname">numBytes</td><td>Number of bytes to transfer. </td></tr>
    <tr><td class="paramname">waitForGpio</td><td>Whether to wait for some GPIO at the end of transfer (e.g. BUSY line on SX126x/SX128x). </td></tr>
    <tr><td class="paramname">verify</td><td>Whether to verify the result of the transaction after it is finished. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7df4c687249c07af2594a5f7ad0a946f" name="a7df4c687249c07af2594a5f7ad0a946f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df4c687249c07af2594a5f7ad0a946f">&#9670;&#160;</a></span>waitForMicroseconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Module::waitForMicroseconds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for time to elapse, either using the microsecond timer, or the TimerFlag. Note that in interrupt timing mode, it is up to the user to set up the timing interrupt! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Waiting start timestamp, in microseconds. </td></tr>
    <tr><td class="paramname">len</td><td>Waiting duration, in microseconds; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3a4fc4101fb3f134152b458c447b8ecb" name="a3a4fc4101fb3f134152b458c447b8ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4fc4101fb3f134152b458c447b8ecb">&#9670;&#160;</a></span>spiConfig</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_module_1_1_s_p_i_config__t.html">SPIConfig_t</a> Module::spiConfig</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">      .stream = <span class="keyword">false</span>,</div>
<div class="line">      .err = <a class="code hl_define" href="group__status__codes.html#gacc0baeb3e5fc99760a07d18ba55531b6">RADIOLIB_ERR_UNKNOWN</a>,</div>
<div class="line">      .cmds = { 0x00, 0x80, 0x00, 0x00 },</div>
<div class="line">      .widths = { Module::BITS_8, Module::BITS_0, Module::BITS_8 },</div>
<div class="line">      .statusPos = 0,</div>
<div class="line">      .parseStatusCb = <span class="keyword">nullptr</span>,</div>
<div class="line">      .checkStatusCb = <span class="keyword">nullptr</span>,</div>
<div class="line">      .timeout = 1000,</div>
<div class="line">    }</div>
<div class="ttc" id="agroup__status__codes_html_gacc0baeb3e5fc99760a07d18ba55531b6"><div class="ttname"><a href="group__status__codes.html#gacc0baeb3e5fc99760a07d18ba55531b6">RADIOLIB_ERR_UNKNOWN</a></div><div class="ttdeci">#define RADIOLIB_ERR_UNKNOWN</div><div class="ttdoc">There was an unexpected, unknown error. If you see this, something went incredibly wrong....</div><div class="ttdef"><b>Definition</b> TypeDef.h:110</div></div>
</div><!-- fragment -->
<p>SPI configuration structure. The default configuration corresponds to register-access modules, such as <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_module_8h_source.html">Module.h</a></li>
<li>src/<b>Module.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_module.html">Module</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
