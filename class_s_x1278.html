<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: SX1278 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_s_x1278.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_x1278-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SX1278 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Derived class for SX1278 modules. Also used as base class for <a class="el" href="class_s_x1276.html" title="Derived class for SX1276 modules. Overrides some methods from SX1278 due to different parameter range...">SX1276</a>, <a class="el" href="class_s_x1277.html" title="Derived class for SX1277 modules. Overrides some methods from SX1278 due to different parameter range...">SX1277</a>, <a class="el" href="class_s_x1279.html" title="Derived class for SX1279 modules. Overrides some methods from SX1278 due to different parameter range...">SX1279</a>, <a class="el" href="class_r_f_m95.html" title="Only exists as alias for SX1276, since there seems to be no difference between RFM95 and SX1276 modul...">RFM95</a> and <a class="el" href="class_r_f_m96.html" title="Only exists as alias for SX1276, since there seems to be no difference between RFM96 and SX1276 modul...">RFM96</a>. All of these modules use the same basic hardware and only differ in parameter ranges (and names).  
 <a href="class_s_x1278.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_x1278_8h_source.html">SX1278.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SX1278:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_x1278.png" usemap="#SX1278_map" alt=""/>
  <map id="SX1278_map" name="SX1278_map">
<area href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi..." alt="SX127x" shape="rect" coords="103,56,196,80"/>
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="103,0,196,24"/>
<area href="class_s_x1276.html" title="Derived class for SX1276 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1276" shape="rect" coords="0,168,93,192"/>
<area href="class_s_x1277.html" title="Derived class for SX1277 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1277" shape="rect" coords="103,168,196,192"/>
<area href="class_s_x1279.html" title="Derived class for SX1279 modules. Overrides some methods from SX1278 due to different parameter range..." alt="SX1279" shape="rect" coords="206,168,299,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00ebd3e60a66056940b241b13da0c68e" id="r_a00ebd3e60a66056940b241b13da0c68e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a00ebd3e60a66056940b241b13da0c68e">SX1278</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:a00ebd3e60a66056940b241b13da0c68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Called from Arduino sketch when creating new LoRa instance.  <br /></td></tr>
<tr class="separator:a00ebd3e60a66056940b241b13da0c68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867a336ae900f4a221d42b4c807122cf" id="r_a867a336ae900f4a221d42b4c807122cf"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a867a336ae900f4a221d42b4c807122cf">begin</a> (float freq=434.0, float bw=125.0, uint8_t sf=9, uint8_t cr=7, uint8_t syncWord=RADIOLIB_SX127X_SYNC_WORD, int8_t power=10, uint16_t preambleLength=8, uint8_t gain=0)</td></tr>
<tr class="memdesc:a867a336ae900f4a221d42b4c807122cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">LoRa modem initialization method. Must be called at least once from Arduino sketch to initialize the module.  <br /></td></tr>
<tr class="separator:a867a336ae900f4a221d42b4c807122cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86464af008b71d12948690b780280e7d" id="r_a86464af008b71d12948690b780280e7d"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a86464af008b71d12948690b780280e7d">beginFSK</a> (float freq=434.0, float br=4.8, float freqDev=5.0, float rxBw=125.0, int8_t power=10, uint16_t preambleLength=16, bool enableOOK=false)</td></tr>
<tr class="memdesc:a86464af008b71d12948690b780280e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FSK modem initialization method. Must be called at least once from Arduino sketch to initialize the module.  <br /></td></tr>
<tr class="separator:a86464af008b71d12948690b780280e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d60902ac59b653a9eb83e82a932f7ad" id="r_a6d60902ac59b653a9eb83e82a932f7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a6d60902ac59b653a9eb83e82a932f7ad">reset</a> () override</td></tr>
<tr class="memdesc:a6d60902ac59b653a9eb83e82a932f7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin.  <br /></td></tr>
<tr class="separator:a6d60902ac59b653a9eb83e82a932f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4d95d3b2798cf8ea94890ae71dcc59" id="r_adb4d95d3b2798cf8ea94890ae71dcc59"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#adb4d95d3b2798cf8ea94890ae71dcc59">setFrequency</a> (float freq) override</td></tr>
<tr class="memdesc:adb4d95d3b2798cf8ea94890ae71dcc59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Allowed values range from 137.0 MHz to 525.0 MHz.  <br /></td></tr>
<tr class="separator:adb4d95d3b2798cf8ea94890ae71dcc59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c27ed1ebaae4e3ed8afe3ae6941dd6" id="r_a46c27ed1ebaae4e3ed8afe3ae6941dd6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a46c27ed1ebaae4e3ed8afe3ae6941dd6">setBandwidth</a> (float bw)</td></tr>
<tr class="memdesc:a46c27ed1ebaae4e3ed8afe3ae6941dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa link bandwidth. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125, 250 and 500 kHz. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:a46c27ed1ebaae4e3ed8afe3ae6941dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70c22fe38bc3b944070ccbc083fed08" id="r_af70c22fe38bc3b944070ccbc083fed08"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#af70c22fe38bc3b944070ccbc083fed08">setSpreadingFactor</a> (uint8_t sf)</td></tr>
<tr class="memdesc:af70c22fe38bc3b944070ccbc083fed08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa link spreading factor. Allowed values range from 6 to 12. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:af70c22fe38bc3b944070ccbc083fed08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834f26a0bd3fc8a03fa7e68aa4daf9e1" id="r_a834f26a0bd3fc8a03fa7e68aa4daf9e1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a834f26a0bd3fc8a03fa7e68aa4daf9e1">setCodingRate</a> (uint8_t cr)</td></tr>
<tr class="memdesc:a834f26a0bd3fc8a03fa7e68aa4daf9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa link coding rate denominator. Allowed values range from 4 to 8. Only available in LoRa mode. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC.  <br /></td></tr>
<tr class="separator:a834f26a0bd3fc8a03fa7e68aa4daf9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6df07fc4972cc656f05670e6802f67" id="r_afd6df07fc4972cc656f05670e6802f67"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#afd6df07fc4972cc656f05670e6802f67">setBitRate</a> (float br) override</td></tr>
<tr class="memdesc:afd6df07fc4972cc656f05670e6802f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK bit rate. Allowed values range from 0.5 to 300 kbps. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:afd6df07fc4972cc656f05670e6802f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68af98ab018cfdb70edde1051dcb1dc" id="r_ac68af98ab018cfdb70edde1051dcb1dc"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ac68af98ab018cfdb70edde1051dcb1dc">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE) override</td></tr>
<tr class="memdesc:ac68af98ab018cfdb70edde1051dcb1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data rate.  <br /></td></tr>
<tr class="separator:ac68af98ab018cfdb70edde1051dcb1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9d9f371a3a53a0be25cc05284ade47" id="r_a6f9d9f371a3a53a0be25cc05284ade47"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a6f9d9f371a3a53a0be25cc05284ade47">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE) override</td></tr>
<tr class="memdesc:a6f9d9f371a3a53a0be25cc05284ade47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module.  <br /></td></tr>
<tr class="separator:a6f9d9f371a3a53a0be25cc05284ade47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69abc18e7fa0055e6b80024e8cde7db4" id="r_a69abc18e7fa0055e6b80024e8cde7db4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a69abc18e7fa0055e6b80024e8cde7db4">setOutputPower</a> (int8_t power) override</td></tr>
<tr class="memdesc:a69abc18e7fa0055e6b80024e8cde7db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission output power. Allowed values range from -4 to 15 dBm (RFO pin) or +2 to +17 dBm (PA_BOOST pin). High power +20 dBm operation is also supported, on the PA_BOOST pin. Defaults to PA_BOOST.  <br /></td></tr>
<tr class="separator:a69abc18e7fa0055e6b80024e8cde7db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab206a23ac93f5687ba5f6741fa690130" id="r_ab206a23ac93f5687ba5f6741fa690130"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ab206a23ac93f5687ba5f6741fa690130">setOutputPower</a> (int8_t power, bool forceRfo)</td></tr>
<tr class="memdesc:ab206a23ac93f5687ba5f6741fa690130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission output power. Allowed values range from -4 to 15 dBm (RFO pin) or +2 to +17 dBm (PA_BOOST pin). High power +20 dBm operation is also supported, on the PA_BOOST pin.  <br /></td></tr>
<tr class="separator:ab206a23ac93f5687ba5f6741fa690130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7b585c4a616a1cd6f89a8b46a7d9f8" id="r_aac7b585c4a616a1cd6f89a8b46a7d9f8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#aac7b585c4a616a1cd6f89a8b46a7d9f8">checkOutputPower</a> (int8_t power, int8_t *clipped) override</td></tr>
<tr class="memdesc:aac7b585c4a616a1cd6f89a8b46a7d9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>.  <br /></td></tr>
<tr class="separator:aac7b585c4a616a1cd6f89a8b46a7d9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6146c2a3d0a35662312165325fd97f8" id="r_ac6146c2a3d0a35662312165325fd97f8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ac6146c2a3d0a35662312165325fd97f8">checkOutputPower</a> (int8_t power, int8_t *clipped, bool useRfo)</td></tr>
<tr class="memdesc:ac6146c2a3d0a35662312165325fd97f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable.  <br /></td></tr>
<tr class="separator:ac6146c2a3d0a35662312165325fd97f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57b713988cfa224a6db2ff325052931" id="r_aa57b713988cfa224a6db2ff325052931"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#aa57b713988cfa224a6db2ff325052931">setGain</a> (uint8_t gain)</td></tr>
<tr class="memdesc:aa57b713988cfa224a6db2ff325052931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets gain of receiver LNA (low-noise amplifier). Can be set to any integer in range 1 to 6 where 1 is the highest gain. Set to 0 to enable automatic gain control (recommended).  <br /></td></tr>
<tr class="separator:aa57b713988cfa224a6db2ff325052931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb740a4925b64d83d5edca10d93f0563" id="r_afb740a4925b64d83d5edca10d93f0563"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#afb740a4925b64d83d5edca10d93f0563">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:afb740a4925b64d83d5edca10d93f0563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Gaussian filter bandwidth-time product that will be used for data shaping. Only available in FSK mode with FSK modulation. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <br /></td></tr>
<tr class="separator:afb740a4925b64d83d5edca10d93f0563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ccc4d5062f739d534ab22562c7efca4" id="r_a1ccc4d5062f739d534ab22562c7efca4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a1ccc4d5062f739d534ab22562c7efca4">setDataShapingOOK</a> (uint8_t sh)</td></tr>
<tr class="memdesc:a1ccc4d5062f739d534ab22562c7efca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets filter cutoff frequency that will be used for data shaping. Allowed values are 1 for frequency equal to bit rate and 2 for frequency equal to 2x bit rate. Set to 0 to disable data shaping. Only available in FSK mode with OOK modulation.  <br /></td></tr>
<tr class="separator:a1ccc4d5062f739d534ab22562c7efca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fcdc2962d1cf3410be208154d98ae4b" id="r_a0fcdc2962d1cf3410be208154d98ae4b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a0fcdc2962d1cf3410be208154d98ae4b">getRSSI</a> () override</td></tr>
<tr class="memdesc:a0fcdc2962d1cf3410be208154d98ae4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets recorded signal strength indicator. Overload with packet mode enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <br /></td></tr>
<tr class="separator:a0fcdc2962d1cf3410be208154d98ae4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17357254073baeb7490c98faf10d991" id="r_ab17357254073baeb7490c98faf10d991"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ab17357254073baeb7490c98faf10d991">getRSSI</a> (bool packet, bool skipReceive=false)</td></tr>
<tr class="memdesc:ab17357254073baeb7490c98faf10d991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets recorded signal strength indicator.  <br /></td></tr>
<tr class="separator:ab17357254073baeb7490c98faf10d991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0be7586b8e40355bbd29d78ae9941d1" id="r_ac0be7586b8e40355bbd29d78ae9941d1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ac0be7586b8e40355bbd29d78ae9941d1">setCRC</a> (bool enable, bool mode=false)</td></tr>
<tr class="memdesc:ac0be7586b8e40355bbd29d78ae9941d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables CRC check of received packets.  <br /></td></tr>
<tr class="separator:ac0be7586b8e40355bbd29d78ae9941d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6398c4d4fde302d6d4752708bce856" id="r_a6d6398c4d4fde302d6d4752708bce856"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a6d6398c4d4fde302d6d4752708bce856">forceLDRO</a> (bool enable)</td></tr>
<tr class="memdesc:a6d6398c4d4fde302d6d4752708bce856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces LoRa low data rate optimization. Only available in LoRa mode. After calling this method, LDRO will always be set to the provided value, regardless of symbol length. To re-enable automatic LDRO configuration, call <a class="el" href="class_s_x1278.html#ae02adcde8c2978c0d1b157729dd5df1e" title="Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method,...">SX1278::autoLDRO()</a>  <br /></td></tr>
<tr class="separator:a6d6398c4d4fde302d6d4752708bce856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02adcde8c2978c0d1b157729dd5df1e" id="r_ae02adcde8c2978c0d1b157729dd5df1e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#ae02adcde8c2978c0d1b157729dd5df1e">autoLDRO</a> ()</td></tr>
<tr class="memdesc:ae02adcde8c2978c0d1b157729dd5df1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method, LDRO will be enabled automatically when symbol length exceeds 16 ms.  <br /></td></tr>
<tr class="separator:ae02adcde8c2978c0d1b157729dd5df1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f5ac7dd6587b86c5f2c2b16336612e" id="r_a47f5ac7dd6587b86c5f2c2b16336612e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a47f5ac7dd6587b86c5f2c2b16336612e">implicitHeader</a> (size_t len)</td></tr>
<tr class="memdesc:a47f5ac7dd6587b86c5f2c2b16336612e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set implicit header mode for future reception/transmission. Required for spreading factor 6.  <br /></td></tr>
<tr class="separator:a47f5ac7dd6587b86c5f2c2b16336612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7717f09820a8e9a93621b0a00713f1" id="r_a7c7717f09820a8e9a93621b0a00713f1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a7c7717f09820a8e9a93621b0a00713f1">explicitHeader</a> ()</td></tr>
<tr class="memdesc:a7c7717f09820a8e9a93621b0a00713f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set explicit header mode for future reception/transmission.  <br /></td></tr>
<tr class="separator:a7c7717f09820a8e9a93621b0a00713f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609dd3faf2036e8c2d046fd191e0137d" id="r_a609dd3faf2036e8c2d046fd191e0137d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x1278.html#a609dd3faf2036e8c2d046fd191e0137d">setModem</a> (ModemType_t modem) override</td></tr>
<tr class="memdesc:a609dd3faf2036e8c2d046fd191e0137d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters.  <br /></td></tr>
<tr class="separator:a609dd3faf2036e8c2d046fd191e0137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_s_x127x"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_s_x127x')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_s_x127x.html">SX127x</a></td></tr>
<tr class="memitem:ac74c5914ca429a3892c66b9d98e3ea6c inherit pub_methods_class_s_x127x" id="r_ac74c5914ca429a3892c66b9d98e3ea6c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac74c5914ca429a3892c66b9d98e3ea6c">SX127x</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:ac74c5914ca429a3892c66b9d98e3ea6c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. Called internally when creating new LoRa instance.  <br /></td></tr>
<tr class="separator:ac74c5914ca429a3892c66b9d98e3ea6c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddbde7fd8eb06d38abfb658eee29bc1 inherit pub_methods_class_s_x127x" id="r_a7ddbde7fd8eb06d38abfb658eee29bc1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7ddbde7fd8eb06d38abfb658eee29bc1">begin</a> (const uint8_t *chipVersions, uint8_t numVersions, uint8_t syncWord, uint16_t preambleLength)</td></tr>
<tr class="memdesc:a7ddbde7fd8eb06d38abfb658eee29bc1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method. Will be called with appropriate parameters when calling initialization method from derived class.  <br /></td></tr>
<tr class="separator:a7ddbde7fd8eb06d38abfb658eee29bc1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fe001474583d490df1d0b38260bf8e inherit pub_methods_class_s_x127x" id="r_a66fe001474583d490df1d0b38260bf8e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a66fe001474583d490df1d0b38260bf8e">beginFSK</a> (const uint8_t *chipVersions, uint8_t numVersions, float freqDev, float rxBw, uint16_t preambleLength, bool enableOOK)</td></tr>
<tr class="memdesc:a66fe001474583d490df1d0b38260bf8e inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem. Will be called with appropriate parameters when calling FSK initialization method from derived class.  <br /></td></tr>
<tr class="separator:a66fe001474583d490df1d0b38260bf8e inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cb0d8810a5ce025d3bf5b51ca263d6 inherit pub_methods_class_s_x127x" id="r_a75cb0d8810a5ce025d3bf5b51ca263d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a75cb0d8810a5ce025d3bf5b51ca263d6">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a75cb0d8810a5ce025d3bf5b51ca263d6 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Will transmit arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to transmit Arduino String or C-string, see <a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534" title="C-string transmit method.">PhysicalLayer::transmit</a>.  <br /></td></tr>
<tr class="separator:a75cb0d8810a5ce025d3bf5b51ca263d6 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d6b2d3cb8ce3ebb50adb35430dfd3c inherit pub_methods_class_s_x127x" id="r_a53d6b2d3cb8ce3ebb50adb35430dfd3c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a53d6b2d3cb8ce3ebb50adb35430dfd3c">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0) override</td></tr>
<tr class="memdesc:a53d6b2d3cb8ce3ebb50adb35430dfd3c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Will attempt to receive arbitrary binary data up to 255 bytes long using LoRa or up to 63 bytes using FSK modem. For overloads to receive Arduino String, see <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8" title="Binary receive method. Must be implemented in module class.">PhysicalLayer::receive</a>.  <br /></td></tr>
<tr class="separator:a53d6b2d3cb8ce3ebb50adb35430dfd3c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae97e18744dc617bc9326cfbaad3a3 inherit pub_methods_class_s_x127x" id="r_a13ae97e18744dc617bc9326cfbaad3a3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a13ae97e18744dc617bc9326cfbaad3a3">scanChannel</a> () override</td></tr>
<tr class="memdesc:a13ae97e18744dc617bc9326cfbaad3a3 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for valid LoRa preamble in the current channel.  <br /></td></tr>
<tr class="separator:a13ae97e18744dc617bc9326cfbaad3a3 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff85ee7979da08b4e66316f1ba2c6a9 inherit pub_methods_class_s_x127x" id="r_a1ff85ee7979da08b4e66316f1ba2c6a9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1ff85ee7979da08b4e66316f1ba2c6a9">sleep</a> () override</td></tr>
<tr class="memdesc:a1ff85ee7979da08b4e66316f1ba2c6a9 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to sleep to save power. Module will not be able to transmit or receive any data while in sleep mode. Module will wake up automatically when methods like transmit or receive are called.  <br /></td></tr>
<tr class="separator:a1ff85ee7979da08b4e66316f1ba2c6a9 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760b8c5103128f122fbe489c6529ce41 inherit pub_methods_class_s_x127x" id="r_a760b8c5103128f122fbe489c6529ce41"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a760b8c5103128f122fbe489c6529ce41">standby</a> () override</td></tr>
<tr class="memdesc:a760b8c5103128f122fbe489c6529ce41 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to standby.  <br /></td></tr>
<tr class="separator:a760b8c5103128f122fbe489c6529ce41 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa565bbff460e487672953dc05d335cb0 inherit pub_methods_class_s_x127x" id="r_aa565bbff460e487672953dc05d335cb0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa565bbff460e487672953dc05d335cb0">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:aa565bbff460e487672953dc05d335cb0 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the LoRa module to standby.  <br /></td></tr>
<tr class="separator:aa565bbff460e487672953dc05d335cb0 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeeb9f7192e11a75b5dfb1ab8488e84 inherit pub_methods_class_s_x127x" id="r_aefeeb9f7192e11a75b5dfb1ab8488e84"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aefeeb9f7192e11a75b5dfb1ab8488e84">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:aefeeb9f7192e11a75b5dfb1ab8488e84 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct transmission mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:aefeeb9f7192e11a75b5dfb1ab8488e84 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac558d537c6364c4bc82c8f33e398f inherit pub_methods_class_s_x127x" id="r_aa7ac558d537c6364c4bc82c8f33e398f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa7ac558d537c6364c4bc82c8f33e398f">receiveDirect</a> () override</td></tr>
<tr class="memdesc:aa7ac558d537c6364c4bc82c8f33e398f inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables direct reception mode on pins DIO1 (clock) and DIO2 (data). While in direct mode, the module will not be able to transmit or receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:aa7ac558d537c6364c4bc82c8f33e398f inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0995088d37689a3c240a1af791df6cf1 inherit pub_methods_class_s_x127x" id="r_a0995088d37689a3c240a1af791df6cf1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0995088d37689a3c240a1af791df6cf1">packetMode</a> ()</td></tr>
<tr class="memdesc:a0995088d37689a3c240a1af791df6cf1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables direct mode and enables packet mode, allowing the module to receive packets. Can only be activated in FSK mode.  <br /></td></tr>
<tr class="separator:a0995088d37689a3c240a1af791df6cf1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75bc48cc74a407370cd9f4bf95e9e30 inherit pub_methods_class_s_x127x" id="r_ae75bc48cc74a407370cd9f4bf95e9e30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae75bc48cc74a407370cd9f4bf95e9e30">setDio0Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:ae75bc48cc74a407370cd9f4bf95e9e30 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO0 activates.  <br /></td></tr>
<tr class="separator:ae75bc48cc74a407370cd9f4bf95e9e30 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729b4f3f36096b5b15bae19c7876e823 inherit pub_methods_class_s_x127x" id="r_a729b4f3f36096b5b15bae19c7876e823"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearDio0Action</b> ()</td></tr>
<tr class="memdesc:a729b4f3f36096b5b15bae19c7876e823 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO0 activates. <br /></td></tr>
<tr class="separator:a729b4f3f36096b5b15bae19c7876e823 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4bce81839b105c464ebf922602e58b inherit pub_methods_class_s_x127x" id="r_a7b4bce81839b105c464ebf922602e58b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b4bce81839b105c464ebf922602e58b">setDio1Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:a7b4bce81839b105c464ebf922602e58b inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when DIO1 activates.  <br /></td></tr>
<tr class="separator:a7b4bce81839b105c464ebf922602e58b inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6532a25e1730973ac08146008adca5 inherit pub_methods_class_s_x127x" id="r_a9b6532a25e1730973ac08146008adca5"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearDio1Action</b> ()</td></tr>
<tr class="memdesc:a9b6532a25e1730973ac08146008adca5 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO1 activates. <br /></td></tr>
<tr class="separator:a9b6532a25e1730973ac08146008adca5 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae236a467095fb5364d0fc4a98d85f96e inherit pub_methods_class_s_x127x" id="r_ae236a467095fb5364d0fc4a98d85f96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae236a467095fb5364d0fc4a98d85f96e">setPacketReceivedAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ae236a467095fb5364d0fc4a98d85f96e inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:ae236a467095fb5364d0fc4a98d85f96e inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbc4c256d37f9cdabf9e5f2ef16aa92 inherit pub_methods_class_s_x127x" id="r_a6cbc4c256d37f9cdabf9e5f2ef16aa92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6cbc4c256d37f9cdabf9e5f2ef16aa92">clearPacketReceivedAction</a> () override</td></tr>
<tr class="memdesc:a6cbc4c256d37f9cdabf9e5f2ef16aa92 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a6cbc4c256d37f9cdabf9e5f2ef16aa92 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3530e8e19cfe4d96fe49ca4e6386b099 inherit pub_methods_class_s_x127x" id="r_a3530e8e19cfe4d96fe49ca4e6386b099"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3530e8e19cfe4d96fe49ca4e6386b099">setPacketSentAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a3530e8e19cfe4d96fe49ca4e6386b099 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a3530e8e19cfe4d96fe49ca4e6386b099 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec32a52b13752d75f3076a5868c312d inherit pub_methods_class_s_x127x" id="r_a2ec32a52b13752d75f3076a5868c312d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2ec32a52b13752d75f3076a5868c312d">clearPacketSentAction</a> () override</td></tr>
<tr class="memdesc:a2ec32a52b13752d75f3076a5868c312d inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a2ec32a52b13752d75f3076a5868c312d inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23c2b384ae8611d59e10ef6a14fe7e4 inherit pub_methods_class_s_x127x" id="r_ac23c2b384ae8611d59e10ef6a14fe7e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac23c2b384ae8611d59e10ef6a14fe7e4">setChannelScanAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ac23c2b384ae8611d59e10ef6a14fe7e4 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:ac23c2b384ae8611d59e10ef6a14fe7e4 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce9beca21406e3556b3518370947ee2 inherit pub_methods_class_s_x127x" id="r_a0ce9beca21406e3556b3518370947ee2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0ce9beca21406e3556b3518370947ee2">clearChannelScanAction</a> () override</td></tr>
<tr class="memdesc:a0ce9beca21406e3556b3518370947ee2 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:a0ce9beca21406e3556b3518370947ee2 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbdfd8e2a2ad1eb7e59a73385847acb inherit pub_methods_class_s_x127x" id="r_a6fbdfd8e2a2ad1eb7e59a73385847acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fbdfd8e2a2ad1eb7e59a73385847acb">setFifoEmptyAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a6fbdfd8e2a2ad1eb7e59a73385847acb inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is empty.  <br /></td></tr>
<tr class="separator:a6fbdfd8e2a2ad1eb7e59a73385847acb inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6eb4363badc1c3450ad7a4d11af4b1 inherit pub_methods_class_s_x127x" id="r_aaa6eb4363badc1c3450ad7a4d11af4b1"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFifoEmptyAction</b> ()</td></tr>
<tr class="memdesc:aaa6eb4363badc1c3450ad7a4d11af4b1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when FIFO is empty. <br /></td></tr>
<tr class="separator:aaa6eb4363badc1c3450ad7a4d11af4b1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9529ac87f62c32c9c5fac3dc6e08a9 inherit pub_methods_class_s_x127x" id="r_a7b9529ac87f62c32c9c5fac3dc6e08a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b9529ac87f62c32c9c5fac3dc6e08a9">setFifoThreshold</a> (uint8_t threshold)</td></tr>
<tr class="memdesc:a7b9529ac87f62c32c9c5fac3dc6e08a9 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set FIFO threshold level. Be aware that threshold is also set in setFifoFullAction method. setFifoThreshold method must be called AFTER calling setFifoFullAction!  <br /></td></tr>
<tr class="separator:a7b9529ac87f62c32c9c5fac3dc6e08a9 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201c31366f32c41b801724fb662265c1 inherit pub_methods_class_s_x127x" id="r_a201c31366f32c41b801724fb662265c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a201c31366f32c41b801724fb662265c1">setFifoFullAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a201c31366f32c41b801724fb662265c1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is full.  <br /></td></tr>
<tr class="separator:a201c31366f32c41b801724fb662265c1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f041e91ab2fbb6f05eef56b5addac71 inherit pub_methods_class_s_x127x" id="r_a0f041e91ab2fbb6f05eef56b5addac71"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFifoFullAction</b> ()</td></tr>
<tr class="memdesc:a0f041e91ab2fbb6f05eef56b5addac71 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when FIFO is full. <br /></td></tr>
<tr class="separator:a0f041e91ab2fbb6f05eef56b5addac71 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dbd1697a415c6db3b47cd620c8c02e inherit pub_methods_class_s_x127x" id="r_a36dbd1697a415c6db3b47cd620c8c02e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a36dbd1697a415c6db3b47cd620c8c02e">fifoAdd</a> (uint8_t *data, int totalLen, int *remLen)</td></tr>
<tr class="memdesc:a36dbd1697a415c6db3b47cd620c8c02e inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is empty.  <br /></td></tr>
<tr class="separator:a36dbd1697a415c6db3b47cd620c8c02e inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b193b71ddb6015d25b0a161809d75a inherit pub_methods_class_s_x127x" id="r_a25b193b71ddb6015d25b0a161809d75a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a25b193b71ddb6015d25b0a161809d75a">fifoGet</a> (volatile uint8_t *data, int totalLen, volatile int *rcvLen)</td></tr>
<tr class="memdesc:a25b193b71ddb6015d25b0a161809d75a inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when FIFO is sufficiently full to read.  <br /></td></tr>
<tr class="separator:a25b193b71ddb6015d25b0a161809d75a inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9cec52b7fbd0c69cbd861dc17549f inherit pub_methods_class_s_x127x" id="r_a7fd9cec52b7fbd0c69cbd861dc17549f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7fd9cec52b7fbd0c69cbd861dc17549f">finishTransmit</a> () override</td></tr>
<tr class="memdesc:a7fd9cec52b7fbd0c69cbd861dc17549f inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <br /></td></tr>
<tr class="separator:a7fd9cec52b7fbd0c69cbd861dc17549f inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe1076252a366c3c4aa323fdff7d40c inherit pub_methods_class_s_x127x" id="r_abbe1076252a366c3c4aa323fdff7d40c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abbe1076252a366c3c4aa323fdff7d40c">startReceive</a> () override</td></tr>
<tr class="memdesc:abbe1076252a366c3c4aa323fdff7d40c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:abbe1076252a366c3c4aa323fdff7d40c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc840e8d6fe5e222f0143be17876745 inherit pub_methods_class_s_x127x" id="r_abfc840e8d6fe5e222f0143be17876745"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abfc840e8d6fe5e222f0143be17876745">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:abfc840e8d6fe5e222f0143be17876745 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData!  <br /></td></tr>
<tr class="separator:abfc840e8d6fe5e222f0143be17876745 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaec05c056dacb2c2171eaa8521be4bb inherit pub_methods_class_s_x127x" id="r_acaec05c056dacb2c2171eaa8521be4bb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#acaec05c056dacb2c2171eaa8521be4bb">finishReceive</a> () override</td></tr>
<tr class="memdesc:acaec05c056dacb2c2171eaa8521be4bb inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after reception is done.  <br /></td></tr>
<tr class="separator:acaec05c056dacb2c2171eaa8521be4bb inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa5723724393576ed597509200e17d1 inherit pub_methods_class_s_x127x" id="r_a6fa5723724393576ed597509200e17d1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fa5723724393576ed597509200e17d1">startChannelScan</a> () override</td></tr>
<tr class="memdesc:a6fa5723724393576ed597509200e17d1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. DIO0 will be activated when LoRa preamble is detected. DIO1 will be activated if there's no preamble detected before timeout.  <br /></td></tr>
<tr class="separator:a6fa5723724393576ed597509200e17d1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81189ce77541d78fc8feb99c2a3f35b2 inherit pub_methods_class_s_x127x" id="r_a81189ce77541d78fc8feb99c2a3f35b2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a81189ce77541d78fc8feb99c2a3f35b2">getChannelScanResult</a> () override</td></tr>
<tr class="memdesc:a81189ce77541d78fc8feb99c2a3f35b2 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <br /></td></tr>
<tr class="separator:a81189ce77541d78fc8feb99c2a3f35b2 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c7f4584352a12390594395d9c29bde inherit pub_methods_class_s_x127x" id="r_ac5c7f4584352a12390594395d9c29bde"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5c7f4584352a12390594395d9c29bde">setSyncWord</a> (uint8_t syncWord)</td></tr>
<tr class="memdesc:ac5c7f4584352a12390594395d9c29bde inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa sync word. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:ac5c7f4584352a12390594395d9c29bde inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400575e3d83977bd250c5cb382fc7002 inherit pub_methods_class_s_x127x" id="r_a400575e3d83977bd250c5cb382fc7002"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a400575e3d83977bd250c5cb382fc7002">setCurrentLimit</a> (uint8_t currentLimit)</td></tr>
<tr class="memdesc:a400575e3d83977bd250c5cb382fc7002 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current limit for over current protection at transmitter amplifier. Allowed values range from 45 to 120 mA in 5 mA steps and 120 to 240 mA in 10 mA steps.  <br /></td></tr>
<tr class="separator:a400575e3d83977bd250c5cb382fc7002 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844499bace6ae001446d71bee2877656 inherit pub_methods_class_s_x127x" id="r_a844499bace6ae001446d71bee2877656"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a844499bace6ae001446d71bee2877656">setPreambleLength</a> (size_t preambleLength) override</td></tr>
<tr class="memdesc:a844499bace6ae001446d71bee2877656 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa or FSK preamble length. Allowed values range from 6 to 65535 in LoRa mode or 0 to 65535 in FSK mode.  <br /></td></tr>
<tr class="separator:a844499bace6ae001446d71bee2877656 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b79dae55315cdf25e530db77eeb140f inherit pub_methods_class_s_x127x" id="r_a5b79dae55315cdf25e530db77eeb140f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5b79dae55315cdf25e530db77eeb140f">invertPreamble</a> (bool enable)</td></tr>
<tr class="memdesc:a5b79dae55315cdf25e530db77eeb140f inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert FSK preamble polarity. The default (non-inverted) is 0x55, the inverted is 0xAA.  <br /></td></tr>
<tr class="separator:a5b79dae55315cdf25e530db77eeb140f inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aa854a2668d70f4d3a374a49440362 inherit pub_methods_class_s_x127x" id="r_af6aa854a2668d70f4d3a374a49440362"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af6aa854a2668d70f4d3a374a49440362">getFrequencyError</a> (bool autoCorrect=false)</td></tr>
<tr class="memdesc:af6aa854a2668d70f4d3a374a49440362 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency error of the latest received packet.  <br /></td></tr>
<tr class="separator:af6aa854a2668d70f4d3a374a49440362 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094ba2d9268340b7aba99afe5da0544 inherit pub_methods_class_s_x127x" id="r_a5094ba2d9268340b7aba99afe5da0544"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5094ba2d9268340b7aba99afe5da0544">getAFCError</a> ()</td></tr>
<tr class="memdesc:a5094ba2d9268340b7aba99afe5da0544 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets current AFC error.  <br /></td></tr>
<tr class="separator:a5094ba2d9268340b7aba99afe5da0544 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b3f7464303085d34191dd334c1976f inherit pub_methods_class_s_x127x" id="r_a47b3f7464303085d34191dd334c1976f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a47b3f7464303085d34191dd334c1976f">getSNR</a> () override</td></tr>
<tr class="memdesc:a47b3f7464303085d34191dd334c1976f inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets signal-to-noise ratio of the latest received packet. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:a47b3f7464303085d34191dd334c1976f inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25b685de0859b799488bf7729350b6 inherit pub_methods_class_s_x127x" id="r_adc25b685de0859b799488bf7729350b6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adc25b685de0859b799488bf7729350b6">getDataRate</a> () const</td></tr>
<tr class="memdesc:adc25b685de0859b799488bf7729350b6 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data rate of the latest transmitted packet.  <br /></td></tr>
<tr class="separator:adc25b685de0859b799488bf7729350b6 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448ea8a6a6011a9cdddd4e09bd6c9679 inherit pub_methods_class_s_x127x" id="r_a448ea8a6a6011a9cdddd4e09bd6c9679"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a448ea8a6a6011a9cdddd4e09bd6c9679">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a448ea8a6a6011a9cdddd4e09bd6c9679 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK frequency deviation from carrier frequency. Allowed values depend on bit rate setting and must be lower than 200 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a448ea8a6a6011a9cdddd4e09bd6c9679 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc53b9f9d90647c5709cb974779cf53 inherit pub_methods_class_s_x127x" id="r_a2cc53b9f9d90647c5709cb974779cf53"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cc53b9f9d90647c5709cb974779cf53">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a2cc53b9f9d90647c5709cb974779cf53 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK receiver bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a2cc53b9f9d90647c5709cb974779cf53 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef inherit pub_methods_class_s_x127x" id="r_a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef">setAFCBandwidth</a> (float afcBw)</td></tr>
<tr class="memdesc:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK automatic frequency correction bandwidth. Allowed values range from 2.6 to 250 kHz. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a63e00b1ecf1b0dcb6d8a91fc9b8ea5ef inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e inherit pub_methods_class_s_x127x" id="r_a41f8cfcc2cdeb25a8e5a03f1ba4edd1e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a41f8cfcc2cdeb25a8e5a03f1ba4edd1e">setAFC</a> (bool isEnabled)</td></tr>
<tr class="memdesc:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables FSK automatic frequency correction(AFC)  <br /></td></tr>
<tr class="separator:a41f8cfcc2cdeb25a8e5a03f1ba4edd1e inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f67330124cefc07a462e77922453d0 inherit pub_methods_class_s_x127x" id="r_ab0f67330124cefc07a462e77922453d0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab0f67330124cefc07a462e77922453d0">setAFCAGCTrigger</a> (uint8_t trigger)</td></tr>
<tr class="memdesc:ab0f67330124cefc07a462e77922453d0 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls trigger of AFC and AGC.  <br /></td></tr>
<tr class="separator:ab0f67330124cefc07a462e77922453d0 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf400f33e17c1679c0b55cd70bef90b0 inherit pub_methods_class_s_x127x" id="r_aaf400f33e17c1679c0b55cd70bef90b0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aaf400f33e17c1679c0b55cd70bef90b0">setSyncWord</a> (uint8_t *syncWord, size_t len) override</td></tr>
<tr class="memdesc:aaf400f33e17c1679c0b55cd70bef90b0 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK sync word. Allowed sync words are up to 8 bytes long and can not contain null bytes. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:aaf400f33e17c1679c0b55cd70bef90b0 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99630d50672b43fc7162ba8f3293f95 inherit pub_methods_class_s_x127x" id="r_ab99630d50672b43fc7162ba8f3293f95"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab99630d50672b43fc7162ba8f3293f95">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:ab99630d50672b43fc7162ba8f3293f95 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK node address. Calling this method will enable address filtering. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:ab99630d50672b43fc7162ba8f3293f95 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc51ce6718153e4963128f25bb5aab40 inherit pub_methods_class_s_x127x" id="r_abc51ce6718153e4963128f25bb5aab40"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abc51ce6718153e4963128f25bb5aab40">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:abc51ce6718153e4963128f25bb5aab40 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK broadcast address. Calling this method will enable address filtering. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:abc51ce6718153e4963128f25bb5aab40 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6e9bbfd75f9cad26f9f72c34c4ada5 inherit pub_methods_class_s_x127x" id="r_afe6e9bbfd75f9cad26f9f72c34c4ada5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#afe6e9bbfd75f9cad26f9f72c34c4ada5">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:afe6e9bbfd75f9cad26f9f72c34c4ada5 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables FSK address filtering.  <br /></td></tr>
<tr class="separator:afe6e9bbfd75f9cad26f9f72c34c4ada5 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ef0af19a6b8954f956a3c3ad4286ee inherit pub_methods_class_s_x127x" id="r_a24ef0af19a6b8954f956a3c3ad4286ee"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a24ef0af19a6b8954f956a3c3ad4286ee">setOOK</a> (bool enableOOK)</td></tr>
<tr class="memdesc:a24ef0af19a6b8954f956a3c3ad4286ee inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables OOK modulation instead of FSK.  <br /></td></tr>
<tr class="separator:a24ef0af19a6b8954f956a3c3ad4286ee inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b93142202167270db109d18b743c744 inherit pub_methods_class_s_x127x" id="r_a8b93142202167270db109d18b743c744"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8b93142202167270db109d18b743c744">setOokThresholdType</a> (uint8_t type)</td></tr>
<tr class="memdesc:a8b93142202167270db109d18b743c744 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the type of threshold in the OOK data slicer.  <br /></td></tr>
<tr class="separator:a8b93142202167270db109d18b743c744 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f43d70b5f94e49e09b4c9f082f46d inherit pub_methods_class_s_x127x" id="r_aac2f43d70b5f94e49e09b4c9f082f46d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aac2f43d70b5f94e49e09b4c9f082f46d">setOokPeakThresholdDecrement</a> (uint8_t value)</td></tr>
<tr class="memdesc:aac2f43d70b5f94e49e09b4c9f082f46d inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Period of decrement of the RSSI threshold in the OOK demodulator.  <br /></td></tr>
<tr class="separator:aac2f43d70b5f94e49e09b4c9f082f46d inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ff4e4e0afaebed727648e1400be538 inherit pub_methods_class_s_x127x" id="r_a17ff4e4e0afaebed727648e1400be538"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a17ff4e4e0afaebed727648e1400be538">setOokFixedOrFloorThreshold</a> (uint8_t value)</td></tr>
<tr class="memdesc:a17ff4e4e0afaebed727648e1400be538 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed threshold for the Data Slicer in OOK mode or floor threshold for the Data Slicer in OOK when Peak mode is used.  <br /></td></tr>
<tr class="separator:a17ff4e4e0afaebed727648e1400be538 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ca43e6aad02815fa1507f0f0831c54 inherit pub_methods_class_s_x127x" id="r_a48ca43e6aad02815fa1507f0f0831c54"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a48ca43e6aad02815fa1507f0f0831c54">setOokPeakThresholdStep</a> (uint8_t value)</td></tr>
<tr class="memdesc:a48ca43e6aad02815fa1507f0f0831c54 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of each decrement of the RSSI threshold in the OOK demodulator.  <br /></td></tr>
<tr class="separator:a48ca43e6aad02815fa1507f0f0831c54 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1921e1d9fc1d888d2e73bb732e7db7aa inherit pub_methods_class_s_x127x" id="r_a1921e1d9fc1d888d2e73bb732e7db7aa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1921e1d9fc1d888d2e73bb732e7db7aa">enableBitSync</a> ()</td></tr>
<tr class="memdesc:a1921e1d9fc1d888d2e73bb732e7db7aa inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Bit synchronizer.  <br /></td></tr>
<tr class="separator:a1921e1d9fc1d888d2e73bb732e7db7aa inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8025b05b8f4f2f2abb4cd803b06e2ebd inherit pub_methods_class_s_x127x" id="r_a8025b05b8f4f2f2abb4cd803b06e2ebd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8025b05b8f4f2f2abb4cd803b06e2ebd">disableBitSync</a> ()</td></tr>
<tr class="memdesc:a8025b05b8f4f2f2abb4cd803b06e2ebd inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable Bit synchronizer (not allowed in Packet mode).  <br /></td></tr>
<tr class="separator:a8025b05b8f4f2f2abb4cd803b06e2ebd inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462fa74275e67c296328a01f361892d5 inherit pub_methods_class_s_x127x" id="r_a462fa74275e67c296328a01f361892d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a462fa74275e67c296328a01f361892d5">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a462fa74275e67c296328a01f361892d5 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <br /></td></tr>
<tr class="separator:a462fa74275e67c296328a01f361892d5 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46011b39460e27227a99cc93fdd1484b inherit pub_methods_class_s_x127x" id="r_a46011b39460e27227a99cc93fdd1484b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a46011b39460e27227a99cc93fdd1484b">getLoRaRxHeaderInfo</a> (uint8_t *cr, bool *hasCRC)</td></tr>
<tr class="memdesc:a46011b39460e27227a99cc93fdd1484b inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get LoRa header information from last received packet. Only valid in explicit header mode.  <br /></td></tr>
<tr class="separator:a46011b39460e27227a99cc93fdd1484b inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb42d9cd518e9f6408a40753c0be359 inherit pub_methods_class_s_x127x" id="r_a6fb42d9cd518e9f6408a40753c0be359"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a6fb42d9cd518e9f6408a40753c0be359">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:a6fb42d9cd518e9f6408a40753c0be359 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in FSK mode only.  <br /></td></tr>
<tr class="separator:a6fb42d9cd518e9f6408a40753c0be359 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d39296b40e7282ef44d8f376065e92c inherit pub_methods_class_s_x127x" id="r_a1d39296b40e7282ef44d8f376065e92c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a1d39296b40e7282ef44d8f376065e92c">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_SX127X_MAX_PACKET_LENGTH_FSK)</td></tr>
<tr class="memdesc:a1d39296b40e7282ef44d8f376065e92c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in FSK mode only.  <br /></td></tr>
<tr class="separator:a1d39296b40e7282ef44d8f376065e92c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ce24df39a164498977b0f532752f6 inherit pub_methods_class_s_x127x" id="r_a655ce24df39a164498977b0f532752f6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a655ce24df39a164498977b0f532752f6">getNumSymbols</a> (size_t len, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc)</td></tr>
<tr class="memdesc:a655ce24df39a164498977b0f532752f6 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from bytes to LoRa symbols.  <br /></td></tr>
<tr class="separator:a655ce24df39a164498977b0f532752f6 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7ecbc92c9d70f93211d21399d237d0 inherit pub_methods_class_s_x127x" id="r_a9e7ecbc92c9d70f93211d21399d237d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9e7ecbc92c9d70f93211d21399d237d0">getTimeOnAir</a> (size_t len) override</td></tr>
<tr class="memdesc:a9e7ecbc92c9d70f93211d21399d237d0 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <br /></td></tr>
<tr class="separator:a9e7ecbc92c9d70f93211d21399d237d0 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cb7d326f6d7effb6301d730a24def1 inherit pub_methods_class_s_x127x" id="r_a99cb7d326f6d7effb6301d730a24def1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a99cb7d326f6d7effb6301d730a24def1">calculateTimeOnAir</a> (ModemType_t modem, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc, size_t len) override</td></tr>
<tr class="memdesc:a99cb7d326f6d7effb6301d730a24def1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size.  <br /></td></tr>
<tr class="separator:a99cb7d326f6d7effb6301d730a24def1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc4021380dc557114625dc51262cf90 inherit pub_methods_class_s_x127x" id="r_adbc4021380dc557114625dc51262cf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#adbc4021380dc557114625dc51262cf90">calculateRxTimeout</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeoutUs) override</td></tr>
<tr class="memdesc:adbc4021380dc557114625dc51262cf90 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time)  <br /></td></tr>
<tr class="separator:adbc4021380dc557114625dc51262cf90 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22de05835dda9ed287ec48f60ef91f55 inherit pub_methods_class_s_x127x" id="r_a22de05835dda9ed287ec48f60ef91f55"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a22de05835dda9ed287ec48f60ef91f55">getIrqFlags</a> () override</td></tr>
<tr class="memdesc:a22de05835dda9ed287ec48f60ef91f55 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read currently active IRQ flags.  <br /></td></tr>
<tr class="separator:a22de05835dda9ed287ec48f60ef91f55 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae42b94ab2ecf729f29f101222e97666 inherit pub_methods_class_s_x127x" id="r_aae42b94ab2ecf729f29f101222e97666"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aae42b94ab2ecf729f29f101222e97666">setIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:aae42b94ab2ecf729f29f101222e97666 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). NOTE: Unlike other modules that support IRQ abstraction (<a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, <a class="el" href="class_l_r11x0.html" title="Base class for LR11x0 series. All derived classes for LR11x0 (e.g. LR1110 or LR1120) inherit from thi...">LR11x0</a>, etc.), <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> cannot configure multiple IRQs to signal using the same DIOx pin. This method tries to configure IRQs in a "best effort" approach, and will skip conflicting flags. RADIOLIB_ERR_INVALID_IRQ will be returned in this case.  <br /></td></tr>
<tr class="separator:aae42b94ab2ecf729f29f101222e97666 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3eae13a7f0558c1bc881abebd958242 inherit pub_methods_class_s_x127x" id="r_aa3eae13a7f0558c1bc881abebd958242"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aa3eae13a7f0558c1bc881abebd958242">clearIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:aa3eae13a7f0558c1bc881abebd958242 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:aa3eae13a7f0558c1bc881abebd958242 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab531ad461b250a060e92d9c744e79070 inherit pub_methods_class_s_x127x" id="r_ab531ad461b250a060e92d9c744e79070"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab531ad461b250a060e92d9c744e79070">setCrcFiltering</a> (bool enable=true)</td></tr>
<tr class="memdesc:ab531ad461b250a060e92d9c744e79070 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CRC filtering and generation.  <br /></td></tr>
<tr class="separator:ab531ad461b250a060e92d9c744e79070 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3955f85f456edae772a51025a19029b inherit pub_methods_class_s_x127x" id="r_ad3955f85f456edae772a51025a19029b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ad3955f85f456edae772a51025a19029b">setRSSIConfig</a> (uint8_t smoothingSamples, int8_t offset=0)</td></tr>
<tr class="memdesc:ad3955f85f456edae772a51025a19029b inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets RSSI measurement configuration in FSK mode.  <br /></td></tr>
<tr class="separator:ad3955f85f456edae772a51025a19029b inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2d455012bd28d304589c8164390eb inherit pub_methods_class_s_x127x" id="r_abad2d455012bd28d304589c8164390eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#abad2d455012bd28d304589c8164390eb">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:abad2d455012bd28d304589c8164390eb inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Only available in FSK mode. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER and RADIOLIB_ENCODING_WHITENING.  <br /></td></tr>
<tr class="separator:abad2d455012bd28d304589c8164390eb inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d2ddb517e474a699b4539653b3754d inherit pub_methods_class_s_x127x" id="r_ac5d2ddb517e474a699b4539653b3754d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ac5d2ddb517e474a699b4539653b3754d">getIRQFlags</a> ()</td></tr>
<tr class="memdesc:ac5d2ddb517e474a699b4539653b3754d inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads currently active IRQ flags, can be used to check which event caused an interrupt. In LoRa mode, this is the content of SX127X_REG_IRQ_FLAGS register. In FSK mode, this is the contents of SX127X_REG_IRQ_FLAGS_2 (MSB) and SX127X_REG_IRQ_FLAGS_1 (LSB) registers.  <br /></td></tr>
<tr class="separator:ac5d2ddb517e474a699b4539653b3754d inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf6a5bd8f3257f98ee4f250cbdf8bdc inherit pub_methods_class_s_x127x" id="r_a2cf6a5bd8f3257f98ee4f250cbdf8bdc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a2cf6a5bd8f3257f98ee4f250cbdf8bdc">getModemStatus</a> ()</td></tr>
<tr class="memdesc:a2cf6a5bd8f3257f98ee4f250cbdf8bdc inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads modem status. Only available in LoRa mode.  <br /></td></tr>
<tr class="separator:a2cf6a5bd8f3257f98ee4f250cbdf8bdc inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bc32a555675879ad9e2a9e399dc6c1 inherit pub_methods_class_s_x127x" id="r_a95bc32a555675879ad9e2a9e399dc6c1"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a95bc32a555675879ad9e2a9e399dc6c1">getTempRaw</a> ()</td></tr>
<tr class="memdesc:a95bc32a555675879ad9e2a9e399dc6c1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads uncalibrated temperature value. This function will change operating mode and should not be called during Tx, Rx or CAD.  <br /></td></tr>
<tr class="separator:a95bc32a555675879ad9e2a9e399dc6c1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca9edcae05060cce3ff7ee58faeb4e2 inherit pub_methods_class_s_x127x" id="r_a8ca9edcae05060cce3ff7ee58faeb4e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a8ca9edcae05060cce3ff7ee58faeb4e2">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a8ca9edcae05060cce3ff7ee58faeb4e2 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.    <br /></td></tr>
<tr class="separator:a8ca9edcae05060cce3ff7ee58faeb4e2 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9625a5246a45112267ce441ac2de254 inherit pub_methods_class_s_x127x" id="r_ab9625a5246a45112267ce441ac2de254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ab9625a5246a45112267ce441ac2de254">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:ab9625a5246a45112267ce441ac2de254 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.    <br /></td></tr>
<tr class="separator:ab9625a5246a45112267ce441ac2de254 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9877550ed7881be06d00ea190f230fb9 inherit pub_methods_class_s_x127x" id="r_a9877550ed7881be06d00ea190f230fb9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9877550ed7881be06d00ea190f230fb9">randomByte</a> () override</td></tr>
<tr class="memdesc:a9877550ed7881be06d00ea190f230fb9 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <br /></td></tr>
<tr class="separator:a9877550ed7881be06d00ea190f230fb9 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5324d7d854e7a2f6768221d4f362cd inherit pub_methods_class_s_x127x" id="r_aee5324d7d854e7a2f6768221d4f362cd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#aee5324d7d854e7a2f6768221d4f362cd">getChipVersion</a> ()</td></tr>
<tr class="memdesc:aee5324d7d854e7a2f6768221d4f362cd inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return SX1278_CHIP_VERSION (0x12) or SX1272_CHIP_VERSION (0x22) if <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> is connected and working.  <br /></td></tr>
<tr class="separator:aee5324d7d854e7a2f6768221d4f362cd inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363a436978ba990e1bf7d73f648ad7e9 inherit pub_methods_class_s_x127x" id="r_a363a436978ba990e1bf7d73f648ad7e9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a363a436978ba990e1bf7d73f648ad7e9">invertIQ</a> (bool enable) override</td></tr>
<tr class="memdesc:a363a436978ba990e1bf7d73f648ad7e9 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable inversion of the I and Q signals.  <br /></td></tr>
<tr class="separator:a363a436978ba990e1bf7d73f648ad7e9 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a9004cc05ff8aba2e9610db31109d inherit pub_methods_class_s_x127x" id="r_a333a9004cc05ff8aba2e9610db31109d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a333a9004cc05ff8aba2e9610db31109d">getModem</a> (ModemType_t *modem) override</td></tr>
<tr class="memdesc:a333a9004cc05ff8aba2e9610db31109d inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modem currently in use by the radio.  <br /></td></tr>
<tr class="separator:a333a9004cc05ff8aba2e9610db31109d inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd7fb49a3b27707aff6636ff6dee550 inherit pub_methods_class_s_x127x" id="r_a3bd7fb49a3b27707aff6636ff6dee550"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3bd7fb49a3b27707aff6636ff6dee550">stageMode</a> (RadioModeType_t mode, <a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *cfg) override</td></tr>
<tr class="memdesc:a3bd7fb49a3b27707aff6636ff6dee550 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage mode of the radio to be launched later using launchMode.    <br /></td></tr>
<tr class="separator:a3bd7fb49a3b27707aff6636ff6dee550 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538b43314081e8b3eda95e0011d1e5b9 inherit pub_methods_class_s_x127x" id="r_a538b43314081e8b3eda95e0011d1e5b9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a538b43314081e8b3eda95e0011d1e5b9">launchMode</a> () override</td></tr>
<tr class="memdesc:a538b43314081e8b3eda95e0011d1e5b9 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch previously staged mode.    <br /></td></tr>
<tr class="separator:a538b43314081e8b3eda95e0011d1e5b9 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b99d1bc67ac2c81eeb11dd6793a8c5 inherit pub_methods_class_s_x127x" id="r_ae4b99d1bc67ac2c81eeb11dd6793a8c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae4b99d1bc67ac2c81eeb11dd6793a8c5">setDirectAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:ae4b99d1bc67ac2c81eeb11dd6793a8c5 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is received in direct mode.  <br /></td></tr>
<tr class="separator:ae4b99d1bc67ac2c81eeb11dd6793a8c5 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e149fac59b3accbc9550bf605d6bbf0 inherit pub_methods_class_s_x127x" id="r_a0e149fac59b3accbc9550bf605d6bbf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a0e149fac59b3accbc9550bf605d6bbf0">readBit</a> (uint32_t pin) override</td></tr>
<tr class="memdesc:a0e149fac59b3accbc9550bf605d6bbf0 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <br /></td></tr>
<tr class="separator:a0e149fac59b3accbc9550bf605d6bbf0 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f04a7e883057908df18f06c7f74c7e1 inherit pub_methods_class_s_x127x" id="r_a7f04a7e883057908df18f06c7f74c7e1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7f04a7e883057908df18f06c7f74c7e1">setFHSSHoppingPeriod</a> (uint8_t freqHoppingPeriod)</td></tr>
<tr class="memdesc:a7f04a7e883057908df18f06c7f74c7e1 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the hopping period and enables FHSS.  <br /></td></tr>
<tr class="separator:a7f04a7e883057908df18f06c7f74c7e1 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7600b8b0aac4d8a5e962d631145b617 inherit pub_methods_class_s_x127x" id="r_ad7600b8b0aac4d8a5e962d631145b617"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ad7600b8b0aac4d8a5e962d631145b617">getFHSSHoppingPeriod</a> (void)</td></tr>
<tr class="memdesc:ad7600b8b0aac4d8a5e962d631145b617 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets FHSS hopping period.  <br /></td></tr>
<tr class="separator:ad7600b8b0aac4d8a5e962d631145b617 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56340d1bdc69b3efc64636be39445a9c inherit pub_methods_class_s_x127x" id="r_a56340d1bdc69b3efc64636be39445a9c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a56340d1bdc69b3efc64636be39445a9c">getFHSSChannel</a> (void)</td></tr>
<tr class="memdesc:a56340d1bdc69b3efc64636be39445a9c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the FHSS channel in use.  <br /></td></tr>
<tr class="separator:a56340d1bdc69b3efc64636be39445a9c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41089d9e5b45217d3e31ac22b5326b66 inherit pub_methods_class_s_x127x" id="r_a41089d9e5b45217d3e31ac22b5326b66"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearFHSSInt</b> (void)</td></tr>
<tr class="memdesc:a41089d9e5b45217d3e31ac22b5326b66 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the FHSS interrupt. <br /></td></tr>
<tr class="separator:a41089d9e5b45217d3e31ac22b5326b66 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d373bc93e99790912cebe8d5ae6403 inherit pub_methods_class_s_x127x" id="r_af7d373bc93e99790912cebe8d5ae6403"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af7d373bc93e99790912cebe8d5ae6403">setDIOMapping</a> (uint32_t pin, uint32_t value) override</td></tr>
<tr class="memdesc:af7d373bc93e99790912cebe8d5ae6403 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <br /></td></tr>
<tr class="separator:af7d373bc93e99790912cebe8d5ae6403 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b85344084b800966a46ace59dcb5277 inherit pub_methods_class_s_x127x" id="r_a7b85344084b800966a46ace59dcb5277"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a7b85344084b800966a46ace59dcb5277">setDIOPreambleDetect</a> (bool usePreambleDetect)</td></tr>
<tr class="memdesc:a7b85344084b800966a46ace59dcb5277 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO mapping to use RSSI or Preamble Detect for pins that support it.  <br /></td></tr>
<tr class="separator:a7b85344084b800966a46ace59dcb5277 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094d0f471aaa428167816d1ac30bb76 inherit pub_methods_class_s_x127x" id="r_a5094d0f471aaa428167816d1ac30bb76"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a5094d0f471aaa428167816d1ac30bb76">setRSSIThreshold</a> (float dbm)</td></tr>
<tr class="memdesc:a5094d0f471aaa428167816d1ac30bb76 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RSSI value above which the RSSI interrupt is signaled.  <br /></td></tr>
<tr class="separator:a5094d0f471aaa428167816d1ac30bb76 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9aa18e13e8390ec437e249e1d2472 inherit pub_methods_class_s_x127x" id="r_a9ca9aa18e13e8390ec437e249e1d2472"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a9ca9aa18e13e8390ec437e249e1d2472">setLowBatteryThreshold</a> (int8_t level, uint32_t pin=RADIOLIB_NC)</td></tr>
<tr class="memdesc:a9ca9aa18e13e8390ec437e249e1d2472 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set low battery indicator threshold.  <br /></td></tr>
<tr class="separator:a9ca9aa18e13e8390ec437e249e1d2472 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_s_x127x" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_s_x127x" id="r_ada508497ee2e70170da3afe078e2fe0e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ada508497ee2e70170da3afe078e2fe0e">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ada508497ee2e70170da3afe078e2fe0e inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_s_x127x" id="r_ae608fabef91defa1e33e6a6787c68ce8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae608fabef91defa1e33e6a6787c68ce8">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0)</td></tr>
<tr class="memdesc:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae608fabef91defa1e33e6a6787c68ce8 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_s_x127x" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_s_x127x" id="r_af79757dbbd62e080c1bad2e608ab940c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#af79757dbbd62e080c1bad2e608ab940c">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <br /></td></tr>
<tr class="separator:af79757dbbd62e080c1bad2e608ab940c inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18664ad615c5507ff1690baaca90b094 inherit pub_methods_class_s_x127x" id="r_a18664ad615c5507ff1690baaca90b094"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a18664ad615c5507ff1690baaca90b094">startReceive</a> ()</td></tr>
<tr class="memdesc:a18664ad615c5507ff1690baaca90b094 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets module to received mode using its default configuration.  <br /></td></tr>
<tr class="separator:a18664ad615c5507ff1690baaca90b094 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93500dfbcfd39837e04c0f3eaa40d97 inherit pub_methods_class_s_x127x" id="r_ae93500dfbcfd39837e04c0f3eaa40d97"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#ae93500dfbcfd39837e04c0f3eaa40d97">startReceive</a> (uint32_t timeout, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqFlags=RADIOLIB_IRQ_RX_DEFAULT_FLAGS, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqMask=RADIOLIB_IRQ_RX_DEFAULT_MASK, size_t len=0)</td></tr>
<tr class="memdesc:ae93500dfbcfd39837e04c0f3eaa40d97 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae93500dfbcfd39837e04c0f3eaa40d97 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300 inherit pub_methods_class_s_x127x" id="r_a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x127x.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300 inherit pub_methods_class_s_x127x"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300 inherit pub_methods_class_s_x127x"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer" id="r_afc972a84153977d6ccd9e116b6181ad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalLayer</b> ()</td></tr>
<tr class="memdesc:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer" id="r_a7af88f9f75c9778c29002c2b8238a239"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PhysicalLayer</b> ()=default</td></tr>
<tr class="memdesc:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer" id="r_ae602ebd46d60da8670c9f353cef695d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae602ebd46d60da8670c9f353cef695d9">getIrqMapped</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from radio-agnostic IRQ flags to radio-specific flags.  <br /></td></tr>
<tr class="separator:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer" id="r_a2c7dd4704e3df353265010710bd26e83"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a2c7dd4704e3df353265010710bd26e83">checkIrq</a> (RadioLibIrqType_t irq)</td></tr>
<tr class="memdesc:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a specific IRQ bit is set (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer" id="r_a8564f9834a0247e93e7620c23559ceb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8564f9834a0247e93e7620c23559ceb8">setIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on specific IRQ bit(s) (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer" id="r_af9a7e739e39705a72ffa8b63ec09bb15"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af9a7e739e39705a72ffa8b63ec09bb15">clearIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer" id="r_a82a52062d9259c2c546d7bf8072b7a72"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a82a52062d9259c2c546d7bf8072b7a72">startChannelScan</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer" id="r_af788cf83ceb0222cd0fa4a1323b9041b"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af788cf83ceb0222cd0fa4a1323b9041b">scanChannel</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer" id="r_acd9171bd71aa80fb86113b612c42de53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer" id="r_a76113e10481743094a1cd0280692b0a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer" id="r_a88a10657bd2215a11a2331f937414b55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer" id="r_a8e378fe136a498ea485a9c10f5e15aab"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer" id="r_ab57182d32646861ef0d865e2740d6b26"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer" id="r_a429796eb2e7ea86781a2e8ca42af43f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropSync</b> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer" id="r_a4d5b30493c8d7fcfb784e128362d596c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer" id="r_aa949616080a463a82bb6ad5075a9e16e"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>freqStep</b></td></tr>
<tr class="memdesc:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency step of the synthesizer in Hz. <br /></td></tr>
<tr class="separator:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer" id="r_a1c04f8fba5eef96e59972004e8abc623"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxPacketLength</b></td></tr>
<tr class="memdesc:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of packet that can be received by the module. <br /></td></tr>
<tr class="separator:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Derived class for SX1278 modules. Also used as base class for <a class="el" href="class_s_x1276.html" title="Derived class for SX1276 modules. Overrides some methods from SX1278 due to different parameter range...">SX1276</a>, <a class="el" href="class_s_x1277.html" title="Derived class for SX1277 modules. Overrides some methods from SX1278 due to different parameter range...">SX1277</a>, <a class="el" href="class_s_x1279.html" title="Derived class for SX1279 modules. Overrides some methods from SX1278 due to different parameter range...">SX1279</a>, <a class="el" href="class_r_f_m95.html" title="Only exists as alias for SX1276, since there seems to be no difference between RFM95 and SX1276 modul...">RFM95</a> and <a class="el" href="class_r_f_m96.html" title="Only exists as alias for SX1276, since there seems to be no difference between RFM96 and SX1276 modul...">RFM96</a>. All of these modules use the same basic hardware and only differ in parameter ranges (and names). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a00ebd3e60a66056940b241b13da0c68e" name="a00ebd3e60a66056940b241b13da0c68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ebd3e60a66056940b241b13da0c68e">&#9670;&#160;</a></span>SX1278()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SX1278::SX1278 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. Called from Arduino sketch when creating new LoRa instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the LoRa chip. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae02adcde8c2978c0d1b157729dd5df1e" name="ae02adcde8c2978c0d1b157729dd5df1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02adcde8c2978c0d1b157729dd5df1e">&#9670;&#160;</a></span>autoLDRO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::autoLDRO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method, LDRO will be enabled automatically when symbol length exceeds 16 ms. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a867a336ae900f4a221d42b4c807122cf" name="a867a336ae900f4a221d42b4c807122cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867a336ae900f4a221d42b4c807122cf">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em> = <code>125.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em> = <code>RADIOLIB_SX127X_SYNC_WORD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>LoRa modem initialization method. Must be called at least once from Arduino sketch to initialize the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Allowed values range from 137.0 MHz to 525.0 MHz. </td></tr>
    <tr><td class="paramname">bw</td><td>LoRa link bandwidth in kHz. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125, 250 and 500 kHz. </td></tr>
    <tr><td class="paramname">sf</td><td>LoRa link spreading factor. Allowed values range from 6 to 12. </td></tr>
    <tr><td class="paramname">cr</td><td>LoRa link coding rate denominator. Allowed values range from 4 to 8. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC. </td></tr>
    <tr><td class="paramname">syncWord</td><td>LoRa sync word. Can be used to distinguish different networks. Note that value 0x34 is reserved for LoRaWAN networks. </td></tr>
    <tr><td class="paramname">power</td><td>Transmission output power in dBm. Allowed values range from 2 to 17 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of LoRa transmission preamble in symbols. The actual preamble length is 4.25 symbols longer than the set number. Allowed values range from 6 to 65535. </td></tr>
    <tr><td class="paramname">gain</td><td>Gain of receiver LNA (low-noise amplifier). Can be set to any integer in range 1 to 6 where 1 is the highest gain. Set to 0 to enable automatic gain control (recommended). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_s_x1276.html#a729cfac96ccd76fa96cfae93d17a2d92">SX1276</a>, <a class="el" href="class_s_x1277.html#af2327920562514632256895602c1f68b">SX1277</a>, and <a class="el" href="class_s_x1279.html#ace52854eb22ac331e887eb320d2cd873">SX1279</a>.</p>

</div>
</div>
<a id="a86464af008b71d12948690b780280e7d" name="a86464af008b71d12948690b780280e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86464af008b71d12948690b780280e7d">&#9670;&#160;</a></span>beginFSK()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::beginFSK </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em> = <code>4.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em> = <code>125.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>FSK modem initialization method. Must be called at least once from Arduino sketch to initialize the module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Allowed values range from 137.0 MHz to 525.0 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>Bit rate of the FSK transmission in kbps (kilobits per second). Allowed values range from 1.2 to 300.0 kbps. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation of the FSK transmission in kHz. Allowed values range from 0.6 to 200.0 kHz. Note that the allowed range changes based on bit rate setting, so that the condition FreqDev + BitRate/2 &lt;= 250 kHz is always met. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Allowed values are 2.6, 3.1, 3.9, 5.2, 6.3, 7.8, 10.4, 12.5, 15.6, 20.8, 25, 31.3, 41.7, 50, 62.5, 83.3, 100, 125, 166.7, 200 and 250 kHz. </td></tr>
    <tr><td class="paramname">power</td><td>Transmission output power in dBm. Allowed values range from 2 to 17 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Length of FSK preamble in bits. </td></tr>
    <tr><td class="paramname">enableOOK</td><td>Use OOK modulation instead of FSK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_s_x1276.html#aad2a12f233378d75d28ab9a2307331a8">SX1276</a>, <a class="el" href="class_s_x1277.html#ab04763764dceef0543197aa0316d0030">SX1277</a>, and <a class="el" href="class_s_x1279.html#a2a0634c2a60c21045388377a2c8c2617">SX1279</a>.</p>

</div>
</div>
<a id="a6f9d9f371a3a53a0be25cc05284ade47" name="a6f9d9f371a3a53a0be25cc05284ade47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9d9f371a3a53a0be25cc05284ade47">&#9670;&#160;</a></span>checkDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::checkDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em> = <code>RADIOLIB_MODEM_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the data rate can be configured by this module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. </td></tr>
    <tr><td class="paramname">modem</td><td>The modem corresponding to the requested datarate (FSK or LoRa). Defaults to currently active modem if not supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a9c5c902d9f8ffe9866b7f178b14d34f6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aac7b585c4a616a1cd6f89a8b46a7d9f8" name="aac7b585c4a616a1cd6f89a8b46a7d9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7b585c4a616a1cd6f89a8b46a7d9f8">&#9670;&#160;</a></span>checkOutputPower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::checkOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>clipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power in dBm, assumes PA_BOOST pin. </td></tr>
    <tr><td class="paramname">clipped</td><td>Clipped output power value to what is possible within the module's range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ac6146c2a3d0a35662312165325fd97f8" name="ac6146c2a3d0a35662312165325fd97f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6146c2a3d0a35662312165325fd97f8">&#9670;&#160;</a></span>checkOutputPower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::checkOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>clipped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if output power is configurable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power in dBm. </td></tr>
    <tr><td class="paramname">clipped</td><td>Clipped output power value to what is possible within the module's range. </td></tr>
    <tr><td class="paramname">useRfo</td><td>Whether to use the RFO (true) or the PA_BOOST (false) pin for the RF output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7c7717f09820a8e9a93621b0a00713f1" name="a7c7717f09820a8e9a93621b0a00713f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7717f09820a8e9a93621b0a00713f1">&#9670;&#160;</a></span>explicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::explicitHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set explicit header mode for future reception/transmission. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6d6398c4d4fde302d6d4752708bce856" name="a6d6398c4d4fde302d6d4752708bce856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6398c4d4fde302d6d4752708bce856">&#9670;&#160;</a></span>forceLDRO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::forceLDRO </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces LoRa low data rate optimization. Only available in LoRa mode. After calling this method, LDRO will always be set to the provided value, regardless of symbol length. To re-enable automatic LDRO configuration, call <a class="el" href="class_s_x1278.html#ae02adcde8c2978c0d1b157729dd5df1e" title="Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method,...">SX1278::autoLDRO()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Force LDRO to be always enabled (true) or disabled (false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a0fcdc2962d1cf3410be208154d98ae4b" name="a0fcdc2962d1cf3410be208154d98ae4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fcdc2962d1cf3410be208154d98ae4b">&#9670;&#160;</a></span>getRSSI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float SX1278::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets recorded signal strength indicator. Overload with packet mode enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="section return"><dt>Returns</dt><dd>RSSI value in dBm. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab17357254073baeb7490c98faf10d991" name="ab17357254073baeb7490c98faf10d991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17357254073baeb7490c98faf10d991">&#9670;&#160;</a></span>getRSSI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX1278::getRSSI </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipReceive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets recorded signal strength indicator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>Whether to read last packet RSSI, or the current value. LoRa mode only, ignored for FSK. </td></tr>
    <tr><td class="paramname">skipReceive</td><td>Set to true to skip putting radio in receive mode for the RSSI measurement in FSK/OOK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RSSI value in dBm. </dd></dl>

</div>
</div>
<a id="a47f5ac7dd6587b86c5f2c2b16336612e" name="a47f5ac7dd6587b86c5f2c2b16336612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f5ac7dd6587b86c5f2c2b16336612e">&#9670;&#160;</a></span>implicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::implicitHeader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set implicit header mode for future reception/transmission. Required for spreading factor 6. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6d60902ac59b653a9eb83e82a932f7ad" name="a6d60902ac59b653a9eb83e82a932f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d60902ac59b653a9eb83e82a932f7ad">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX1278::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset method. Will reset the chip to the default state using RST pin. </p>

<p>Reimplemented from <a class="el" href="class_s_x127x.html#a15f510359be44fd633037810587f1ea2">SX127x</a>.</p>

</div>
</div>
<a id="a46c27ed1ebaae4e3ed8afe3ae6941dd6" name="a46c27ed1ebaae4e3ed8afe3ae6941dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c27ed1ebaae4e3ed8afe3ae6941dd6">&#9670;&#160;</a></span>setBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa link bandwidth. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125, 250 and 500 kHz. Only available in LoRa mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa link bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afd6df07fc4972cc656f05670e6802f67" name="afd6df07fc4972cc656f05670e6802f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6df07fc4972cc656f05670e6802f67">&#9670;&#160;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK bit rate. Allowed values range from 0.5 to 300 kbps. Only available in FSK mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>Bit rate to be set (in kbps). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a834f26a0bd3fc8a03fa7e68aa4daf9e1" name="a834f26a0bd3fc8a03fa7e68aa4daf9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834f26a0bd3fc8a03fa7e68aa4daf9e1">&#9670;&#160;</a></span>setCodingRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setCodingRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa link coding rate denominator. Allowed values range from 4 to 8. Only available in LoRa mode. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>LoRa link coding rate denominator to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac0be7586b8e40355bbd29d78ae9941d1" name="ac0be7586b8e40355bbd29d78ae9941d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0be7586b8e40355bbd29d78ae9941d1">&#9670;&#160;</a></span>setCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setCRC </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables CRC check of received packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Enable (true) or disable (false) CRC. </td></tr>
    <tr><td class="paramname">mode</td><td>Set CRC mode to SX127X_CRC_WHITENING_TYPE_CCITT for CCITT, polynomial X16 + X12 + X5 + 1 (false) or SX127X_CRC_WHITENING_TYPE_IBM for IBM, polynomial X16 + X15 + X2 + 1 (true). Only valid in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac68af98ab018cfdb70edde1051dcb1dc" name="ac68af98ab018cfdb70edde1051dcb1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68af98ab018cfdb70edde1051dcb1dc">&#9670;&#160;</a></span>setDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em> = <code>RADIOLIB_MODEM_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set data rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. </td></tr>
    <tr><td class="paramname">modem</td><td>The modem corresponding to the requested datarate (FSK or LoRa). Defaults to currently active modem if not supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ac5f1e0c24d8bf878f2c9fe729b6e1610">PhysicalLayer</a>.</p>

</div>
</div>
<a id="afb740a4925b64d83d5edca10d93f0563" name="afb740a4925b64d83d5edca10d93f0563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb740a4925b64d83d5edca10d93f0563">&#9670;&#160;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets Gaussian filter bandwidth-time product that will be used for data shaping. Only available in FSK mode with FSK modulation. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Gaussian shaping bandwidth-time product that will be used for data shaping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1ccc4d5062f739d534ab22562c7efca4" name="a1ccc4d5062f739d534ab22562c7efca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccc4d5062f739d534ab22562c7efca4">&#9670;&#160;</a></span>setDataShapingOOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setDataShapingOOK </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets filter cutoff frequency that will be used for data shaping. Allowed values are 1 for frequency equal to bit rate and 2 for frequency equal to 2x bit rate. Set to 0 to disable data shaping. Only available in FSK mode with OOK modulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Cutoff frequency that will be used for data shaping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adb4d95d3b2798cf8ea94890ae71dcc59" name="adb4d95d3b2798cf8ea94890ae71dcc59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4d95d3b2798cf8ea94890ae71dcc59">&#9670;&#160;</a></span>setFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets carrier frequency. Allowed values range from 137.0 MHz to 525.0 MHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency to be set in MHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">PhysicalLayer</a>.</p>

<p>Reimplemented in <a class="el" href="class_s_x1279.html#ab60691d073ca75ef09dab7a8f28fb7fb">SX1279</a>.</p>

</div>
</div>
<a id="aa57b713988cfa224a6db2ff325052931" name="aa57b713988cfa224a6db2ff325052931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57b713988cfa224a6db2ff325052931">&#9670;&#160;</a></span>setGain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setGain </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets gain of receiver LNA (low-noise amplifier). Can be set to any integer in range 1 to 6 where 1 is the highest gain. Set to 0 to enable automatic gain control (recommended). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>Gain of receiver LNA (low-noise amplifier) to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a609dd3faf2036e8c2d046fd191e0137d" name="a609dd3faf2036e8c2d046fd191e0137d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609dd3faf2036e8c2d046fd191e0137d">&#9670;&#160;</a></span>setModem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setModem </td>
          <td>(</td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modem</td><td>Modem type to set - FSK or LoRa. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a77415bf4ed34be18c92c0cf4b2de7149">PhysicalLayer</a>.</p>

<p>Reimplemented in <a class="el" href="class_s_x1279.html#aea8bd74e7c5d7b97d4fe4a8182680d5c">SX1279</a>.</p>

</div>
</div>
<a id="a69abc18e7fa0055e6b80024e8cde7db4" name="a69abc18e7fa0055e6b80024e8cde7db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69abc18e7fa0055e6b80024e8cde7db4">&#9670;&#160;</a></span>setOutputPower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission output power. Allowed values range from -4 to 15 dBm (RFO pin) or +2 to +17 dBm (PA_BOOST pin). High power +20 dBm operation is also supported, on the PA_BOOST pin. Defaults to PA_BOOST. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Transmission output power in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab206a23ac93f5687ba5f6741fa690130" name="ab206a23ac93f5687ba5f6741fa690130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab206a23ac93f5687ba5f6741fa690130">&#9670;&#160;</a></span>setOutputPower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceRfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets transmission output power. Allowed values range from -4 to 15 dBm (RFO pin) or +2 to +17 dBm (PA_BOOST pin). High power +20 dBm operation is also supported, on the PA_BOOST pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Transmission output power in dBm. </td></tr>
    <tr><td class="paramname">forceRfo</td><td>Whether to force using the RFO pin for the RF output (true) or to leave the selection up to user (false) based on power output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af70c22fe38bc3b944070ccbc083fed08" name="af70c22fe38bc3b944070ccbc083fed08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70c22fe38bc3b944070ccbc083fed08">&#9670;&#160;</a></span>setSpreadingFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX1278::setSpreadingFactor </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets LoRa link spreading factor. Allowed values range from 6 to 12. Only available in LoRa mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>LoRa link spreading factor to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented in <a class="el" href="class_s_x1277.html#af083270ea5fbad2acb789c7ce8e27322">SX1277</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/SX127x/<a class="el" href="_s_x1278_8h_source.html">SX1278.h</a></li>
<li>src/modules/SX127x/<b>SX1278.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_x1278.html">SX1278</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
