<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: LR2021 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_l_r2021.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_l_r2021-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">LR2021 Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for LR2021:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_l_r2021.png" usemap="#LR2021_map" alt=""/>
  <map id="LR2021_map" name="LR2021_map">
<area href="class_l_rxxxx.html" alt="LRxxxx" shape="rect" coords="0,56,93,80"/>
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="0,0,93,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7cc93cb3b185f23008a5c4c250110c2e" id="r_a7cc93cb3b185f23008a5c4c250110c2e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2e">OpMode_t</a> { <br />
&#160;&#160;<a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2ea213ca32e2b01ccc39a8b5ed871e14ff8">MODE_END_OF_TABLE</a> = Module::MODE_END_OF_TABLE
, <a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2ea776ad40a0d311b01990a737549a6360e">MODE_STBY</a> = Module::MODE_IDLE
, <a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2ea2a3dc8a60e80b39cf5c218e0454532c5">MODE_RX</a> = Module::MODE_RX
, <a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2eae9bb7b727539e92dc623c12f0b120216">MODE_TX</a> = Module::MODE_TX
, <br />
&#160;&#160;<a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2ea55966ada4de25514944483e2203647e8">MODE_RX_HF</a>
, <a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2eab7ce6e88852aea8f8401bc109744b2bf">MODE_TX_HF</a>
<br />
 }</td></tr>
<tr class="memdesc:a7cc93cb3b185f23008a5c4c250110c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom operation modes for <a class="el" href="class_l_r2021.html">LR2021</a>. Needed because <a class="el" href="class_l_r2021.html">LR2021</a> has several modems (sub-GHz, 2.4 GHz etc.) in one package.  <a href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2e">More...</a><br /></td></tr>
<tr class="separator:a7cc93cb3b185f23008a5c4c250110c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0e61b0b25a43fb572e1bcd34fc02dda2" id="r_a0e61b0b25a43fb572e1bcd34fc02dda2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0e61b0b25a43fb572e1bcd34fc02dda2">LR2021</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:a0e61b0b25a43fb572e1bcd34fc02dda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a0e61b0b25a43fb572e1bcd34fc02dda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b13119ff624af7a283ea9a0a9386b6b" id="r_a1b13119ff624af7a283ea9a0a9386b6b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a1b13119ff624af7a283ea9a0a9386b6b">begin</a> (float freq=434.0, float bw=125.0, uint8_t sf=9, uint8_t cr=7, uint8_t syncWord=RADIOLIB_LR2021_LORA_SYNC_WORD_PRIVATE, int8_t power=10, uint16_t preambleLength=8, float tcxoVoltage=1.6)</td></tr>
<tr class="memdesc:a1b13119ff624af7a283ea9a0a9386b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for LoRa modem.  <br /></td></tr>
<tr class="separator:a1b13119ff624af7a283ea9a0a9386b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc703d439acc814a69b14cbd16468e80" id="r_abc703d439acc814a69b14cbd16468e80"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#abc703d439acc814a69b14cbd16468e80">beginGFSK</a> (float freq=434.0, float br=4.8, float freqDev=5.0, float rxBw=153.8, int8_t power=10, uint16_t preambleLength=16, float tcxoVoltage=1.6)</td></tr>
<tr class="memdesc:abc703d439acc814a69b14cbd16468e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem.  <br /></td></tr>
<tr class="separator:abc703d439acc814a69b14cbd16468e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab824e75ac4a6fcec1c9fbed298c1eeda" id="r_ab824e75ac4a6fcec1c9fbed298c1eeda"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ab824e75ac4a6fcec1c9fbed298c1eeda">beginOOK</a> (float freq=434.0, float br=4.8, float rxBw=153.8, int8_t power=10, uint16_t preambleLength=16, float tcxoVoltage=1.6)</td></tr>
<tr class="memdesc:ab824e75ac4a6fcec1c9fbed298c1eeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for OOK modem.  <br /></td></tr>
<tr class="separator:ab824e75ac4a6fcec1c9fbed298c1eeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d914ed14ec9d82faf65c7fba7a02b1" id="r_aa6d914ed14ec9d82faf65c7fba7a02b1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aa6d914ed14ec9d82faf65c7fba7a02b1">beginLRFHSS</a> (float freq=434.0, uint8_t bw=RADIOLIB_LRXXXX_LR_FHSS_BW_722_66, uint8_t cr=RADIOLIB_LRXXXX_LR_FHSS_CR_2_3, bool narrowGrid=true, int8_t power=10, float tcxoVoltage=1.6)</td></tr>
<tr class="memdesc:aa6d914ed14ec9d82faf65c7fba7a02b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for LR-FHSS modem.  <br /></td></tr>
<tr class="separator:aa6d914ed14ec9d82faf65c7fba7a02b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b49d22917a9fe66398d544e0d91088" id="r_a62b49d22917a9fe66398d544e0d91088"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a62b49d22917a9fe66398d544e0d91088">beginFLRC</a> (float freq=434.0, uint16_t br=650, uint8_t cr=RADIOLIB_LR2021_FLRC_CR_2_3, int8_t pwr=10, uint16_t preambleLength=16, uint8_t dataShaping=<a class="el" href="group__config__shaping.html#gaa778d14c29d21fe329137a28a3f54a5d">RADIOLIB_SHAPING_0_5</a>, float tcxoVoltage=1.6)</td></tr>
<tr class="memdesc:a62b49d22917a9fe66398d544e0d91088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FLRC modem.  <br /></td></tr>
<tr class="separator:a62b49d22917a9fe66398d544e0d91088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8126dd09cf4c51eabcf7f72dc03b068d" id="r_a8126dd09cf4c51eabcf7f72dc03b068d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a8126dd09cf4c51eabcf7f72dc03b068d">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a8126dd09cf4c51eabcf7f72dc03b068d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a8126dd09cf4c51eabcf7f72dc03b068d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aa09fca3c2e895d0bf8fee166b6778" id="r_a08aa09fca3c2e895d0bf8fee166b6778"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a08aa09fca3c2e895d0bf8fee166b6778">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0) override</td></tr>
<tr class="memdesc:a08aa09fca3c2e895d0bf8fee166b6778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a08aa09fca3c2e895d0bf8fee166b6778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670691f6a40a82f2e6b25e90c4200f57" id="r_a670691f6a40a82f2e6b25e90c4200f57"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a670691f6a40a82f2e6b25e90c4200f57">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:a670691f6a40a82f2e6b25e90c4200f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode transmission.  <br /></td></tr>
<tr class="separator:a670691f6a40a82f2e6b25e90c4200f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bea897ee70fc8c4d8f311d97871195b" id="r_a1bea897ee70fc8c4d8f311d97871195b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a1bea897ee70fc8c4d8f311d97871195b">receiveDirect</a> () override</td></tr>
<tr class="memdesc:a1bea897ee70fc8c4d8f311d97871195b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as <a class="el" href="class_l_r2021.html">LR2021</a> does not support direct mode reception. Will always return RADIOLIB_ERR_UNKNOWN.  <br /></td></tr>
<tr class="separator:a1bea897ee70fc8c4d8f311d97871195b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8e79cd860d03edbb6c38ca4e62b8fc" id="r_a3a8e79cd860d03edbb6c38ca4e62b8fc"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a3a8e79cd860d03edbb6c38ca4e62b8fc">scanChannel</a> () override</td></tr>
<tr class="memdesc:a3a8e79cd860d03edbb6c38ca4e62b8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for LoRa transmission in the current channel. Detects both preamble and payload.  <br /></td></tr>
<tr class="separator:a3a8e79cd860d03edbb6c38ca4e62b8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fbe7fbdc6cd06e068b8cfa72cf5fc9" id="r_a80fbe7fbdc6cd06e068b8cfa72cf5fc9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a80fbe7fbdc6cd06e068b8cfa72cf5fc9">scanChannel</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config) override</td></tr>
<tr class="memdesc:a80fbe7fbdc6cd06e068b8cfa72cf5fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for LoRa transmission in the current channel. Detects both preamble and payload.  <br /></td></tr>
<tr class="separator:a80fbe7fbdc6cd06e068b8cfa72cf5fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab065a956b2fcc17169b5c228dc66b8c0" id="r_ab065a956b2fcc17169b5c228dc66b8c0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ab065a956b2fcc17169b5c228dc66b8c0">standby</a> () override</td></tr>
<tr class="memdesc:ab065a956b2fcc17169b5c228dc66b8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator).  <br /></td></tr>
<tr class="separator:ab065a956b2fcc17169b5c228dc66b8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1f96d15e812fe61f5be741d3a47c38" id="r_a1c1f96d15e812fe61f5be741d3a47c38"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a1c1f96d15e812fe61f5be741d3a47c38">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:a1c1f96d15e812fe61f5be741d3a47c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <br /></td></tr>
<tr class="separator:a1c1f96d15e812fe61f5be741d3a47c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5016d7784e0204cf0cac1794c05e9f55" id="r_a5016d7784e0204cf0cac1794c05e9f55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a5016d7784e0204cf0cac1794c05e9f55">standby</a> (uint8_t mode, bool wakeup)</td></tr>
<tr class="memdesc:a5016d7784e0204cf0cac1794c05e9f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <br /></td></tr>
<tr class="separator:a5016d7784e0204cf0cac1794c05e9f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e54c607b9c6e19406abc9f8ad29a817" id="r_a0e54c607b9c6e19406abc9f8ad29a817"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0e54c607b9c6e19406abc9f8ad29a817">sleep</a> () override</td></tr>
<tr class="memdesc:a0e54c607b9c6e19406abc9f8ad29a817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r2021.html#ab065a956b2fcc17169b5c228dc66b8c0" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>. Overload with warm start enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <br /></td></tr>
<tr class="separator:a0e54c607b9c6e19406abc9f8ad29a817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade792fc1fdac2a5b68d76267cd24833f" id="r_ade792fc1fdac2a5b68d76267cd24833f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ade792fc1fdac2a5b68d76267cd24833f">sleep</a> (bool retainConfig, uint32_t sleepTime)</td></tr>
<tr class="memdesc:ade792fc1fdac2a5b68d76267cd24833f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r2021.html#ab065a956b2fcc17169b5c228dc66b8c0" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>.  <br /></td></tr>
<tr class="separator:ade792fc1fdac2a5b68d76267cd24833f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea734806d4056f8ea47b4f828bcf8b3b" id="r_aea734806d4056f8ea47b4f828bcf8b3b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aea734806d4056f8ea47b4f828bcf8b3b">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:aea734806d4056f8ea47b4f828bcf8b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <br /></td></tr>
<tr class="separator:aea734806d4056f8ea47b4f828bcf8b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bfd550e471626da5e8c6bab1e3f415" id="r_a80bfd550e471626da5e8c6bab1e3f415"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a80bfd550e471626da5e8c6bab1e3f415">finishTransmit</a> () override</td></tr>
<tr class="memdesc:a80bfd550e471626da5e8c6bab1e3f415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <br /></td></tr>
<tr class="separator:a80bfd550e471626da5e8c6bab1e3f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cb9a1ec4f8ffb323f32a48a477b150" id="r_ad0cb9a1ec4f8ffb323f32a48a477b150"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ad0cb9a1ec4f8ffb323f32a48a477b150">startReceive</a> () override</td></tr>
<tr class="memdesc:ad0cb9a1ec4f8ffb323f32a48a477b150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:ad0cb9a1ec4f8ffb323f32a48a477b150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d318b6eca634bccf74b99a493b32236" id="r_a0d318b6eca634bccf74b99a493b32236"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0d318b6eca634bccf74b99a493b32236">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a0d318b6eca634bccf74b99a493b32236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData!  <br /></td></tr>
<tr class="separator:a0d318b6eca634bccf74b99a493b32236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaa4984504bdd10ae75e0163c0871db" id="r_aabaa4984504bdd10ae75e0163c0871db"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aabaa4984504bdd10ae75e0163c0871db">finishReceive</a> () override</td></tr>
<tr class="memdesc:aabaa4984504bdd10ae75e0163c0871db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after reception is done.  <br /></td></tr>
<tr class="separator:aabaa4984504bdd10ae75e0163c0871db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669f66069b12d1363789b39af363c68c" id="r_a669f66069b12d1363789b39af363c68c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a669f66069b12d1363789b39af363c68c">startChannelScan</a> () override</td></tr>
<tr class="memdesc:a669f66069b12d1363789b39af363c68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout. Defaults to CAD parameter values recommended by AN1200.48.  <br /></td></tr>
<tr class="separator:a669f66069b12d1363789b39af363c68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf00a7bf608444bc290913ed149ce7c" id="r_abcf00a7bf608444bc290913ed149ce7c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#abcf00a7bf608444bc290913ed149ce7c">startChannelScan</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config) override</td></tr>
<tr class="memdesc:abcf00a7bf608444bc290913ed149ce7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. IRQ pin will be activated when LoRa preamble is detected, or upon timeout.  <br /></td></tr>
<tr class="separator:abcf00a7bf608444bc290913ed149ce7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8560915043a2c21892b51bc576ea73" id="r_a5c8560915043a2c21892b51bc576ea73"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a5c8560915043a2c21892b51bc576ea73">getChannelScanResult</a> () override</td></tr>
<tr class="memdesc:a5c8560915043a2c21892b51bc576ea73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <br /></td></tr>
<tr class="separator:a5c8560915043a2c21892b51bc576ea73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed89cc7405fc0e0157a146cb1aee07c" id="r_a3ed89cc7405fc0e0157a146cb1aee07c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a3ed89cc7405fc0e0157a146cb1aee07c">getIrqFlags</a> () override</td></tr>
<tr class="memdesc:a3ed89cc7405fc0e0157a146cb1aee07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read currently active IRQ flags.  <br /></td></tr>
<tr class="separator:a3ed89cc7405fc0e0157a146cb1aee07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f977f788bc15e396dcb6025987c513" id="r_af2f977f788bc15e396dcb6025987c513"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#af2f977f788bc15e396dcb6025987c513">setIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:af2f977f788bc15e396dcb6025987c513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:af2f977f788bc15e396dcb6025987c513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cee48cac6a64d518353aa2389f8074" id="r_a21cee48cac6a64d518353aa2389f8074"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a21cee48cac6a64d518353aa2389f8074">clearIrqFlags</a> (uint32_t irq) override</td></tr>
<tr class="memdesc:a21cee48cac6a64d518353aa2389f8074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a21cee48cac6a64d518353aa2389f8074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8923a4d2a3cf8a7834ae6c53c6d3eb0" id="r_ab8923a4d2a3cf8a7834ae6c53c6d3eb0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ab8923a4d2a3cf8a7834ae6c53c6d3eb0">setModem</a> (ModemType_t modem) override</td></tr>
<tr class="memdesc:ab8923a4d2a3cf8a7834ae6c53c6d3eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters.  <br /></td></tr>
<tr class="separator:ab8923a4d2a3cf8a7834ae6c53c6d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602ba1f6b66b263f84ccd0a73f15381c" id="r_a602ba1f6b66b263f84ccd0a73f15381c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a602ba1f6b66b263f84ccd0a73f15381c">setFrequency</a> (float freq) override</td></tr>
<tr class="memdesc:a602ba1f6b66b263f84ccd0a73f15381c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Allowed values are in range from 150.0 to 960.0 MHz, 1900 - 2200 MHz and 2400 - 2500 MHz. Will automatically perform image calibration if the frequency changes by more than RADIOLIB_LR2021_CAL_IMG_FREQ_TRIG MHz. NOTE: When switching between sub-GHz and high-frequency bands, after changing the frequency, <a class="el" href="class_l_r2021.html#aca2599a31c088a5e8c59317ae132d4d0" title="Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-...">setOutputPower()</a> must be called in order to set the correct power amplifier!  <br /></td></tr>
<tr class="separator:a602ba1f6b66b263f84ccd0a73f15381c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e05f34bffa00c64b03cb1ec05951929" id="r_a0e05f34bffa00c64b03cb1ec05951929"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0e05f34bffa00c64b03cb1ec05951929">setFrequency</a> (float freq, bool skipCalibration)</td></tr>
<tr class="memdesc:a0e05f34bffa00c64b03cb1ec05951929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Allowed values are in range from 150.0 to 960.0 MHz, 1900 - 2200 MHz and 2400 - 2500 MHz. Will automatically perform image calibration if the frequency changes by more than RADIOLIB_LR2021_CAL_IMG_FREQ_TRIG MHz. NOTE: When switching between sub-GHz and high-frequency bands, after changing the frequency, <a class="el" href="class_l_r2021.html#aca2599a31c088a5e8c59317ae132d4d0" title="Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-...">setOutputPower()</a> must be called in order to set the correct power amplifier!  <br /></td></tr>
<tr class="separator:a0e05f34bffa00c64b03cb1ec05951929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2599a31c088a5e8c59317ae132d4d0" id="r_aca2599a31c088a5e8c59317ae132d4d0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aca2599a31c088a5e8c59317ae132d4d0">setOutputPower</a> (int8_t power) override</td></tr>
<tr class="memdesc:aca2599a31c088a5e8c59317ae132d4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-frequency PA).  <br /></td></tr>
<tr class="separator:aca2599a31c088a5e8c59317ae132d4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d38e9fa1f3250d78482c8fb755f22a2" id="r_a2d38e9fa1f3250d78482c8fb755f22a2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a2d38e9fa1f3250d78482c8fb755f22a2">setOutputPower</a> (int8_t power, uint32_t rampTimeUs)</td></tr>
<tr class="memdesc:a2d38e9fa1f3250d78482c8fb755f22a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-frequency PA).  <br /></td></tr>
<tr class="separator:a2d38e9fa1f3250d78482c8fb755f22a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c82cdc7a22f252dfd36b2516ee7c49" id="r_a39c82cdc7a22f252dfd36b2516ee7c49"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a39c82cdc7a22f252dfd36b2516ee7c49">checkOutputPower</a> (int8_t power, int8_t *clipped) override</td></tr>
<tr class="memdesc:a39c82cdc7a22f252dfd36b2516ee7c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>.  <br /></td></tr>
<tr class="separator:a39c82cdc7a22f252dfd36b2516ee7c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2cb23b1f2dbdcd53a140b8a53d7e776" id="r_ab2cb23b1f2dbdcd53a140b8a53d7e776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ab2cb23b1f2dbdcd53a140b8a53d7e776">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:ab2cb23b1f2dbdcd53a140b8a53d7e776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.    <br /></td></tr>
<tr class="separator:ab2cb23b1f2dbdcd53a140b8a53d7e776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722b8a19894aa26c4ca6d880f1211298" id="r_a722b8a19894aa26c4ca6d880f1211298"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a722b8a19894aa26c4ca6d880f1211298">setBandwidth</a> (float bw)</td></tr>
<tr class="memdesc:a722b8a19894aa26c4ca6d880f1211298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa bandwidth. Allowed values are 31.25, 41.67, 62.5, 83.34, 125.0, 101.56, 203.13, 250.0, 406.25, 500.0 kHz, 812.5 kHz and 1000.0 kHz.  <br /></td></tr>
<tr class="separator:a722b8a19894aa26c4ca6d880f1211298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6e0999997105037967da5e571c0b29" id="r_aca6e0999997105037967da5e571c0b29"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aca6e0999997105037967da5e571c0b29">setSpreadingFactor</a> (uint8_t sf, bool legacy=false)</td></tr>
<tr class="memdesc:aca6e0999997105037967da5e571c0b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa spreading factor. Allowed values range from 5 to 12.  <br /></td></tr>
<tr class="separator:aca6e0999997105037967da5e571c0b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0db140307e3e0d7bd31641fe0d5fe" id="r_a49d0db140307e3e0d7bd31641fe0d5fe"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a49d0db140307e3e0d7bd31641fe0d5fe">setCodingRate</a> (uint8_t cr, bool longInterleave=false)</td></tr>
<tr class="memdesc:a49d0db140307e3e0d7bd31641fe0d5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa coding rate denominator. Allowed values range from 4 to 8. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC.  <br /></td></tr>
<tr class="separator:a49d0db140307e3e0d7bd31641fe0d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0792e44750e268eb38c3c2f28b13455a" id="r_a0792e44750e268eb38c3c2f28b13455a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0792e44750e268eb38c3c2f28b13455a">setSyncWord</a> (uint8_t syncWord)</td></tr>
<tr class="memdesc:a0792e44750e268eb38c3c2f28b13455a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa sync word.  <br /></td></tr>
<tr class="separator:a0792e44750e268eb38c3c2f28b13455a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe825d8bf2bf526058914bf99b71a92" id="r_abfe825d8bf2bf526058914bf99b71a92"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#abfe825d8bf2bf526058914bf99b71a92">setPreambleLength</a> (size_t preambleLength) override</td></tr>
<tr class="memdesc:abfe825d8bf2bf526058914bf99b71a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length for LoRa or GFSK modem. Allowed values range from 1 to 65535.  <br /></td></tr>
<tr class="separator:abfe825d8bf2bf526058914bf99b71a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a421e4a6308a24166a23ff50e613c" id="r_a2c2a421e4a6308a24166a23ff50e613c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a2c2a421e4a6308a24166a23ff50e613c">setTCXO</a> (float voltage, uint32_t delay=1000000)</td></tr>
<tr class="memdesc:a2c2a421e4a6308a24166a23ff50e613c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TCXO (Temperature Compensated Crystal Oscillator) configuration.  <br /></td></tr>
<tr class="separator:a2c2a421e4a6308a24166a23ff50e613c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d4b44df2968fee363102c3fa528fc" id="r_a508d4b44df2968fee363102c3fa528fc"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a508d4b44df2968fee363102c3fa528fc">setCRC</a> (uint8_t len, uint32_t initial=0x00001D0FUL, uint32_t polynomial=0x00001021UL, bool inverted=true)</td></tr>
<tr class="memdesc:a508d4b44df2968fee363102c3fa528fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets CRC configuration.  <br /></td></tr>
<tr class="separator:a508d4b44df2968fee363102c3fa528fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f382f3585b68e5329e7392a3026acb5" id="r_a6f382f3585b68e5329e7392a3026acb5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a6f382f3585b68e5329e7392a3026acb5">invertIQ</a> (bool enable) override</td></tr>
<tr class="memdesc:a6f382f3585b68e5329e7392a3026acb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable inversion of the I and Q signals.  <br /></td></tr>
<tr class="separator:a6f382f3585b68e5329e7392a3026acb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07413158d09efd4e4d91046a1d1245a6" id="r_a07413158d09efd4e4d91046a1d1245a6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a07413158d09efd4e4d91046a1d1245a6">setBitRate</a> (float br) override</td></tr>
<tr class="memdesc:a07413158d09efd4e4d91046a1d1245a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK bit rate. Allowed values range from 0.5 to 2000.0 kbps.  <br /></td></tr>
<tr class="separator:a07413158d09efd4e4d91046a1d1245a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae038b9716d7d59a7c9dcb285e5ff34f5" id="r_ae038b9716d7d59a7c9dcb285e5ff34f5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ae038b9716d7d59a7c9dcb285e5ff34f5">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:ae038b9716d7d59a7c9dcb285e5ff34f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK frequency deviation. Allowed values range from 0.6 to 500.0 kHz.  <br /></td></tr>
<tr class="separator:ae038b9716d7d59a7c9dcb285e5ff34f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af2e7efeb46334e528f691e6e03b564" id="r_a0af2e7efeb46334e528f691e6e03b564"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a0af2e7efeb46334e528f691e6e03b564">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a0af2e7efeb46334e528f691e6e03b564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz.  <br /></td></tr>
<tr class="separator:a0af2e7efeb46334e528f691e6e03b564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67fef9d1e4719d51871100e058be93d" id="r_ab67fef9d1e4719d51871100e058be93d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ab67fef9d1e4719d51871100e058be93d">setSyncWord</a> (uint8_t *syncWord, size_t len) override</td></tr>
<tr class="memdesc:ab67fef9d1e4719d51871100e058be93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK sync word in the form of array of up to 8 bytes.  <br /></td></tr>
<tr class="separator:ab67fef9d1e4719d51871100e058be93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecc461944b46e15a4573288a752a4c2" id="r_abecc461944b46e15a4573288a752a4c2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#abecc461944b46e15a4573288a752a4c2">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:abecc461944b46e15a4573288a752a4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets node address. Calling this method will also enable address filtering for node address only.  <br /></td></tr>
<tr class="separator:abecc461944b46e15a4573288a752a4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3906c62ff40c1f7871ab92c1573d9042" id="r_a3906c62ff40c1f7871ab92c1573d9042"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a3906c62ff40c1f7871ab92c1573d9042">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:a3906c62ff40c1f7871ab92c1573d9042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address.  <br /></td></tr>
<tr class="separator:a3906c62ff40c1f7871ab92c1573d9042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f586b966393cd54bdd885ea70dd1709" id="r_a2f586b966393cd54bdd885ea70dd1709"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a2f586b966393cd54bdd885ea70dd1709">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:a2f586b966393cd54bdd885ea70dd1709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables address filtering. Calling this method will also erase previously set addresses.  <br /></td></tr>
<tr class="separator:a2f586b966393cd54bdd885ea70dd1709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99bda2205aacb19befd05f5bdd021a65" id="r_a99bda2205aacb19befd05f5bdd021a65"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a99bda2205aacb19befd05f5bdd021a65">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:a99bda2205aacb19befd05f5bdd021a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <br /></td></tr>
<tr class="separator:a99bda2205aacb19befd05f5bdd021a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a65db5e1dbe5f3ff72021e4acad6c40" id="r_a6a65db5e1dbe5f3ff72021e4acad6c40"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a6a65db5e1dbe5f3ff72021e4acad6c40">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:a6a65db5e1dbe5f3ff72021e4acad6c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Available in GFSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <br /></td></tr>
<tr class="separator:a6a65db5e1dbe5f3ff72021e4acad6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934a871e6f92b290541fe975f6f32bae" id="r_a934a871e6f92b290541fe975f6f32bae"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a934a871e6f92b290541fe975f6f32bae">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_LR2021_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:a934a871e6f92b290541fe975f6f32bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in GFSK mode only.  <br /></td></tr>
<tr class="separator:a934a871e6f92b290541fe975f6f32bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68728e2b6347b49bae942a9360f40988" id="r_a68728e2b6347b49bae942a9360f40988"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a68728e2b6347b49bae942a9360f40988">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_LR2021_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:a68728e2b6347b49bae942a9360f40988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in GFSK mode only.  <br /></td></tr>
<tr class="separator:a68728e2b6347b49bae942a9360f40988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d641cb6dc009ab1999fe4e68e2aea97" id="r_a7d641cb6dc009ab1999fe4e68e2aea97"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a7d641cb6dc009ab1999fe4e68e2aea97">setWhitening</a> (bool enabled, uint16_t initial=0x01FF)</td></tr>
<tr class="memdesc:a7d641cb6dc009ab1999fe4e68e2aea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets GFSK whitening parameters.  <br /></td></tr>
<tr class="separator:a7d641cb6dc009ab1999fe4e68e2aea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225430eeb1ef175c3920b19e8fd00937" id="r_a225430eeb1ef175c3920b19e8fd00937"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a225430eeb1ef175c3920b19e8fd00937">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE) override</td></tr>
<tr class="memdesc:a225430eeb1ef175c3920b19e8fd00937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data rate.  <br /></td></tr>
<tr class="separator:a225430eeb1ef175c3920b19e8fd00937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2271630945521d4a1eaa3a29dcffac1b" id="r_a2271630945521d4a1eaa3a29dcffac1b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a2271630945521d4a1eaa3a29dcffac1b">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE) override</td></tr>
<tr class="memdesc:a2271630945521d4a1eaa3a29dcffac1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module.  <br /></td></tr>
<tr class="separator:a2271630945521d4a1eaa3a29dcffac1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9eef45712d5daae3c0a38e7dfd5d73" id="r_afc9eef45712d5daae3c0a38e7dfd5d73"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#afc9eef45712d5daae3c0a38e7dfd5d73">setLrFhssConfig</a> (uint8_t bw, uint8_t cr, uint8_t hdrCount=3, uint16_t hopSeed=0x13A)</td></tr>
<tr class="memdesc:afc9eef45712d5daae3c0a38e7dfd5d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LR-FHSS configuration.  <br /></td></tr>
<tr class="separator:afc9eef45712d5daae3c0a38e7dfd5d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a71766e8fa71dc9224006b580de8f9" id="r_ad3a71766e8fa71dc9224006b580de8f9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ad3a71766e8fa71dc9224006b580de8f9">setRxBoostedGainMode</a> (uint8_t level)</td></tr>
<tr class="memdesc:ad3a71766e8fa71dc9224006b580de8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables Rx Boosted Gain mode (additional Rx gain for increased power consumption).  <br /></td></tr>
<tr class="separator:ad3a71766e8fa71dc9224006b580de8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cc2e14f141502bb3e3e2d082916cd0" id="r_a84cc2e14f141502bb3e3e2d082916cd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a84cc2e14f141502bb3e3e2d082916cd0">getTimeOnAir</a> (size_t len) override</td></tr>
<tr class="memdesc:a84cc2e14f141502bb3e3e2d082916cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <br /></td></tr>
<tr class="separator:a84cc2e14f141502bb3e3e2d082916cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7069e59abecae1e4b48de5920da4b3" id="r_a8d7069e59abecae1e4b48de5920da4b3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a8d7069e59abecae1e4b48de5920da4b3">getModem</a> (ModemType_t *modem) override</td></tr>
<tr class="memdesc:a8d7069e59abecae1e4b48de5920da4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modem currently in use by the radio.  <br /></td></tr>
<tr class="separator:a8d7069e59abecae1e4b48de5920da4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7fa49b2245a3dfc3613bfcac4a249e" id="r_adf7fa49b2245a3dfc3613bfcac4a249e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#adf7fa49b2245a3dfc3613bfcac4a249e">stageMode</a> (RadioModeType_t mode, <a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *cfg) override</td></tr>
<tr class="memdesc:adf7fa49b2245a3dfc3613bfcac4a249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage mode of the radio to be launched later using launchMode.    <br /></td></tr>
<tr class="separator:adf7fa49b2245a3dfc3613bfcac4a249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4ebe0b2af4604494a44ccd650fb137" id="r_a6d4ebe0b2af4604494a44ccd650fb137"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a6d4ebe0b2af4604494a44ccd650fb137">launchMode</a> () override</td></tr>
<tr class="memdesc:a6d4ebe0b2af4604494a44ccd650fb137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch previously staged mode.    <br /></td></tr>
<tr class="separator:a6d4ebe0b2af4604494a44ccd650fb137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bac7d26814507e56ee90d3dc6fd77a" id="r_aa3bac7d26814507e56ee90d3dc6fd77a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aa3bac7d26814507e56ee90d3dc6fd77a">getVoltage</a> (uint8_t bits=13)</td></tr>
<tr class="memdesc:aa3bac7d26814507e56ee90d3dc6fd77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the supply voltage on the Vbat pin.  <br /></td></tr>
<tr class="separator:aa3bac7d26814507e56ee90d3dc6fd77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb35ae71215ecbaff2262887171cfd7f" id="r_afb35ae71215ecbaff2262887171cfd7f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#afb35ae71215ecbaff2262887171cfd7f">getTemperature</a> (uint8_t source, uint8_t bits=13)</td></tr>
<tr class="memdesc:afb35ae71215ecbaff2262887171cfd7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the temperature.  <br /></td></tr>
<tr class="separator:afb35ae71215ecbaff2262887171cfd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444ec095ed8bd08df909b3b1b899d35e" id="r_a444ec095ed8bd08df909b3b1b899d35e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a444ec095ed8bd08df909b3b1b899d35e">getRSSI</a> () override</td></tr>
<tr class="memdesc:a444ec095ed8bd08df909b3b1b899d35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets recorded signal strength indicator. Overload with packet mode enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <br /></td></tr>
<tr class="separator:a444ec095ed8bd08df909b3b1b899d35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11674102f4d704d02d27eaceeaeccd35" id="r_a11674102f4d704d02d27eaceeaeccd35"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a11674102f4d704d02d27eaceeaeccd35">getRSSI</a> (bool packet, bool skipReceive=false)</td></tr>
<tr class="memdesc:a11674102f4d704d02d27eaceeaeccd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator).  <br /></td></tr>
<tr class="separator:a11674102f4d704d02d27eaceeaeccd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaf960d942fbff38c12ccb38b137122" id="r_addaf960d942fbff38c12ccb38b137122"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#addaf960d942fbff38c12ccb38b137122">getSNR</a> () override</td></tr>
<tr class="memdesc:addaf960d942fbff38c12ccb38b137122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <br /></td></tr>
<tr class="separator:addaf960d942fbff38c12ccb38b137122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcca6fe60ef562616d08318663bbb3d" id="r_aefcca6fe60ef562616d08318663bbb3d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aefcca6fe60ef562616d08318663bbb3d">randomByte</a> () override</td></tr>
<tr class="memdesc:aefcca6fe60ef562616d08318663bbb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <br /></td></tr>
<tr class="separator:aefcca6fe60ef562616d08318663bbb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55c538925942546916a1ee2be075d8" id="r_acf55c538925942546916a1ee2be075d8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#acf55c538925942546916a1ee2be075d8">implicitHeader</a> (size_t len)</td></tr>
<tr class="memdesc:acf55c538925942546916a1ee2be075d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set implicit header mode for future reception/transmission.  <br /></td></tr>
<tr class="separator:acf55c538925942546916a1ee2be075d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cf216f8aee520a559b64cc03f61901" id="r_a53cf216f8aee520a559b64cc03f61901"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a53cf216f8aee520a559b64cc03f61901">explicitHeader</a> ()</td></tr>
<tr class="memdesc:a53cf216f8aee520a559b64cc03f61901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set explicit header mode for future reception/transmission.  <br /></td></tr>
<tr class="separator:a53cf216f8aee520a559b64cc03f61901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4aaffbca82fd163c09e004d9df205f1" id="r_af4aaffbca82fd163c09e004d9df205f1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#af4aaffbca82fd163c09e004d9df205f1">ookDetector</a> (uint16_t pattern=0x0285, uint8_t len=16, uint8_t repeats=0, bool syncRaw=false, bool rising=false, uint8_t sofLen=0)</td></tr>
<tr class="memdesc:af4aaffbca82fd163c09e004d9df205f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OOK detector properties. The default values are set to allow ADS-B reception.  <br /></td></tr>
<tr class="separator:af4aaffbca82fd163c09e004d9df205f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e88077f2e75c598e0ca820196d7ed9d" id="r_a4e88077f2e75c598e0ca820196d7ed9d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a4e88077f2e75c598e0ca820196d7ed9d">setOokDetectionThreshold</a> (int16_t level)</td></tr>
<tr class="memdesc:a4e88077f2e75c598e0ca820196d7ed9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set OOK detection threshold.  <br /></td></tr>
<tr class="separator:a4e88077f2e75c598e0ca820196d7ed9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2d2d22e793e32c50efd5f01881979e" id="r_aca2d2d22e793e32c50efd5f01881979e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#aca2d2d22e793e32c50efd5f01881979e">setSideDetector</a> (const <a class="el" href="struct_l_r2021_lo_ra_side_detector__t.html">LR2021LoRaSideDetector_t</a> *cfg, size_t numDetectors)</td></tr>
<tr class="memdesc:aca2d2d22e793e32c50efd5f01881979e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure LoRa side detector, which enables to detect mutiple spreading factors and receive one of them. The following limitations apply: In Rx mode, all side-detector spreading factors must be higher than the primary one (configured via begin or setSpreadingFactor) For CAD mode, the above condition is inverted - all side-detector spreading factors must be smaller All packets to be detected must have the same header type (implicit or explicit) If bandwidth is higher than 500 kHz, at most 2 side detectors are allowed. If the primary spreading factor is 10, 11 or 12, at most 2 side detectors are allowed. All spreading factors must be different. The difference between maximum and minimum spreading factor used must be less than or equal to 4.  <br /></td></tr>
<tr class="separator:aca2d2d22e793e32c50efd5f01881979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874b2522d4b296505278d943df308a99" id="r_a874b2522d4b296505278d943df308a99"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a874b2522d4b296505278d943df308a99">setGain</a> (uint8_t gain)</td></tr>
<tr class="memdesc:a874b2522d4b296505278d943df308a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets gain of receiver LNA (low-noise amplifier). Can be set to any integer in range 1 to 13, where 13 is the highest gain. Set to 0 to enable automatic gain control (recommended).  <br /></td></tr>
<tr class="separator:a874b2522d4b296505278d943df308a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada508497ee2e70170da3afe078e2fe0e" id="r_ada508497ee2e70170da3afe078e2fe0e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ada508497ee2e70170da3afe078e2fe0e">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ada508497ee2e70170da3afe078e2fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ada508497ee2e70170da3afe078e2fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608fabef91defa1e33e6a6787c68ce8" id="r_ae608fabef91defa1e33e6a6787c68ce8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ae608fabef91defa1e33e6a6787c68ce8">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0)</td></tr>
<tr class="memdesc:ae608fabef91defa1e33e6a6787c68ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae608fabef91defa1e33e6a6787c68ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79757dbbd62e080c1bad2e608ab940c" id="r_af79757dbbd62e080c1bad2e608ab940c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#af79757dbbd62e080c1bad2e608ab940c">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:af79757dbbd62e080c1bad2e608ab940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <br /></td></tr>
<tr class="separator:af79757dbbd62e080c1bad2e608ab940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18664ad615c5507ff1690baaca90b094" id="r_a18664ad615c5507ff1690baaca90b094"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a18664ad615c5507ff1690baaca90b094">startReceive</a> ()</td></tr>
<tr class="memdesc:a18664ad615c5507ff1690baaca90b094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets module to received mode using its default configuration.  <br /></td></tr>
<tr class="separator:a18664ad615c5507ff1690baaca90b094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93500dfbcfd39837e04c0f3eaa40d97" id="r_ae93500dfbcfd39837e04c0f3eaa40d97"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#ae93500dfbcfd39837e04c0f3eaa40d97">startReceive</a> (uint32_t timeout, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqFlags=RADIOLIB_IRQ_RX_DEFAULT_FLAGS, <a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irqMask=RADIOLIB_IRQ_RX_DEFAULT_MASK, size_t len=0)</td></tr>
<tr class="memdesc:ae93500dfbcfd39837e04c0f3eaa40d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae93500dfbcfd39837e04c0f3eaa40d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300" id="r_a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_r2021.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_l_rxxxx"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_l_rxxxx')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_l_rxxxx.html">LRxxxx</a></td></tr>
<tr class="memitem:a39236cf915fe31cbc46d80487a0e0ac6 inherit pub_methods_class_l_rxxxx" id="r_a39236cf915fe31cbc46d80487a0e0ac6"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>LRxxxx</b> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="separator:a39236cf915fe31cbc46d80487a0e0ac6 inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad653a5cb836ffde04ef55973d153484f inherit pub_methods_class_l_rxxxx" id="r_ad653a5cb836ffde04ef55973d153484f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#ad653a5cb836ffde04ef55973d153484f">reset</a> ()</td></tr>
<tr class="memdesc:ad653a5cb836ffde04ef55973d153484f inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin.  <br /></td></tr>
<tr class="separator:ad653a5cb836ffde04ef55973d153484f inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52838eb97f91110fb381cddc8e7d03a inherit pub_methods_class_l_rxxxx" id="r_aa52838eb97f91110fb381cddc8e7d03a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#aa52838eb97f91110fb381cddc8e7d03a">setIrqAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:aa52838eb97f91110fb381cddc8e7d03a inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when IRQ1 activates.  <br /></td></tr>
<tr class="separator:aa52838eb97f91110fb381cddc8e7d03a inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2ae3c67468c0e0bfd970f12c7867330 inherit pub_methods_class_l_rxxxx" id="r_ac2ae3c67468c0e0bfd970f12c7867330"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearIrqAction</b> ()</td></tr>
<tr class="memdesc:ac2ae3c67468c0e0bfd970f12c7867330 inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when IRQ1 activates. <br /></td></tr>
<tr class="separator:ac2ae3c67468c0e0bfd970f12c7867330 inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51974c95b458ec80c73d2c4a62d83684 inherit pub_methods_class_l_rxxxx" id="r_a51974c95b458ec80c73d2c4a62d83684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#a51974c95b458ec80c73d2c4a62d83684">setPacketReceivedAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a51974c95b458ec80c73d2c4a62d83684 inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a51974c95b458ec80c73d2c4a62d83684 inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55e6f6f3b5485907346b5962293dff0 inherit pub_methods_class_l_rxxxx" id="r_ad55e6f6f3b5485907346b5962293dff0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#ad55e6f6f3b5485907346b5962293dff0">clearPacketReceivedAction</a> () override</td></tr>
<tr class="memdesc:ad55e6f6f3b5485907346b5962293dff0 inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:ad55e6f6f3b5485907346b5962293dff0 inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb00035fcc5f1dddac0ba5159abe5cc inherit pub_methods_class_l_rxxxx" id="r_a8fb00035fcc5f1dddac0ba5159abe5cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#a8fb00035fcc5f1dddac0ba5159abe5cc">setPacketSentAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a8fb00035fcc5f1dddac0ba5159abe5cc inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a8fb00035fcc5f1dddac0ba5159abe5cc inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae142248e9c14ba978b937c84b4eb5a inherit pub_methods_class_l_rxxxx" id="r_acae142248e9c14ba978b937c84b4eb5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#acae142248e9c14ba978b937c84b4eb5a">clearPacketSentAction</a> () override</td></tr>
<tr class="memdesc:acae142248e9c14ba978b937c84b4eb5a inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:acae142248e9c14ba978b937c84b4eb5a inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2cfba89348f0b909758e451155bbaa inherit pub_methods_class_l_rxxxx" id="r_a4d2cfba89348f0b909758e451155bbaa"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#a4d2cfba89348f0b909758e451155bbaa">getIrqStatus</a> ()</td></tr>
<tr class="memdesc:a4d2cfba89348f0b909758e451155bbaa inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current IRQ status.  <br /></td></tr>
<tr class="separator:a4d2cfba89348f0b909758e451155bbaa inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8820e2b9a96e631788d34cdd47e83b0d inherit pub_methods_class_l_rxxxx" id="r_a8820e2b9a96e631788d34cdd47e83b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#a8820e2b9a96e631788d34cdd47e83b0d">calculateTimeOnAir</a> (ModemType_t modem, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc, size_t len) override</td></tr>
<tr class="memdesc:a8820e2b9a96e631788d34cdd47e83b0d inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size.  <br /></td></tr>
<tr class="separator:a8820e2b9a96e631788d34cdd47e83b0d inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a11e112ff2749eeaa9d04294bc2c80c inherit pub_methods_class_l_rxxxx" id="r_a7a11e112ff2749eeaa9d04294bc2c80c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_l_rxxxx.html#a7a11e112ff2749eeaa9d04294bc2c80c">calculateRxTimeout</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeoutUs) override</td></tr>
<tr class="memdesc:a7a11e112ff2749eeaa9d04294bc2c80c inherit pub_methods_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time)  <br /></td></tr>
<tr class="separator:a7a11e112ff2749eeaa9d04294bc2c80c inherit pub_methods_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer" id="r_afc972a84153977d6ccd9e116b6181ad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalLayer</b> ()</td></tr>
<tr class="memdesc:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer" id="r_a7af88f9f75c9778c29002c2b8238a239"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PhysicalLayer</b> ()=default</td></tr>
<tr class="memdesc:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer" id="r_ae602ebd46d60da8670c9f353cef695d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae602ebd46d60da8670c9f353cef695d9">getIrqMapped</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from radio-agnostic IRQ flags to radio-specific flags.  <br /></td></tr>
<tr class="separator:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer" id="r_a2c7dd4704e3df353265010710bd26e83"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a2c7dd4704e3df353265010710bd26e83">checkIrq</a> (RadioLibIrqType_t irq)</td></tr>
<tr class="memdesc:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a specific IRQ bit is set (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer" id="r_a8564f9834a0247e93e7620c23559ceb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8564f9834a0247e93e7620c23559ceb8">setIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on specific IRQ bit(s) (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer" id="r_af9a7e739e39705a72ffa8b63ec09bb15"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af9a7e739e39705a72ffa8b63ec09bb15">clearIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer" id="r_acd9171bd71aa80fb86113b612c42de53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer" id="r_a76113e10481743094a1cd0280692b0a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer" id="r_a88a10657bd2215a11a2331f937414b55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer" id="r_a8e378fe136a498ea485a9c10f5e15aab"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer" id="r_abf96cf4f3cb4c82d44be581dbe615966"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">setDirectAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is received in direct mode. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:abf96cf4f3cb4c82d44be581dbe615966 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer" id="r_acda61fc99cfa373153c50c78380ed885"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">readBit</a> (uint32_t pin)</td></tr>
<tr class="memdesc:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:acda61fc99cfa373153c50c78380ed885 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer" id="r_ab57182d32646861ef0d865e2740d6b26"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer" id="r_a429796eb2e7ea86781a2e8ca42af43f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropSync</b> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer" id="r_a4d5b30493c8d7fcfb784e128362d596c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer" id="r_ae11c191a7edf3116bf468b9153237260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">setChannelScanAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer" id="r_a169a4d04c5c50d3336e274d70930d9f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a169a4d04c5c50d3336e274d70930d9f6">clearChannelScanAction</a> ()</td></tr>
<tr class="memdesc:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a66b9703e39e95dc14e72328aee9becd0" id="r_a66b9703e39e95dc14e72328aee9becd0"><td class="memItemLeft" align="right" valign="top"><a id="a66b9703e39e95dc14e72328aee9becd0" name="a66b9703e39e95dc14e72328aee9becd0"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>irqDioNum</b> = 5</td></tr>
<tr class="memdesc:a66b9703e39e95dc14e72328aee9becd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which DIO pin is to be used as the interrupt pin. <br /></td></tr>
<tr class="separator:a66b9703e39e95dc14e72328aee9becd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_l_rxxxx"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_l_rxxxx')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_l_rxxxx.html">LRxxxx</a></td></tr>
<tr class="memitem:aedc6b7f69451ab79e05f5d9ff757fb20 inherit pub_attribs_class_l_rxxxx" id="r_aedc6b7f69451ab79e05f5d9ff757fb20"><td class="memItemLeft" align="right" valign="top">
bool&#160;</td><td class="memItemRight" valign="bottom"><b>XTAL</b></td></tr>
<tr class="memdesc:aedc6b7f69451ab79e05f5d9ff757fb20 inherit pub_attribs_class_l_rxxxx"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the module has an XTAL (true) or TCXO (false). Defaults to false. <br /></td></tr>
<tr class="separator:aedc6b7f69451ab79e05f5d9ff757fb20 inherit pub_attribs_class_l_rxxxx"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer" id="r_aa949616080a463a82bb6ad5075a9e16e"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>freqStep</b></td></tr>
<tr class="memdesc:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency step of the synthesizer in Hz. <br /></td></tr>
<tr class="separator:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer" id="r_a1c04f8fba5eef96e59972004e8abc623"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxPacketLength</b></td></tr>
<tr class="memdesc:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of packet that can be received by the module. <br /></td></tr>
<tr class="separator:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7cc93cb3b185f23008a5c4c250110c2e" name="a7cc93cb3b185f23008a5c4c250110c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc93cb3b185f23008a5c4c250110c2e">&#9670;&#160;</a></span>OpMode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_l_r2021.html#a7cc93cb3b185f23008a5c4c250110c2e">LR2021::OpMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom operation modes for <a class="el" href="class_l_r2021.html">LR2021</a>. Needed because <a class="el" href="class_l_r2021.html">LR2021</a> has several modems (sub-GHz, 2.4 GHz etc.) in one package. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2ea213ca32e2b01ccc39a8b5ed871e14ff8" name="a7cc93cb3b185f23008a5c4c250110c2ea213ca32e2b01ccc39a8b5ed871e14ff8"></a>MODE_END_OF_TABLE&#160;</td><td class="fielddoc"><p>End of table marker, use END_OF_MODE_TABLE constant instead </p>
</td></tr>
<tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2ea776ad40a0d311b01990a737549a6360e" name="a7cc93cb3b185f23008a5c4c250110c2ea776ad40a0d311b01990a737549a6360e"></a>MODE_STBY&#160;</td><td class="fielddoc"><p>Standby/idle mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2ea2a3dc8a60e80b39cf5c218e0454532c5" name="a7cc93cb3b185f23008a5c4c250110c2ea2a3dc8a60e80b39cf5c218e0454532c5"></a>MODE_RX&#160;</td><td class="fielddoc"><p>Receive mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2eae9bb7b727539e92dc623c12f0b120216" name="a7cc93cb3b185f23008a5c4c250110c2eae9bb7b727539e92dc623c12f0b120216"></a>MODE_TX&#160;</td><td class="fielddoc"><p>Transmission mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2ea55966ada4de25514944483e2203647e8" name="a7cc93cb3b185f23008a5c4c250110c2ea55966ada4de25514944483e2203647e8"></a>MODE_RX_HF&#160;</td><td class="fielddoc"><p>High frequency receive mode </p>
</td></tr>
<tr><td class="fieldname"><a id="a7cc93cb3b185f23008a5c4c250110c2eab7ce6e88852aea8f8401bc109744b2bf" name="a7cc93cb3b185f23008a5c4c250110c2eab7ce6e88852aea8f8401bc109744b2bf"></a>MODE_TX_HF&#160;</td><td class="fielddoc"><p>High frequency transmission mode </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0e61b0b25a43fb572e1bcd34fc02dda2" name="a0e61b0b25a43fb572e1bcd34fc02dda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e61b0b25a43fb572e1bcd34fc02dda2">&#9670;&#160;</a></span>LR2021()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LR2021::LR2021 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the radio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b13119ff624af7a283ea9a0a9386b6b" name="a1b13119ff624af7a283ea9a0a9386b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b13119ff624af7a283ea9a0a9386b6b">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em> = <code>125.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em> = <code>9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em> = <code>RADIOLIB_LR2021_LORA_SYNC_WORD_PRIVATE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em> = <code>1.6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for LoRa modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434.0 MHz. </td></tr>
    <tr><td class="paramname">bw</td><td>LoRa bandwidth in kHz. Defaults to 125.0 kHz. </td></tr>
    <tr><td class="paramname">sf</td><td>LoRa spreading factor. Defaults to 9. </td></tr>
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator. Defaults to 7 (coding rate 4/7). Allowed values range from 4 to 8. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC. </td></tr>
    <tr><td class="paramname">syncWord</td><td>1-byte LoRa sync word. Defaults to RADIOLIB_LR2021_LORA_SYNC_WORD_PRIVATE (0x12). </td></tr>
    <tr><td class="paramname">power</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>LoRa preamble length in symbols. Defaults to 8 symbols. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. Defaults to 1.6 V. If you are seeing -706/-707 error codes, it likely means you are using non-0 value for module with XTAL. To use XTAL, either set this value to 0, or set <a class="el" href="class_l_rxxxx.html#aedc6b7f69451ab79e05f5d9ff757fb20" title="Whether the module has an XTAL (true) or TCXO (false). Defaults to false.">LR2021::XTAL</a> to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a62b49d22917a9fe66398d544e0d91088" name="a62b49d22917a9fe66398d544e0d91088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b49d22917a9fe66398d544e0d91088">&#9670;&#160;</a></span>beginFLRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::beginFLRC </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>br</em> = <code>650</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em> = <code>RADIOLIB_LR2021_FLRC_CR_2_3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>pwr</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dataShaping</em> = <code><a class="el" href="group__config__shaping.html#gaa778d14c29d21fe329137a28a3f54a5d">RADIOLIB_SHAPING_0_5</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em> = <code>1.6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FLRC modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434.0 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>FLRC bit rate in kbps. Defaults to 650 kbps. </td></tr>
    <tr><td class="paramname">cr</td><td>FLRC coding rate. Defaults to RADIOLIB_LR2021_FLRC_CR_2_3 (coding rate 2/3). </td></tr>
    <tr><td class="paramname">pwr</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>FLRC preamble length in bits. Defaults to 16 bits. </td></tr>
    <tr><td class="paramname">dataShaping</td><td>Time-bandwidth product of the Gaussian filter to be used for shaping. Defaults to 0.5. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abc703d439acc814a69b14cbd16468e80" name="abc703d439acc814a69b14cbd16468e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc703d439acc814a69b14cbd16468e80">&#9670;&#160;</a></span>beginGFSK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::beginGFSK </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em> = <code>4.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em> = <code>153.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em> = <code>1.6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FSK modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434.0 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>FSK bit rate in kbps. Defaults to 4.8 kbps. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation from carrier frequency in kHz. Defaults to 5.0 kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Defaults to 153.8 kHz. </td></tr>
    <tr><td class="paramname">power</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>FSK preamble length in bits. Defaults to 16 bits. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. Defaults to 1.6 V. If you are seeing -706/-707 error codes, it likely means you are using non-0 value for module with XTAL. To use XTAL, either set this value to 0, or set <a class="el" href="class_l_rxxxx.html#aedc6b7f69451ab79e05f5d9ff757fb20" title="Whether the module has an XTAL (true) or TCXO (false). Defaults to false.">LR2021::XTAL</a> to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aa6d914ed14ec9d82faf65c7fba7a02b1" name="aa6d914ed14ec9d82faf65c7fba7a02b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d914ed14ec9d82faf65c7fba7a02b1">&#9670;&#160;</a></span>beginLRFHSS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::beginLRFHSS </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bw</em> = <code>RADIOLIB_LRXXXX_LR_FHSS_BW_722_66</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em> = <code>RADIOLIB_LRXXXX_LR_FHSS_CR_2_3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>narrowGrid</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em> = <code>1.6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for LR-FHSS modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434.0 MHz. </td></tr>
    <tr><td class="paramname">bw</td><td>LR-FHSS bandwidth, one of RADIOLIB_LRXXXX_LR_FHSS_BW_* values. Defaults to 722.66 kHz. </td></tr>
    <tr><td class="paramname">cr</td><td>LR-FHSS coding rate, one of RADIOLIB_LRXXXX_LR_FHSS_CR_* values. Defaults to 2/3 coding rate. </td></tr>
    <tr><td class="paramname">narrowGrid</td><td>Whether to use narrow (3.9 kHz) or wide (25.39 kHz) grid spacing. Defaults to true (narrow/non-FCC) grid. </td></tr>
    <tr><td class="paramname">power</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. Defaults to 1.6 V. If you are seeing -706/-707 error codes, it likely means you are using non-0 value for module with XTAL. To use XTAL, either set this value to 0, or set <a class="el" href="class_l_rxxxx.html#aedc6b7f69451ab79e05f5d9ff757fb20" title="Whether the module has an XTAL (true) or TCXO (false). Defaults to false.">LR2021::XTAL</a> to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab824e75ac4a6fcec1c9fbed298c1eeda" name="ab824e75ac4a6fcec1c9fbed298c1eeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab824e75ac4a6fcec1c9fbed298c1eeda">&#9670;&#160;</a></span>beginOOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::beginOOK </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>434.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em> = <code>4.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em> = <code>153.8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em> = <code>1.6</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for OOK modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434.0 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>OOK bit rate in kbps. Defaults to 4.8 kbps. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Defaults to 153.8 kHz. </td></tr>
    <tr><td class="paramname">power</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>OOK preamble length in bits. Defaults to 16 bits. </td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set. Defaults to 1.6 V. If you are seeing -706/-707 error codes, it likely means you are using non-0 value for module with XTAL. To use XTAL, either set this value to 0, or set <a class="el" href="class_l_rxxxx.html#aedc6b7f69451ab79e05f5d9ff757fb20" title="Whether the module has an XTAL (true) or TCXO (false). Defaults to false.">LR2021::XTAL</a> to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2271630945521d4a1eaa3a29dcffac1b" name="a2271630945521d4a1eaa3a29dcffac1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2271630945521d4a1eaa3a29dcffac1b">&#9670;&#160;</a></span>checkDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::checkDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em> = <code>RADIOLIB_MODEM_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the data rate can be configured by this module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. </td></tr>
    <tr><td class="paramname">modem</td><td>The modem corresponding to the requested datarate (FSK, LoRa or LR-FHSS). Defaults to currently active modem if not supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a9c5c902d9f8ffe9866b7f178b14d34f6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a39c82cdc7a22f252dfd36b2516ee7c49" name="a39c82cdc7a22f252dfd36b2516ee7c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c82cdc7a22f252dfd36b2516ee7c49">&#9670;&#160;</a></span>checkOutputPower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::checkOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>clipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power in dBm, PA will be determined automatically. </td></tr>
    <tr><td class="paramname">clipped</td><td>Clipped output power value to what is possible within the module's range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a21cee48cac6a64d518353aa2389f8074" name="a21cee48cac6a64d518353aa2389f8074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cee48cac6a64d518353aa2389f8074">&#9670;&#160;</a></span>clearIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::clearIrqFlags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>Module-specific IRQ flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ac282bb78da4f4da4661dce191cbd6d87">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2f586b966393cd54bdd885ea70dd1709" name="a2f586b966393cd54bdd885ea70dd1709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f586b966393cd54bdd885ea70dd1709">&#9670;&#160;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables address filtering. Calling this method will also erase previously set addresses. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a53cf216f8aee520a559b64cc03f61901" name="a53cf216f8aee520a559b64cc03f61901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cf216f8aee520a559b64cc03f61901">&#9670;&#160;</a></span>explicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::explicitHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set explicit header mode for future reception/transmission. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aabaa4984504bdd10ae75e0163c0871db" name="aabaa4984504bdd10ae75e0163c0871db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabaa4984504bdd10ae75e0163c0871db">&#9670;&#160;</a></span>finishReceive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::finishReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after reception is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8d8997a3fdeaede52d9354d3bf310bf4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a80bfd550e471626da5e8c6bab1e3f415" name="a80bfd550e471626da5e8c6bab1e3f415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bfd550e471626da5e8c6bab1e3f415">&#9670;&#160;</a></span>finishTransmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::finishTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after transmission is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1de26f68b939f5af79ec29cc34c7be18">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a934a871e6f92b290541fe975f6f32bae" name="a934a871e6f92b290541fe975f6f32bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a934a871e6f92b290541fe975f6f32bae">&#9670;&#160;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>RADIOLIB_LR2021_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. Available in GFSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5c8560915043a2c21892b51bc576ea73" name="a5c8560915043a2c21892b51bc576ea73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8560915043a2c21892b51bc576ea73">&#9670;&#160;</a></span>getChannelScanResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::getChannelScanResult </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the channel scan result. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a63979795a7b53557560bb95b65480906">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3ed89cc7405fc0e0157a146cb1aee07c" name="a3ed89cc7405fc0e0157a146cb1aee07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed89cc7405fc0e0157a146cb1aee07c">&#9670;&#160;</a></span>getIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t LR2021::getIrqFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read currently active IRQ flags. </p>
<dl class="section return"><dt>Returns</dt><dd>IRQ flags. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1caeed34b2e2ff0355467507106a1a2">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a8d7069e59abecae1e4b48de5920da4b3" name="a8d7069e59abecae1e4b48de5920da4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7069e59abecae1e4b48de5920da4b3">&#9670;&#160;</a></span>getModem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::getModem </td>
          <td>(</td>
          <td class="paramtype">ModemType_t *&#160;</td>
          <td class="paramname"><em>modem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get modem currently in use by the radio. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modem</td><td>Pointer to a variable to save the retrieved configuration into. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af061879bf694735297593c048d04a196">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aea734806d4056f8ea47b4f828bcf8b3b" name="aea734806d4056f8ea47b4f828bcf8b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea734806d4056f8ea47b4f828bcf8b3b">&#9670;&#160;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t LR2021::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2fe95169b5cdc8cabe1f2af66cad6ef6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a444ec095ed8bd08df909b3b1b899d35e" name="a444ec095ed8bd08df909b3b1b899d35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a444ec095ed8bd08df909b3b1b899d35e">&#9670;&#160;</a></span>getRSSI() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LR2021::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets recorded signal strength indicator. Overload with packet mode enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="section return"><dt>Returns</dt><dd>RSSI value in dBm. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a11674102f4d704d02d27eaceeaeccd35" name="a11674102f4d704d02d27eaceeaeccd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11674102f4d704d02d27eaceeaeccd35">&#9670;&#160;</a></span>getRSSI() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LR2021::getRSSI </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipReceive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets RSSI (Recorded Signal Strength Indicator). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packet</td><td>Whether to read last packet RSSI, or the current value. </td></tr>
    <tr><td class="paramname">skipReceive</td><td>Set to true to skip putting radio in receive mode for the RSSI measurement in FSK/OOK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RSSI value in dBm. </dd></dl>

</div>
</div>
<a id="addaf960d942fbff38c12ccb38b137122" name="addaf960d942fbff38c12ccb38b137122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaf960d942fbff38c12ccb38b137122">&#9670;&#160;</a></span>getSNR()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LR2021::getSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem. </p>
<dl class="section return"><dt>Returns</dt><dd>SNR of the last received packet in dB. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">PhysicalLayer</a>.</p>

</div>
</div>
<a id="afb35ae71215ecbaff2262887171cfd7f" name="afb35ae71215ecbaff2262887171cfd7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb35ae71215ecbaff2262887171cfd7f">&#9670;&#160;</a></span>getTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LR2021::getTemperature </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>13</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the temperature. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>Measurement source, one of RADIOLIB_LR2021_TEMP_SOURCE_* macros. </td></tr>
    <tr><td class="paramname">bits</td><td>Measurement resolution in bits, 8 to 13. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Temperature in degrees Celsius. </dd></dl>

</div>
</div>
<a id="a84cc2e14f141502bb3e3e2d082916cd0" name="a84cc2e14f141502bb3e3e2d082916cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cc2e14f141502bb3e3e2d082916cd0">&#9670;&#160;</a></span>getTimeOnAir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> LR2021::getTimeOnAir </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get expected time-on-air for a given size of payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expected time-on-air in microseconds. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>[<a class="el" href="class_l_r2021.html">LR2021</a>] Add FLRC to the modems supported in ModemType_t </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a50e730a894f60b58034507ad7730dd3c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa3bac7d26814507e56ee90d3dc6fd77a" name="aa3bac7d26814507e56ee90d3dc6fd77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bac7d26814507e56ee90d3dc6fd77a">&#9670;&#160;</a></span>getVoltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float LR2021::getVoltage </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>13</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the supply voltage on the Vbat pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bits</td><td>Measurement resolution in bits, 8 to 13. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Supply voltage in volts. </dd></dl>

</div>
</div>
<a id="acf55c538925942546916a1ee2be075d8" name="acf55c538925942546916a1ee2be075d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf55c538925942546916a1ee2be075d8">&#9670;&#160;</a></span>implicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::implicitHeader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set implicit header mode for future reception/transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6f382f3585b68e5329e7392a3026acb5" name="a6f382f3585b68e5329e7392a3026acb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f382f3585b68e5329e7392a3026acb5">&#9670;&#160;</a></span>invertIQ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::invertIQ </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/disable inversion of the I and Q signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>IQ inversion enabled (true) or disabled (false); </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a11b4c6d0bf3ae7b9ca04e9434180feab">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6d4ebe0b2af4604494a44ccd650fb137" name="a6d4ebe0b2af4604494a44ccd650fb137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4ebe0b2af4604494a44ccd650fb137">&#9670;&#160;</a></span>launchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::launchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Launch previously staged mode.   </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a>   </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a5c5977bc9f54f21665b022a99e6c87cc">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af4aaffbca82fd163c09e004d9df205f1" name="af4aaffbca82fd163c09e004d9df205f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4aaffbca82fd163c09e004d9df205f1">&#9670;&#160;</a></span>ookDetector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::ookDetector </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pattern</em> = <code>0x0285</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>repeats</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncRaw</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rising</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sofLen</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OOK detector properties. The default values are set to allow ADS-B reception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>Preamble pattern, should end with 01 or 10 (binary). </td></tr>
    <tr><td class="paramname">len</td><td>Preamble pattern length in bits. </td></tr>
    <tr><td class="paramname">repeats</td><td>Number of preamble repeats, maximum of 31. </td></tr>
    <tr><td class="paramname">syncRaw</td><td>Whether the sync word is send raw (unencoded) or encoded. Set to false for encoded sync word. </td></tr>
    <tr><td class="paramname">rising</td><td>Whether the start of frame delimiter edge is rising (true) or falling (false). </td></tr>
    <tr><td class="paramname">sofLen</td><td>Start-of-frame length in bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aefcca6fe60ef562616d08318663bbb3d" name="aefcca6fe60ef562616d08318663bbb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcca6fe60ef562616d08318663bbb3d">&#9670;&#160;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t LR2021::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3563453988a83d22dd07d4691543a300" name="a3563453988a83d22dd07d4691543a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563453988a83d22dd07d4691543a300">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0d318b6eca634bccf74b99a493b32236" name="a0d318b6eca634bccf74b99a493b32236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d318b6eca634bccf74b99a493b32236">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae608fabef91defa1e33e6a6787c68ce8" name="ae608fabef91defa1e33e6a6787c68ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae608fabef91defa1e33e6a6787c68ce8">&#9670;&#160;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Packet length, needed for some modules under special circumstances (e.g. LoRa implicit header mode). </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a08aa09fca3c2e895d0bf8fee166b6778" name="a08aa09fca3c2e895d0bf8fee166b6778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aa09fca3c2e895d0bf8fee166b6778">&#9670;&#160;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] taken from <a class="el" href="class_s_x126x.html" title="Base class for SX126x series. All derived classes for SX126x (e.g. SX1262 or SX1268) inherit from thi...">SX126x</a>, does this really work?</p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1bea897ee70fc8c4d8f311d97871195b" name="a1bea897ee70fc8c4d8f311d97871195b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bea897ee70fc8c4d8f311d97871195b">&#9670;&#160;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as <a class="el" href="class_l_r2021.html">LR2021</a> does not support direct mode reception. Will always return RADIOLIB_ERR_UNKNOWN. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad9d1dbb2041e87af5a80e12f125a60e6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3a8e79cd860d03edbb6c38ca4e62b8fc" name="a3a8e79cd860d03edbb6c38ca4e62b8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a8e79cd860d03edbb6c38ca4e62b8fc">&#9670;&#160;</a></span>scanChannel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::scanChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scan for LoRa transmission in the current channel. Detects both preamble and payload. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abd9e39cc745acbf084cfa0d3f4d10718">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a80fbe7fbdc6cd06e068b8cfa72cf5fc9" name="a80fbe7fbdc6cd06e068b8cfa72cf5fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fbe7fbdc6cd06e068b8cfa72cf5fc9">&#9670;&#160;</a></span>scanChannel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::scanChannel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs scan for LoRa transmission in the current channel. Detects both preamble and payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>CAD configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af788cf83ceb0222cd0fa4a1323b9041b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a722b8a19894aa26c4ca6d880f1211298" name="a722b8a19894aa26c4ca6d880f1211298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722b8a19894aa26c4ca6d880f1211298">&#9670;&#160;</a></span>setBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa bandwidth. Allowed values are 31.25, 41.67, 62.5, 83.34, 125.0, 101.56, 203.13, 250.0, 406.25, 500.0 kHz, 812.5 kHz and 1000.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a07413158d09efd4e4d91046a1d1245a6" name="a07413158d09efd4e4d91046a1d1245a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07413158d09efd4e4d91046a1d1245a6">&#9670;&#160;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK bit rate. Allowed values range from 0.5 to 2000.0 kbps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>FSK bit rate to be set in kbps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] implement fractional bit rate configuration</p>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] implement fractional bit rate configuration</p>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] implement OOK magnitude depth configuration</p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3906c62ff40c1f7871ab92c1573d9042" name="a3906c62ff40c1f7871ab92c1573d9042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3906c62ff40c1f7871ab92c1573d9042">&#9670;&#160;</a></span>setBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setBroadcastAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>broadAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadAddr</td><td>Node address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a49d0db140307e3e0d7bd31641fe0d5fe" name="a49d0db140307e3e0d7bd31641fe0d5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d0db140307e3e0d7bd31641fe0d5fe">&#9670;&#160;</a></span>setCodingRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setCodingRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>longInterleave</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa coding rate denominator. Allowed values range from 4 to 8. Note that a value of 4 means no coding, is undocumented and not recommended without your own FEC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator to be set. </td></tr>
    <tr><td class="paramname">longInterleave</td><td>Enable long interleaver when set to true. Note that with long interleaver enabled, CR 4/7 is not possible, there are packet length restrictions, and it is not compatible with <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> radios! </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a508d4b44df2968fee363102c3fa528fc" name="a508d4b44df2968fee363102c3fa528fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508d4b44df2968fee363102c3fa528fc">&#9670;&#160;</a></span>setCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setCRC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x00001D0FUL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>polynomial</em> = <code>0x00001021UL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets CRC configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>CRC length in bytes, Allowed values are 1 or 2, set to 0 to disable CRC. </td></tr>
    <tr><td class="paramname">initial</td><td>Initial CRC value. GFSK only. Defaults to 0x1D0F (CCITT CRC). </td></tr>
    <tr><td class="paramname">polynomial</td><td>Polynomial for CRC calculation. GFSK only. Defaults to 0x1021 (CCITT CRC). </td></tr>
    <tr><td class="paramname">inverted</td><td>Invert CRC bytes. GFSK only. Defaults to true (CCITT CRC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a225430eeb1ef175c3920b19e8fd00937" name="a225430eeb1ef175c3920b19e8fd00937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225430eeb1ef175c3920b19e8fd00937">&#9670;&#160;</a></span>setDataRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setDataRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_data_rate__t.html">DataRate_t</a>&#160;</td>
          <td class="paramname"><em>dr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em> = <code>RADIOLIB_MODEM_NONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set data rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dr</td><td>Data rate struct. </td></tr>
    <tr><td class="paramname">modem</td><td>The modem corresponding to the requested datarate (FSK, LoRa or LR-FHSS). Defaults to currently active modem if not supplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ac5f1e0c24d8bf878f2c9fe729b6e1610">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a99bda2205aacb19befd05f5bdd021a65" name="a99bda2205aacb19befd05f5bdd021a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bda2205aacb19befd05f5bdd021a65">&#9670;&#160;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Time-bandwidth product of Gaussian filter to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6a65db5e1dbe5f3ff72021e4acad6c40" name="a6a65db5e1dbe5f3ff72021e4acad6c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a65db5e1dbe5f3ff72021e4acad6c40">&#9670;&#160;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Available in GFSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. Set to 0 for NRZ, and 2 for whitening. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acb45b2342400a03a914a91d2ac7fb488">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a602ba1f6b66b263f84ccd0a73f15381c" name="a602ba1f6b66b263f84ccd0a73f15381c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602ba1f6b66b263f84ccd0a73f15381c">&#9670;&#160;</a></span>setFrequency() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets carrier frequency. Allowed values are in range from 150.0 to 960.0 MHz, 1900 - 2200 MHz and 2400 - 2500 MHz. Will automatically perform image calibration if the frequency changes by more than RADIOLIB_LR2021_CAL_IMG_FREQ_TRIG MHz. NOTE: When switching between sub-GHz and high-frequency bands, after changing the frequency, <a class="el" href="class_l_r2021.html#aca2599a31c088a5e8c59317ae132d4d0" title="Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-...">setOutputPower()</a> must be called in order to set the correct power amplifier! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency to be set in MHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0e05f34bffa00c64b03cb1ec05951929" name="a0e05f34bffa00c64b03cb1ec05951929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e05f34bffa00c64b03cb1ec05951929">&#9670;&#160;</a></span>setFrequency() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipCalibration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets carrier frequency. Allowed values are in range from 150.0 to 960.0 MHz, 1900 - 2200 MHz and 2400 - 2500 MHz. Will automatically perform image calibration if the frequency changes by more than RADIOLIB_LR2021_CAL_IMG_FREQ_TRIG MHz. NOTE: When switching between sub-GHz and high-frequency bands, after changing the frequency, <a class="el" href="class_l_r2021.html#aca2599a31c088a5e8c59317ae132d4d0" title="Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-...">setOutputPower()</a> must be called in order to set the correct power amplifier! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency to be set in MHz. </td></tr>
    <tr><td class="paramname">skipCalibration</td><td>Skip automated image calibration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae038b9716d7d59a7c9dcb285e5ff34f5" name="ae038b9716d7d59a7c9dcb285e5ff34f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae038b9716d7d59a7c9dcb285e5ff34f5">&#9670;&#160;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK frequency deviation. Allowed values range from 0.6 to 500.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>GFSK frequency deviation to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2f4f9b428d9ea9af886ca85e5088ed7b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a874b2522d4b296505278d943df308a99" name="a874b2522d4b296505278d943df308a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874b2522d4b296505278d943df308a99">&#9670;&#160;</a></span>setGain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setGain </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>gain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets gain of receiver LNA (low-noise amplifier). Can be set to any integer in range 1 to 13, where 13 is the highest gain. Set to 0 to enable automatic gain control (recommended). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gain</td><td>Gain of receiver LNA (low-noise amplifier) to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af2f977f788bc15e396dcb6025987c513" name="af2f977f788bc15e396dcb6025987c513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f977f788bc15e396dcb6025987c513">&#9670;&#160;</a></span>setIrqFlags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setIrqFlags </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irq</td><td>Module-specific IRQ flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af88dcb54dc8e9a1edaf9f1c3e5ee2b74">PhysicalLayer</a>.</p>

</div>
</div>
<a id="afc9eef45712d5daae3c0a38e7dfd5d73" name="afc9eef45712d5daae3c0a38e7dfd5d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9eef45712d5daae3c0a38e7dfd5d73">&#9670;&#160;</a></span>setLrFhssConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setLrFhssConfig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>hdrCount</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>hopSeed</em> = <code>0x13A</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LR-FHSS configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LR-FHSS bandwidth, one of RADIOLIB_LRXXXX_LR_FHSS_BW_* values. </td></tr>
    <tr><td class="paramname">cr</td><td>LR-FHSS coding rate, one of RADIOLIB_LRXXXX_LR_FHSS_CR_* values. </td></tr>
    <tr><td class="paramname">hdrCount</td><td>Header packet count, 1 - 4. Defaults to 3. </td></tr>
    <tr><td class="paramname">hopSeed</td><td>9-bit seed number for PRNG generation of the hopping sequence. Defaults to 0x13A. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab8923a4d2a3cf8a7834ae6c53c6d3eb0" name="ab8923a4d2a3cf8a7834ae6c53c6d3eb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8923a4d2a3cf8a7834ae6c53c6d3eb0">&#9670;&#160;</a></span>setModem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setModem </td>
          <td>(</td>
          <td class="paramtype">ModemType_t&#160;</td>
          <td class="paramname"><em>modem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modem</td><td>Modem type to set - FSK, LoRa or LR-FHSS. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a77415bf4ed34be18c92c0cf4b2de7149">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abecc461944b46e15a4573288a752a4c2" name="abecc461944b46e15a4573288a752a4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecc461944b46e15a4573288a752a4c2">&#9670;&#160;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets node address. Calling this method will also enable address filtering for node address only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a4e88077f2e75c598e0ca820196d7ed9d" name="a4e88077f2e75c598e0ca820196d7ed9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e88077f2e75c598e0ca820196d7ed9d">&#9670;&#160;</a></span>setOokDetectionThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setOokDetectionThreshold </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set OOK detection threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Threshold level in dB </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aca2599a31c088a5e8c59317ae132d4d0" name="aca2599a31c088a5e8c59317ae132d4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2599a31c088a5e8c59317ae132d4d0">&#9670;&#160;</a></span>setOutputPower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-frequency PA). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power to be set in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2d38e9fa1f3250d78482c8fb755f22a2" name="a2d38e9fa1f3250d78482c8fb755f22a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d38e9fa1f3250d78482c8fb755f22a2">&#9670;&#160;</a></span>setOutputPower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rampTimeUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets output power. Allowed values are in range from -9 to 22 dBm (sub-GHz PA) or -19 to 12 dBm (high-frequency PA). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power to be set in dBm. </td></tr>
    <tr><td class="paramname">rampTimeUs</td><td>PA power ramping time in microseconds. Provided value is rounded up to the nearest discrete ramp time supported by the PA. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] how and when to configure OCP? \TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] Determine the optimal PA configuration</p>

</div>
</div>
<a id="abfe825d8bf2bf526058914bf99b71a92" name="abfe825d8bf2bf526058914bf99b71a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe825d8bf2bf526058914bf99b71a92">&#9670;&#160;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>preambleLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets preamble length for LoRa or GFSK modem. Allowed values range from 1 to 65535. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set in symbols (LoRa) or bits (GFSK). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a85db1ff64e6c56e054f276c511194633">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab2cb23b1f2dbdcd53a140b8a53d7e776" name="ab2cb23b1f2dbdcd53a140b8a53d7e776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2cb23b1f2dbdcd53a140b8a53d7e776">&#9670;&#160;</a></span>setRfSwitchTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LR2021::setRfSwitchTable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>pins</em>[Module::RFSWITCH_MAX_PINS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.   </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pins</td><td>A reference to an array of pins to control. This should always be an array of 3 elements. If you need less pins, use RADIOLIB_NC for the unused elements.</td></tr>
    <tr><td class="paramname">table</td><td>A reference to an array of pin values to use for each supported mode. Each element is an RfSwitchMode_T struct that lists the mode for which it applies and the values for each of the pins passed in the pins argument respectively.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>pins</code> array will be copied into the <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> object, so the original array can be deallocated after this call. However, a reference to the <code>table</code> array will be stored, so that array must remain valid as long RadioLib is being used.</p>
<p>The <code>mode</code> field in each table row should normally use any of the <code>MODE_*</code> constants from the <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf" title="Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios,...">Module::OpMode_t</a> enum. However, some radios support additional modes and will define their own OpMode_t enum.</p>
<p>The length of the table is variable (to support radios that add additional modes), so the table must always be terminated with the special END_OF_MODE_TABLE value.</p>
<p>Normally all modes should be listed in the table, but for some radios, modes can be omitted to indicate they are not supported (e.g. when a radio has a high power and low power TX mode but external circuitry only supports low power). If applicable, this is documented in the radio class itself.</p>
<h4>Example</h4>
<p>For example, on a board that has an RF switch with an enable pin connected to PA0 and a TX/RX select pin connected to PA1:</p>
<div class="fragment"><div class="line"><span class="comment">// In global scope, define the pin array and mode table</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t rfswitch_pins[] =</div>
<div class="line">                       {PA0,  PA1,  RADIOLIB_NC};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> rfswitch_table[] = {</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a>,  {LOW,  LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a>,    {HIGH, LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a>,    {HIGH, HIGH}},</div>
<div class="line">   Module::END_OF_MODE_TABLE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Then somewhere in setup, pass them to radiolib</span></div>
<div class="line">  radio.setRfSwitchTable(rfswitch_pins, rfswitch_table);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a></div><div class="ttdeci">@ MODE_TX</div><div class="ttdoc">Transmission mode.</div><div class="ttdef"><b>Definition</b> Module.h:119</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a></div><div class="ttdeci">@ MODE_IDLE</div><div class="ttdoc">Idle mode.</div><div class="ttdef"><b>Definition</b> Module.h:113</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a></div><div class="ttdeci">@ MODE_RX</div><div class="ttdoc">Receive mode.</div><div class="ttdef"><b>Definition</b> Module.h:116</div></div>
<div class="ttc" id="astruct_module_1_1_rf_switch_mode__t_html"><div class="ttname"><a href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a></div><div class="ttdoc">Description of RF switch pin states for a single mode. See setRfSwitchTable for details.</div><div class="ttdef"><b>Definition</b> Module.h:89</div></div>
</div><!-- fragment -->   
</div>
</div>
<a id="a0af2e7efeb46334e528f691e6e03b564" name="a0af2e7efeb46334e528f691e6e03b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af2e7efeb46334e528f691e6e03b564">&#9670;&#160;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GFSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>GFSK receiver bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ad3a71766e8fa71dc9224006b580de8f9" name="ad3a71766e8fa71dc9224006b580de8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a71766e8fa71dc9224006b580de8f9">&#9670;&#160;</a></span>setRxBoostedGainMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setRxBoostedGainMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables Rx Boosted Gain mode (additional Rx gain for increased power consumption). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">level</td><td>Rx gain boost level. 0 (disabled) to 7 (maximum boost). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aca2d2d22e793e32c50efd5f01881979e" name="aca2d2d22e793e32c50efd5f01881979e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2d2d22e793e32c50efd5f01881979e">&#9670;&#160;</a></span>setSideDetector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setSideDetector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_l_r2021_lo_ra_side_detector__t.html">LR2021LoRaSideDetector_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numDetectors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure LoRa side detector, which enables to detect mutiple spreading factors and receive one of them. The following limitations apply: In Rx mode, all side-detector spreading factors must be higher than the primary one (configured via begin or setSpreadingFactor) For CAD mode, the above condition is inverted - all side-detector spreading factors must be smaller All packets to be detected must have the same header type (implicit or explicit) If bandwidth is higher than 500 kHz, at most 2 side detectors are allowed. If the primary spreading factor is 10, 11 or 12, at most 2 side detectors are allowed. All spreading factors must be different. The difference between maximum and minimum spreading factor used must be less than or equal to 4. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cfg</td><td>Pointer to an array of side detector configuration structures. Set to null to disable all side detectors. </td></tr>
    <tr><td class="paramname">numDetectors</td><td>Number of side detectors to configure. Maximum of 3, set to 0 to to disable all side detectors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>[<a class="el" href="class_l_r2021.html">LR2021</a>] implement multi-SF for CAD (main SF must be smallest!) </dd></dl>

</div>
</div>
<a id="aca6e0999997105037967da5e571c0b29" name="aca6e0999997105037967da5e571c0b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6e0999997105037967da5e571c0b29">&#9670;&#160;</a></span>setSpreadingFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setSpreadingFactor </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>legacy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa spreading factor. Allowed values range from 5 to 12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>LoRa spreading factor to be set. </td></tr>
    <tr><td class="paramname">legacy</td><td>Enable legacy mode for SF6 - this allows to communicate with <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> at SF6. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] enable SF6 legacy mode</p>

</div>
</div>
<a id="ab67fef9d1e4719d51871100e058be93d" name="ab67fef9d1e4719d51871100e058be93d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67fef9d1e4719d51871100e058be93d">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets GFSK sync word in the form of array of up to 8 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>GFSK sync word to be set. </td></tr>
    <tr><td class="paramname">len</td><td>GFSK sync word length in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a6c71cdc1238e1368274670758431a977">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0792e44750e268eb38c3c2f28b13455a" name="a0792e44750e268eb38c3c2f28b13455a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0792e44750e268eb38c3c2f28b13455a">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>LoRa sync word to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2c2a421e4a6308a24166a23ff50e613c" name="a2c2a421e4a6308a24166a23ff50e613c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a421e4a6308a24166a23ff50e613c">&#9670;&#160;</a></span>setTCXO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setTCXO </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>1000000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TCXO (Temperature Compensated Crystal Oscillator) configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltage</td><td>TCXO reference voltage in volts. Allowed values are 1.6, 1.7, 1.8, 2.2. 2.4, 2.7, 3.0 and 3.3 V. Set to 0 to disable TCXO. NOTE: After setting this parameter to 0, the module will be reset (since there's no other way to disable TCXO). </td></tr>
    <tr><td class="paramname">delay</td><td>TCXO timeout in us. Defaults to 1000000 (1 second), because especially on the first startup, this delay may be measured very inaccurately. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7d641cb6dc009ab1999fe4e68e2aea97" name="a7d641cb6dc009ab1999fe4e68e2aea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d641cb6dc009ab1999fe4e68e2aea97">&#9670;&#160;</a></span>setWhitening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::setWhitening </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x01FF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets GFSK whitening parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True = Whitening enabled </td></tr>
    <tr><td class="paramname">initial</td><td>Initial value used for the whitening LFSR in GFSK mode. By default set to 0x01FF for compatibility with <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> and LoRaWAN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] Implement SX128x-compatible whitening</p>
<p>\TODO: [<a class="el" href="class_l_r2021.html">LR2021</a>] Implement configurable index and polynomial</p>

</div>
</div>
<a id="a0e54c607b9c6e19406abc9f8ad29a817" name="a0e54c607b9c6e19406abc9f8ad29a817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e54c607b9c6e19406abc9f8ad29a817">&#9670;&#160;</a></span>sleep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r2021.html#ab065a956b2fcc17169b5c228dc66b8c0" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>. Overload with warm start enabled for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ade792fc1fdac2a5b68d76267cd24833f" name="ade792fc1fdac2a5b68d76267cd24833f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade792fc1fdac2a5b68d76267cd24833f">&#9670;&#160;</a></span>sleep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sleepTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to sleep mode. To wake the device up, call <a class="el" href="class_l_r2021.html#ab065a956b2fcc17169b5c228dc66b8c0" title="Sets the module to standby mode (overload for PhysicalLayer compatibility, uses 13 MHz RC oscillator)...">standby()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retainConfig</td><td>Set to true to retain configuration of the currently active modem ("warm start") or to false to discard current configuration ("cold start"). Defaults to true. </td></tr>
    <tr><td class="paramname">sleepTime</td><td>Sleep duration (enables automatic wakeup), in multiples of 30.52 us. Ignored if set to 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adf7fa49b2245a3dfc3613bfcac4a249e" name="adf7fa49b2245a3dfc3613bfcac4a249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7fa49b2245a3dfc3613bfcac4a249e">&#9670;&#160;</a></span>stageMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::stageMode </td>
          <td>(</td>
          <td class="paramtype">RadioModeType_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stage mode of the radio to be launched later using launchMode.   </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Radio mode to prepare. </td></tr>
    <tr><td class="paramname">cfg</td><td>Configuration of this mode (mode-dependent). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a>   </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>[<a class="el" href="class_l_r2021.html">LR2021</a>] implement GFSK address filtering </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>[<a class="el" href="class_l_r2021.html">LR2021</a>] add configurable LR-FHSS device offset </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a06fa3b844c6028a78e29b7dff58c7c79">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab065a956b2fcc17169b5c228dc66b8c0" name="ab065a956b2fcc17169b5c228dc66b8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab065a956b2fcc17169b5c228dc66b8c0">&#9670;&#160;</a></span>standby() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acbcaf6aefcb77a354797e66222fe5018">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a1c1f96d15e812fe61f5be741d3a47c38" name="a1c1f96d15e812fe61f5be741d3a47c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1f96d15e812fe61f5be741d3a47c38">&#9670;&#160;</a></span>standby() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator to be used in standby mode. Can be set to RADIOLIB_LR2021_STANDBY_RC (13 MHz RC oscillator) or RADIOLIB_LR2021_STANDBY_XOSC (32 MHz external crystal oscillator). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5016d7784e0204cf0cac1794c05e9f55" name="a5016d7784e0204cf0cac1794c05e9f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5016d7784e0204cf0cac1794c05e9f55">&#9670;&#160;</a></span>standby() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wakeup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator to be used in standby mode. Can be set to RADIOLIB_LR2021_STANDBY_RC (13 MHz RC oscillator) or RADIOLIB_LR2021_STANDBY_XOSC (32 MHz external crystal oscillator). </td></tr>
    <tr><td class="paramname">wakeup</td><td>Whether to force the module to wake up. Setting to true will immediately attempt to wake up the module. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a669f66069b12d1363789b39af363c68c" name="a669f66069b12d1363789b39af363c68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669f66069b12d1363789b39af363c68c">&#9670;&#160;</a></span>startChannelScan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::startChannelScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven channel activity detection method. IRQ1 will be activated when LoRa preamble is detected, or upon timeout. Defaults to CAD parameter values recommended by AN1200.48. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae30dfbb5445bb674898fc54f5f90b2f9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abcf00a7bf608444bc290913ed149ce7c" name="abcf00a7bf608444bc290913ed149ce7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf00a7bf608444bc290913ed149ce7c">&#9670;&#160;</a></span>startChannelScan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::startChannelScan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven channel activity detection method. IRQ pin will be activated when LoRa preamble is detected, or upon timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>CAD configuration structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a82a52062d9259c2c546d7bf8072b7a72">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a18664ad615c5507ff1690baaca90b094" name="a18664ad615c5507ff1690baaca90b094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18664ad615c5507ff1690baaca90b094">&#9670;&#160;</a></span>startReceive() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets module to received mode using its default configuration. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad0cb9a1ec4f8ffb323f32a48a477b150" name="ad0cb9a1ec4f8ffb323f32a48a477b150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cb9a1ec4f8ffb323f32a48a477b150">&#9670;&#160;</a></span>startReceive() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method with default parameters. Implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae93500dfbcfd39837e04c0f3eaa40d97" name="ae93500dfbcfd39837e04c0f3eaa40d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93500dfbcfd39837e04c0f3eaa40d97">&#9670;&#160;</a></span>startReceive() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a>&#160;</td>
          <td class="paramname"><em>irqFlags</em> = <code>RADIOLIB_IRQ_RX_DEFAULT_FLAGS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a>&#160;</td>
          <td class="paramname"><em>irqMask</em> = <code>RADIOLIB_IRQ_RX_DEFAULT_MASK</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. A DIO pin will be activated when full packet is received. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Raw timeout value. Some modules use this argument to specify operation mode (single vs. continuous receive). </td></tr>
    <tr><td class="paramname">irqFlags</td><td>Sets the IRQ flags. </td></tr>
    <tr><td class="paramname">irqMask</td><td>Sets the mask of IRQ flags that will trigger the radio interrupt pin. </td></tr>
    <tr><td class="paramname">len</td><td>Packet length, needed for some modules under special circumstances (e.g. LoRa implicit header mode). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae93500dfbcfd39837e04c0f3eaa40d97">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27" name="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&#160;</a></span>startTransmit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af79757dbbd62e080c1bad2e608ab940c" name="af79757dbbd62e080c1bad2e608ab940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79757dbbd62e080c1bad2e608ab940c">&#9670;&#160;</a></span>startTransmit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af79757dbbd62e080c1bad2e608ab940c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534" name="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&#160;</a></span>transmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ada508497ee2e70170da3afe078e2fe0e" name="ada508497ee2e70170da3afe078e2fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada508497ee2e70170da3afe078e2fe0e">&#9670;&#160;</a></span>transmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a8126dd09cf4c51eabcf7f72dc03b068d" name="a8126dd09cf4c51eabcf7f72dc03b068d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8126dd09cf4c51eabcf7f72dc03b068d">&#9670;&#160;</a></span>transmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a670691f6a40a82f2e6b25e90c4200f57" name="a670691f6a40a82f2e6b25e90c4200f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670691f6a40a82f2e6b25e90c4200f57">&#9670;&#160;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>Raw RF frequency value. Defaults to 0, required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aa4c99ac794ee653c2061be4201724b65">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a68728e2b6347b49bae942a9360f40988" name="a68728e2b6347b49bae942a9360f40988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68728e2b6347b49bae942a9360f40988">&#9670;&#160;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t LR2021::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>RADIOLIB_LR2021_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. Available in GFSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLen</td><td>Maximum packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/LR2021/<a class="el" href="_l_r2021_8h_source.html">LR2021.h</a></li>
<li>src/modules/LR2021/<b>LR2021.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_chip_control.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_flrc.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_gfsk.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_lora.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_misc.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_ook.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_oqpsk.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_radio.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_cmds_ranging.cpp</b></li>
<li>src/modules/LR2021/<b>LR2021_config.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_l_r2021.html">LR2021</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
