<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: CC1101 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_c_c1101.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_c_c1101-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CC1101 Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Control class for CC1101 module.  
 <a href="class_c_c1101.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_c1101_8h_source.html">CC1101.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CC1101:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_c_c1101.png" usemap="#CC1101_map" alt=""/>
  <map id="CC1101_map" name="CC1101_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="0,0,93,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6807e4254c4b55fa8d393b2bf8f2db3e" id="r_a6807e4254c4b55fa8d393b2bf8f2db3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6807e4254c4b55fa8d393b2bf8f2db3e">CC1101</a> (<a class="el" href="class_module.html">Module</a> *module)</td></tr>
<tr class="memdesc:a6807e4254c4b55fa8d393b2bf8f2db3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <br /></td></tr>
<tr class="separator:a6807e4254c4b55fa8d393b2bf8f2db3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86f23bb3d113d20f6238a671f18b565" id="r_ad86f23bb3d113d20f6238a671f18b565"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad86f23bb3d113d20f6238a671f18b565">begin</a> (float freq=RADIOLIB_CC1101_DEFAULT_FREQ, float br=RADIOLIB_CC1101_DEFAULT_BR, float freqDev=RADIOLIB_CC1101_DEFAULT_FREQDEV, float rxBw=RADIOLIB_CC1101_DEFAULT_RXBW, int8_t pwr=RADIOLIB_CC1101_DEFAULT_POWER, uint8_t preambleLength=RADIOLIB_CC1101_DEFAULT_PREAMBLELEN)</td></tr>
<tr class="memdesc:ad86f23bb3d113d20f6238a671f18b565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method.  <br /></td></tr>
<tr class="separator:ad86f23bb3d113d20f6238a671f18b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff1ff2e763a3ad598bdae535595db63" id="r_afff1ff2e763a3ad598bdae535595db63"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#afff1ff2e763a3ad598bdae535595db63">beginFSK4</a> (float freq=RADIOLIB_CC1101_DEFAULT_FREQ, float br=RADIOLIB_CC1101_DEFAULT_BR, float freqDev=RADIOLIB_CC1101_DEFAULT_FREQDEV, float rxBw=RADIOLIB_CC1101_DEFAULT_RXBW, int8_t pwr=RADIOLIB_CC1101_DEFAULT_POWER, uint8_t preambleLength=RADIOLIB_CC1101_DEFAULT_PREAMBLELEN)</td></tr>
<tr class="memdesc:afff1ff2e763a3ad598bdae535595db63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for 4-FSK modulation.  <br /></td></tr>
<tr class="separator:afff1ff2e763a3ad598bdae535595db63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc87275c6f5d7f6927ca51a175eba21" id="r_a1fc87275c6f5d7f6927ca51a175eba21"><td class="memItemLeft" align="right" valign="top"><a id="a1fc87275c6f5d7f6927ca51a175eba21" name="a1fc87275c6f5d7f6927ca51a175eba21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()</td></tr>
<tr class="memdesc:a1fc87275c6f5d7f6927ca51a175eba21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method - resets the chip using manual reset sequence (without RESET pin). <br /></td></tr>
<tr class="separator:a1fc87275c6f5d7f6927ca51a175eba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5086eb8a27aa842e94d1df54f385c39b" id="r_a5086eb8a27aa842e94d1df54f385c39b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5086eb8a27aa842e94d1df54f385c39b">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a5086eb8a27aa842e94d1df54f385c39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a5086eb8a27aa842e94d1df54f385c39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2" id="r_a4a7e12ef1eb2aaf9a5f39eeaa114e9f2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a4a7e12ef1eb2aaf9a5f39eeaa114e9f2">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0) override</td></tr>
<tr class="memdesc:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a4a7e12ef1eb2aaf9a5f39eeaa114e9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7612bf81e48086004c62548de2682266" id="r_a7612bf81e48086004c62548de2682266"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a7612bf81e48086004c62548de2682266">standby</a> () override</td></tr>
<tr class="memdesc:a7612bf81e48086004c62548de2682266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <br /></td></tr>
<tr class="separator:a7612bf81e48086004c62548de2682266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af374ad0ecd820a01baef7d177a30132a" id="r_af374ad0ecd820a01baef7d177a30132a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af374ad0ecd820a01baef7d177a30132a">standby</a> (uint8_t mode) override</td></tr>
<tr class="memdesc:af374ad0ecd820a01baef7d177a30132a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby.  <br /></td></tr>
<tr class="separator:af374ad0ecd820a01baef7d177a30132a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ead6224d4378274df465f779199bc92" id="r_a0ead6224d4378274df465f779199bc92"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0ead6224d4378274df465f779199bc92">sleep</a> () override</td></tr>
<tr class="memdesc:a0ead6224d4378274df465f779199bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode.  <br /></td></tr>
<tr class="separator:a0ead6224d4378274df465f779199bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240eef8fa7d838d76f3c11086dc50e46" id="r_a240eef8fa7d838d76f3c11086dc50e46"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a240eef8fa7d838d76f3c11086dc50e46">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:a240eef8fa7d838d76f3c11086dc50e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts synchronous direct mode transmission.  <br /></td></tr>
<tr class="separator:a240eef8fa7d838d76f3c11086dc50e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab053c185330519d58f364790108d29ac" id="r_ab053c185330519d58f364790108d29ac"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab053c185330519d58f364790108d29ac">receiveDirect</a> () override</td></tr>
<tr class="memdesc:ab053c185330519d58f364790108d29ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts synchronous direct mode reception.  <br /></td></tr>
<tr class="separator:ab053c185330519d58f364790108d29ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7c152858537a40e71cf133962cb893" id="r_aef7c152858537a40e71cf133962cb893"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aef7c152858537a40e71cf133962cb893">transmitDirectAsync</a> (uint32_t frf=0)</td></tr>
<tr class="memdesc:aef7c152858537a40e71cf133962cb893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts asynchronous direct mode transmission.  <br /></td></tr>
<tr class="separator:aef7c152858537a40e71cf133962cb893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec1ff1312d2caaae7e3e0389268fca2" id="r_a9ec1ff1312d2caaae7e3e0389268fca2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9ec1ff1312d2caaae7e3e0389268fca2">receiveDirectAsync</a> ()</td></tr>
<tr class="memdesc:a9ec1ff1312d2caaae7e3e0389268fca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts asynchronous direct mode reception.  <br /></td></tr>
<tr class="separator:a9ec1ff1312d2caaae7e3e0389268fca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f6978c757b0dd73e3ef98164a735a2" id="r_a38f6978c757b0dd73e3ef98164a735a2"><td class="memItemLeft" align="right" valign="top"><a id="a38f6978c757b0dd73e3ef98164a735a2" name="a38f6978c757b0dd73e3ef98164a735a2"></a>
int16_t&#160;</td><td class="memItemRight" valign="bottom"><b>packetMode</b> ()</td></tr>
<tr class="memdesc:a38f6978c757b0dd73e3ef98164a735a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops direct mode. It is required to call this method to switch from direct transmissions to packet-based transmissions. <br /></td></tr>
<tr class="separator:a38f6978c757b0dd73e3ef98164a735a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bee13612cf4da067faeb57d18ee2eb7" id="r_a9bee13612cf4da067faeb57d18ee2eb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9bee13612cf4da067faeb57d18ee2eb7">setGdo0Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:a9bee13612cf4da067faeb57d18ee2eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when GDO0 activates.  <br /></td></tr>
<tr class="separator:a9bee13612cf4da067faeb57d18ee2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e6b3745f80cf61e1ced33303311df8" id="r_ab5e6b3745f80cf61e1ced33303311df8"><td class="memItemLeft" align="right" valign="top"><a id="ab5e6b3745f80cf61e1ced33303311df8" name="ab5e6b3745f80cf61e1ced33303311df8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGdo0Action</b> ()</td></tr>
<tr class="memdesc:ab5e6b3745f80cf61e1ced33303311df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when GDO0 activates. <br /></td></tr>
<tr class="separator:ab5e6b3745f80cf61e1ced33303311df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71efbe54590e4431f3286ab99536fe9" id="r_ad71efbe54590e4431f3286ab99536fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad71efbe54590e4431f3286ab99536fe9">setGdo2Action</a> (void(*func)(void), uint32_t dir)</td></tr>
<tr class="memdesc:ad71efbe54590e4431f3286ab99536fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when GDO2 activates.  <br /></td></tr>
<tr class="separator:ad71efbe54590e4431f3286ab99536fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a8b1fe7d08dc6db20cf1569b0d37b4" id="r_ac7a8b1fe7d08dc6db20cf1569b0d37b4"><td class="memItemLeft" align="right" valign="top"><a id="ac7a8b1fe7d08dc6db20cf1569b0d37b4" name="ac7a8b1fe7d08dc6db20cf1569b0d37b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearGdo2Action</b> ()</td></tr>
<tr class="memdesc:ac7a8b1fe7d08dc6db20cf1569b0d37b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when GDO0 activates. <br /></td></tr>
<tr class="separator:ac7a8b1fe7d08dc6db20cf1569b0d37b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a16e8ed85432c6fae8d9e45399de6e" id="r_a29a16e8ed85432c6fae8d9e45399de6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a29a16e8ed85432c6fae8d9e45399de6e">setPacketReceivedAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a29a16e8ed85432c6fae8d9e45399de6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a29a16e8ed85432c6fae8d9e45399de6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0221c4fe494a590cc9714e4752675d61" id="r_a0221c4fe494a590cc9714e4752675d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0221c4fe494a590cc9714e4752675d61">clearPacketReceivedAction</a> () override</td></tr>
<tr class="memdesc:a0221c4fe494a590cc9714e4752675d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is received.  <br /></td></tr>
<tr class="separator:a0221c4fe494a590cc9714e4752675d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336999da23e554073a9fa628131883f5" id="r_a336999da23e554073a9fa628131883f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a336999da23e554073a9fa628131883f5">setPacketSentAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a336999da23e554073a9fa628131883f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a336999da23e554073a9fa628131883f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2791ebc7fe71626407278de5852b492f" id="r_a2791ebc7fe71626407278de5852b492f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a2791ebc7fe71626407278de5852b492f">clearPacketSentAction</a> () override</td></tr>
<tr class="memdesc:a2791ebc7fe71626407278de5852b492f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a packet is sent.  <br /></td></tr>
<tr class="separator:a2791ebc7fe71626407278de5852b492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff7e4066d189482c142e05384a38df0" id="r_a6ff7e4066d189482c142e05384a38df0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6ff7e4066d189482c142e05384a38df0">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:a6ff7e4066d189482c142e05384a38df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method for packets less than 64 bytes. Method blocks for packets longer than 64 bytes up to a 255 byte limit, until the last bytes are placed in the FIFO. Some limitations and issues apply; see discussion: <a href="https://github.com/jgromes/RadioLib/discussions/1138">https://github.com/jgromes/RadioLib/discussions/1138</a> Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:a6ff7e4066d189482c142e05384a38df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ea860154cd6d2b2e2a6962e161c8f" id="r_af70ea860154cd6d2b2e2a6962e161c8f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af70ea860154cd6d2b2e2a6962e161c8f">finishTransmit</a> () override</td></tr>
<tr class="memdesc:af70ea860154cd6d2b2e2a6962e161c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after transmission is done.  <br /></td></tr>
<tr class="separator:af70ea860154cd6d2b2e2a6962e161c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71e947abf6a07b194c6c6d64fd3eb19" id="r_ae71e947abf6a07b194c6c6d64fd3eb19"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae71e947abf6a07b194c6c6d64fd3eb19">startReceive</a> () override</td></tr>
<tr class="memdesc:ae71e947abf6a07b194c6c6d64fd3eb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. GDO0 will be activated when full packet is received.  <br /></td></tr>
<tr class="separator:ae71e947abf6a07b194c6c6d64fd3eb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf153c8fcf2a0d60439426b03692642e" id="r_abf153c8fcf2a0d60439426b03692642e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#abf153c8fcf2a0d60439426b03692642e">startReceive</a> (uint32_t timeout, uint32_t irqFlags, uint32_t irqMask, size_t len) override</td></tr>
<tr class="memdesc:abf153c8fcf2a0d60439426b03692642e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method, implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <br /></td></tr>
<tr class="separator:abf153c8fcf2a0d60439426b03692642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c79975a7bbe8a37f8214ecd1f69ba22" id="r_a8c79975a7bbe8a37f8214ecd1f69ba22"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a8c79975a7bbe8a37f8214ecd1f69ba22">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a8c79975a7bbe8a37f8214ecd1f69ba22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData!  <br /></td></tr>
<tr class="separator:a8c79975a7bbe8a37f8214ecd1f69ba22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd7dac7d846ff25a86b5a3f6e196a6b" id="r_aebd7dac7d846ff25a86b5a3f6e196a6b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aebd7dac7d846ff25a86b5a3f6e196a6b">finishReceive</a> () override</td></tr>
<tr class="memdesc:aebd7dac7d846ff25a86b5a3f6e196a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up after reception is done.  <br /></td></tr>
<tr class="separator:aebd7dac7d846ff25a86b5a3f6e196a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad428d7e6fc9ac119101bb0716fa80bee" id="r_ad428d7e6fc9ac119101bb0716fa80bee"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad428d7e6fc9ac119101bb0716fa80bee">setFrequency</a> (float freq) override</td></tr>
<tr class="memdesc:ad428d7e6fc9ac119101bb0716fa80bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets carrier frequency. Allowed values are in bands 300.0 to 348.0 MHz, 387.0 to 464.0 MHz and 779.0 to 928.0 MHz.  <br /></td></tr>
<tr class="separator:ad428d7e6fc9ac119101bb0716fa80bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd22cdec29e1e34a92aa9854b90fdc9" id="r_a6fd22cdec29e1e34a92aa9854b90fdc9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6fd22cdec29e1e34a92aa9854b90fdc9">setBitRate</a> (float br) override</td></tr>
<tr class="memdesc:a6fd22cdec29e1e34a92aa9854b90fdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit rate. Allowed values range from 0.025 to 600.0 kbps.  <br /></td></tr>
<tr class="separator:a6fd22cdec29e1e34a92aa9854b90fdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc76af01dbc9171b3fdd7570624a4d4f" id="r_adc76af01dbc9171b3fdd7570624a4d4f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#adc76af01dbc9171b3fdd7570624a4d4f">setBitRateTolerance</a> (uint8_t brt)</td></tr>
<tr class="memdesc:adc76af01dbc9171b3fdd7570624a4d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bit rate tolerance in BSCFG register. Allowed values are 0:(0%), 1(3,125%), 2:(6,25%) and 3:(12,5%).  <br /></td></tr>
<tr class="separator:adc76af01dbc9171b3fdd7570624a4d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381d0059d7a0ccd8a2f54d7d3376f9b6" id="r_a381d0059d7a0ccd8a2f54d7d3376f9b6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a381d0059d7a0ccd8a2f54d7d3376f9b6">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a381d0059d7a0ccd8a2f54d7d3376f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets receiver bandwidth. Allowed values are 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650 and 812 kHz.  <br /></td></tr>
<tr class="separator:a381d0059d7a0ccd8a2f54d7d3376f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476adec156ae39974e70ef17b9af7db3" id="r_a476adec156ae39974e70ef17b9af7db3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a476adec156ae39974e70ef17b9af7db3">autoSetRxBandwidth</a> ()</td></tr>
<tr class="memdesc:a476adec156ae39974e70ef17b9af7db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates and sets Rx bandwidth based on the freq, baud and freq uncertainty. Reimplement of atlas0fd00m's (RfCat) CalculatePktChanBw function. Modified for worse ppm with the <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a>, and adjusted for the supportted <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> bw.  <br /></td></tr>
<tr class="separator:a476adec156ae39974e70ef17b9af7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d69713b9f20c9de354c13c3167b18b3" id="r_a0d69713b9f20c9de354c13c3167b18b3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a0d69713b9f20c9de354c13c3167b18b3">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a0d69713b9f20c9de354c13c3167b18b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets frequency deviation. Allowed values range from 1.587 to 380.8 kHz.  <br /></td></tr>
<tr class="separator:a0d69713b9f20c9de354c13c3167b18b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe26fa310e973bf2b14750b9eae02124" id="r_abe26fa310e973bf2b14750b9eae02124"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#abe26fa310e973bf2b14750b9eae02124">getFrequencyDeviation</a> (float *freqDev)</td></tr>
<tr class="memdesc:abe26fa310e973bf2b14750b9eae02124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets frequency deviation.  <br /></td></tr>
<tr class="separator:abe26fa310e973bf2b14750b9eae02124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6dce30fc7da668975b6da663784cdf" id="r_a5d6dce30fc7da668975b6da663784cdf"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5d6dce30fc7da668975b6da663784cdf">setOutputPower</a> (int8_t pwr) override</td></tr>
<tr class="memdesc:a5d6dce30fc7da668975b6da663784cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets output power. Allowed values are -30, -20, -15, -10, 0, 5, 7 or 10 dBm.  <br /></td></tr>
<tr class="separator:a5d6dce30fc7da668975b6da663784cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab500e75fcf63f123eb3945925f361bd0" id="r_ab500e75fcf63f123eb3945925f361bd0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab500e75fcf63f123eb3945925f361bd0">checkOutputPower</a> (int8_t power, int8_t *clipped) override</td></tr>
<tr class="memdesc:ab500e75fcf63f123eb3945925f361bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>.  <br /></td></tr>
<tr class="separator:ab500e75fcf63f123eb3945925f361bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c74ed4339b70be6950e9f92be1d81" id="r_aa86c74ed4339b70be6950e9f92be1d81"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aa86c74ed4339b70be6950e9f92be1d81">checkOutputPower</a> (int8_t power, int8_t *clipped, uint8_t *raw)</td></tr>
<tr class="memdesc:aa86c74ed4339b70be6950e9f92be1d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if output power is configurable.  <br /></td></tr>
<tr class="separator:aa86c74ed4339b70be6950e9f92be1d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab299f0802f004c89ddab7c9192cd52ac" id="r_ab299f0802f004c89ddab7c9192cd52ac"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab299f0802f004c89ddab7c9192cd52ac">setSyncWord</a> (uint8_t *sync, size_t len) override</td></tr>
<tr class="memdesc:ab299f0802f004c89ddab7c9192cd52ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 1 or 2 bytes of sync word.  <br /></td></tr>
<tr class="separator:ab299f0802f004c89ddab7c9192cd52ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433f1a40b33be6c84d3665a1b4cd57d6" id="r_a433f1a40b33be6c84d3665a1b4cd57d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a433f1a40b33be6c84d3665a1b4cd57d6">setSyncWord</a> (uint8_t syncH, uint8_t syncL, uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a433f1a40b33be6c84d3665a1b4cd57d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 16-bit sync word as a two byte value.  <br /></td></tr>
<tr class="separator:a433f1a40b33be6c84d3665a1b4cd57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5345d819ea74f583e4e54f3496aa63eb" id="r_a5345d819ea74f583e4e54f3496aa63eb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5345d819ea74f583e4e54f3496aa63eb">setSyncWord</a> (const uint8_t *syncWord, uint8_t len, uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a5345d819ea74f583e4e54f3496aa63eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets 1 or 2 bytes of sync word.  <br /></td></tr>
<tr class="separator:a5345d819ea74f583e4e54f3496aa63eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae535dc268518c51d03c12defbaebe93e" id="r_ae535dc268518c51d03c12defbaebe93e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae535dc268518c51d03c12defbaebe93e">setPreambleLength</a> (size_t len) override</td></tr>
<tr class="memdesc:ae535dc268518c51d03c12defbaebe93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length.  <br /></td></tr>
<tr class="separator:ae535dc268518c51d03c12defbaebe93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77c828c9c7cc12012fe011e8c4d3570" id="r_ae77c828c9c7cc12012fe011e8c4d3570"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae77c828c9c7cc12012fe011e8c4d3570">setPreambleLength</a> (uint8_t preambleLength, uint8_t qualityThreshold)</td></tr>
<tr class="memdesc:ae77c828c9c7cc12012fe011e8c4d3570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length.  <br /></td></tr>
<tr class="separator:ae77c828c9c7cc12012fe011e8c4d3570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e62914790f132816134fc68c2bb5eb8" id="r_a6e62914790f132816134fc68c2bb5eb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6e62914790f132816134fc68c2bb5eb8">setNodeAddress</a> (uint8_t nodeAddr, uint8_t numBroadcastAddrs=0)</td></tr>
<tr class="memdesc:a6e62914790f132816134fc68c2bb5eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets node and broadcast addresses. Calling this method will also enable address filtering.  <br /></td></tr>
<tr class="separator:a6e62914790f132816134fc68c2bb5eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aee5df428d30b9c80b8a8700609a883" id="r_a9aee5df428d30b9c80b8a8700609a883"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a9aee5df428d30b9c80b8a8700609a883">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:a9aee5df428d30b9c80b8a8700609a883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables address filtering. Calling this method will also erase previously set addresses.  <br /></td></tr>
<tr class="separator:a9aee5df428d30b9c80b8a8700609a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa64d1ad4789d3146b38d14437234756" id="r_afa64d1ad4789d3146b38d14437234756"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#afa64d1ad4789d3146b38d14437234756">setOOK</a> (bool enableOOK)</td></tr>
<tr class="memdesc:afa64d1ad4789d3146b38d14437234756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/disables OOK modulation instead of FSK.  <br /></td></tr>
<tr class="separator:afa64d1ad4789d3146b38d14437234756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80835be83e5a43010afe4e8185114eb" id="r_ab80835be83e5a43010afe4e8185114eb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab80835be83e5a43010afe4e8185114eb">getRSSI</a> () override</td></tr>
<tr class="memdesc:ab80835be83e5a43010afe4e8185114eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator) of the last received packet. In direct or asynchronous direct mode, returns the current RSSI level.  <br /></td></tr>
<tr class="separator:ab80835be83e5a43010afe4e8185114eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ca9e8956e308159949638bf327e5fb" id="r_a59ca9e8956e308159949638bf327e5fb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a59ca9e8956e308159949638bf327e5fb">getLQI</a> () const</td></tr>
<tr class="memdesc:a59ca9e8956e308159949638bf327e5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets LQI (Link Quality Indicator) of the last received packet.  <br /></td></tr>
<tr class="separator:a59ca9e8956e308159949638bf327e5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122281f6a915b77ee9dafc9926e731a0" id="r_a122281f6a915b77ee9dafc9926e731a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a122281f6a915b77ee9dafc9926e731a0">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:a122281f6a915b77ee9dafc9926e731a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <br /></td></tr>
<tr class="separator:a122281f6a915b77ee9dafc9926e731a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25ad96cddf62273bffd601384d22275" id="r_ad25ad96cddf62273bffd601384d22275"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ad25ad96cddf62273bffd601384d22275">fixedPacketLengthMode</a> (uint8_t len=RADIOLIB_CC1101_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:ad25ad96cddf62273bffd601384d22275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode.  <br /></td></tr>
<tr class="separator:ad25ad96cddf62273bffd601384d22275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b9e73d2d82a4cd03841f465825b73f" id="r_a50b9e73d2d82a4cd03841f465825b73f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a50b9e73d2d82a4cd03841f465825b73f">variablePacketLengthMode</a> (uint8_t maxLen=RADIOLIB_CC1101_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:a50b9e73d2d82a4cd03841f465825b73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode.  <br /></td></tr>
<tr class="separator:a50b9e73d2d82a4cd03841f465825b73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe55d0217bf5218865198ef8d6fdab4" id="r_a6fe55d0217bf5218865198ef8d6fdab4"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a6fe55d0217bf5218865198ef8d6fdab4">enableSyncWordFiltering</a> (uint8_t maxErrBits=0, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a6fe55d0217bf5218865198ef8d6fdab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable sync word filtering and generation.  <br /></td></tr>
<tr class="separator:a6fe55d0217bf5218865198ef8d6fdab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2dc4176b62a0636636088e31b8e85b" id="r_a4f2dc4176b62a0636636088e31b8e85b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a4f2dc4176b62a0636636088e31b8e85b">disableSyncWordFiltering</a> (bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:a4f2dc4176b62a0636636088e31b8e85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable preamble and sync word filtering and generation.  <br /></td></tr>
<tr class="separator:a4f2dc4176b62a0636636088e31b8e85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60695681fc74a37f2a31a9638552e877" id="r_a60695681fc74a37f2a31a9638552e877"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a60695681fc74a37f2a31a9638552e877">setCrcFiltering</a> (bool enable=true)</td></tr>
<tr class="memdesc:a60695681fc74a37f2a31a9638552e877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable CRC filtering and generation.  <br /></td></tr>
<tr class="separator:a60695681fc74a37f2a31a9638552e877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1155543b27e46fa27aa4c9180da18bb" id="r_ac1155543b27e46fa27aa4c9180da18bb"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ac1155543b27e46fa27aa4c9180da18bb">setPromiscuousMode</a> (bool enable=true, bool requireCarrierSense=false)</td></tr>
<tr class="memdesc:ac1155543b27e46fa27aa4c9180da18bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in "sniff" mode: no packet filtering (e.g., no preamble, sync word, address, CRC).  <br /></td></tr>
<tr class="separator:ac1155543b27e46fa27aa4c9180da18bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea78919ec14d940cda0f213e4fdced6" id="r_aeea78919ec14d940cda0f213e4fdced6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#aeea78919ec14d940cda0f213e4fdced6">getPromiscuousMode</a> ()</td></tr>
<tr class="memdesc:aeea78919ec14d940cda0f213e4fdced6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the modem is in promiscuous mode: no packet filtering (e.g., no preamble, sync word, address, CRC).  <br /></td></tr>
<tr class="separator:aeea78919ec14d940cda0f213e4fdced6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf96e77f25b7e256891601bef04f35a6" id="r_adf96e77f25b7e256891601bef04f35a6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#adf96e77f25b7e256891601bef04f35a6">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:adf96e77f25b7e256891601bef04f35a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets Gaussian filter bandwidth-time product that will be used for data shaping. Allowed value is RADIOLIB_SHAPING_0_5. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <br /></td></tr>
<tr class="separator:adf96e77f25b7e256891601bef04f35a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b98eb6af33d006306bb7514ed216ea" id="r_ab4b98eb6af33d006306bb7514ed216ea"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ab4b98eb6af33d006306bb7514ed216ea">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:ab4b98eb6af33d006306bb7514ed216ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER, and RADIOLIB_ENCODING_WHITENING. Note that encoding on <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is applied to the entire stream including preamble, sync word, and CRC.  <br /></td></tr>
<tr class="separator:ab4b98eb6af33d006306bb7514ed216ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef45183690bb1879f106af079b01140" id="r_a5ef45183690bb1879f106af079b01140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a5ef45183690bb1879f106af079b01140">setRfSwitchPins</a> (uint32_t rxEn, uint32_t txEn)</td></tr>
<tr class="memdesc:a5ef45183690bb1879f106af079b01140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.    <br /></td></tr>
<tr class="separator:a5ef45183690bb1879f106af079b01140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b401995be4bc136063a035ce1820634" id="r_a7b401995be4bc136063a035ce1820634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a7b401995be4bc136063a035ce1820634">setRfSwitchTable</a> (const uint32_t(&amp;pins)[<a class="el" href="class_module.html#a0c11551e12579bbabf57b19e12555b3c">Module::RFSWITCH_MAX_PINS</a>], const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> table[])</td></tr>
<tr class="memdesc:a7b401995be4bc136063a035ce1820634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.    <br /></td></tr>
<tr class="separator:a7b401995be4bc136063a035ce1820634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cf332824479442cc20fc1c6972b092" id="r_a13cf332824479442cc20fc1c6972b092"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a13cf332824479442cc20fc1c6972b092">randomByte</a> () override</td></tr>
<tr class="memdesc:a13cf332824479442cc20fc1c6972b092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <br /></td></tr>
<tr class="separator:a13cf332824479442cc20fc1c6972b092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c6e622dffd2788d8ac52d708b0705" id="r_a2a4c6e622dffd2788d8ac52d708b0705"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a2a4c6e622dffd2788d8ac52d708b0705">getChipVersion</a> ()</td></tr>
<tr class="memdesc:a2a4c6e622dffd2788d8ac52d708b0705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read version SPI register. Should return CC1101_VERSION_LEGACY (0x04) or CC1101_VERSION_CURRENT (0x14) if <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is connected and working.  <br /></td></tr>
<tr class="separator:a2a4c6e622dffd2788d8ac52d708b0705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f4b059cc56238499c6117b88cd5505" id="r_a24f4b059cc56238499c6117b88cd5505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a24f4b059cc56238499c6117b88cd5505">setDirectAction</a> (void(*func)(void)) override</td></tr>
<tr class="memdesc:a24f4b059cc56238499c6117b88cd5505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt service routine function to call when data bit is receveid in direct mode.  <br /></td></tr>
<tr class="separator:a24f4b059cc56238499c6117b88cd5505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a92d885beefdf2db291301550a980c" id="r_a11a92d885beefdf2db291301550a980c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a11a92d885beefdf2db291301550a980c">readBit</a> (uint32_t pin) override</td></tr>
<tr class="memdesc:a11a92d885beefdf2db291301550a980c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to read and process data bit in direct reception mode.  <br /></td></tr>
<tr class="separator:a11a92d885beefdf2db291301550a980c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544bb8d7be9c0e1ff7f7103b30925862" id="r_a544bb8d7be9c0e1ff7f7103b30925862"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a544bb8d7be9c0e1ff7f7103b30925862">setDIOMapping</a> (uint32_t pin, uint32_t value) override</td></tr>
<tr class="memdesc:a544bb8d7be9c0e1ff7f7103b30925862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure DIO pin mapping to get a given signal on a DIO pin (if available).  <br /></td></tr>
<tr class="separator:a544bb8d7be9c0e1ff7f7103b30925862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada508497ee2e70170da3afe078e2fe0e" id="r_ada508497ee2e70170da3afe078e2fe0e"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ada508497ee2e70170da3afe078e2fe0e">transmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:ada508497ee2e70170da3afe078e2fe0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ada508497ee2e70170da3afe078e2fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae608fabef91defa1e33e6a6787c68ce8" id="r_ae608fabef91defa1e33e6a6787c68ce8"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#ae608fabef91defa1e33e6a6787c68ce8">receive</a> (uint8_t *data, size_t len, <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeout=0)</td></tr>
<tr class="memdesc:ae608fabef91defa1e33e6a6787c68ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae608fabef91defa1e33e6a6787c68ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79757dbbd62e080c1bad2e608ab940c" id="r_af79757dbbd62e080c1bad2e608ab940c"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#af79757dbbd62e080c1bad2e608ab940c">startTransmit</a> (const uint8_t *data, size_t len, uint8_t addr=0)</td></tr>
<tr class="memdesc:af79757dbbd62e080c1bad2e608ab940c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <br /></td></tr>
<tr class="separator:af79757dbbd62e080c1bad2e608ab940c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3563453988a83d22dd07d4691543a300" id="r_a3563453988a83d22dd07d4691543a300"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_c1101.html#a3563453988a83d22dd07d4691543a300">readData</a> (uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a3563453988a83d22dd07d4691543a300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <br /></td></tr>
<tr class="separator:a3563453988a83d22dd07d4691543a300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer" id="r_afc972a84153977d6ccd9e116b6181ad4"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>PhysicalLayer</b> ()</td></tr>
<tr class="memdesc:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:afc972a84153977d6ccd9e116b6181ad4 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer" id="r_a7af88f9f75c9778c29002c2b8238a239"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~PhysicalLayer</b> ()=default</td></tr>
<tr class="memdesc:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor. <br /></td></tr>
<tr class="separator:a7af88f9f75c9778c29002c2b8238a239 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer" id="r_a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer" id="r_a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer" id="r_a11b4c6d0bf3ae7b9ca04e9434180feab"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a11b4c6d0bf3ae7b9ca04e9434180feab">invertIQ</a> (bool enable)</td></tr>
<tr class="memdesc:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set IQ inversion. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a11b4c6d0bf3ae7b9ca04e9434180feab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer" id="r_ac5f1e0c24d8bf878f2c9fe729b6e1610"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac5f1e0c24d8bf878f2c9fe729b6e1610">setDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data rate. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:ac5f1e0c24d8bf878f2c9fe729b6e1610 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer" id="r_a9c5c902d9f8ffe9866b7f178b14d34f6"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a9c5c902d9f8ffe9866b7f178b14d34f6">checkDataRate</a> (<a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, ModemType_t modem=RADIOLIB_MODEM_NONE)</td></tr>
<tr class="memdesc:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the data rate can be configured by this module. Must be implemented in module class if the module supports it.  <br /></td></tr>
<tr class="separator:a9c5c902d9f8ffe9866b7f178b14d34f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer" id="r_aedddaf9460941b90e43e9005035faa0f"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aedddaf9460941b90e43e9005035faa0f">getSNR</a> ()</td></tr>
<tr class="memdesc:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <br /></td></tr>
<tr class="separator:aedddaf9460941b90e43e9005035faa0f inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer" id="r_ac1974cb6218782c557a673aeb4a99928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac1974cb6218782c557a673aeb4a99928">calculateTimeOnAir</a> (ModemType_t modem, <a class="el" href="union_data_rate__t.html">DataRate_t</a> dr, <a class="el" href="union_packet_config__t.html">PacketConfig_t</a> pc, size_t len)</td></tr>
<tr class="memdesc:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the expected time-on-air for a given modem, data rate, packet configuration and payload size.  <br /></td></tr>
<tr class="separator:ac1974cb6218782c557a673aeb4a99928 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer" id="r_a50e730a894f60b58034507ad7730dd3c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a50e730a894f60b58034507ad7730dd3c">getTimeOnAir</a> (size_t len)</td></tr>
<tr class="memdesc:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <br /></td></tr>
<tr class="separator:a50e730a894f60b58034507ad7730dd3c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer" id="r_a7f8d12a90158864a8ebc471b0ec89dc9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a7f8d12a90158864a8ebc471b0ec89dc9">calculateRxTimeout</a> (<a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a> timeoutUs)</td></tr>
<tr class="memdesc:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the timeout value for this specific module / series (in number of symbols or units of time).  <br /></td></tr>
<tr class="separator:a7f8d12a90158864a8ebc471b0ec89dc9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer" id="r_ae602ebd46d60da8670c9f353cef695d9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae602ebd46d60da8670c9f353cef695d9">getIrqMapped</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert from radio-agnostic IRQ flags to radio-specific flags.  <br /></td></tr>
<tr class="separator:ae602ebd46d60da8670c9f353cef695d9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer" id="r_a2c7dd4704e3df353265010710bd26e83"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a2c7dd4704e3df353265010710bd26e83">checkIrq</a> (RadioLibIrqType_t irq)</td></tr>
<tr class="memdesc:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a specific IRQ bit is set (e.g. RxTimeout, CadDone).  <br /></td></tr>
<tr class="separator:a2c7dd4704e3df353265010710bd26e83 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer" id="r_a8564f9834a0247e93e7620c23559ceb8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8564f9834a0247e93e7620c23559ceb8">setIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on specific IRQ bit(s) (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:a8564f9834a0247e93e7620c23559ceb8 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer" id="r_af9a7e739e39705a72ffa8b63ec09bb15"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af9a7e739e39705a72ffa8b63ec09bb15">clearIrq</a> (<a class="el" href="group__typedefs.html#gafaf66becf1112a55ba8ad7402b802b77">RadioLibIrqFlags_t</a> irq)</td></tr>
<tr class="memdesc:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Keep in mind that not all radio modules support all RADIOLIB_IRQ_ flags!  <br /></td></tr>
<tr class="separator:af9a7e739e39705a72ffa8b63ec09bb15 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer" id="r_af1caeed34b2e2ff0355467507106a1a2"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af1caeed34b2e2ff0355467507106a1a2">getIrqFlags</a> ()</td></tr>
<tr class="memdesc:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read currently active IRQ flags. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:af1caeed34b2e2ff0355467507106a1a2 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer" id="r_af88dcb54dc8e9a1edaf9f1c3e5ee2b74"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af88dcb54dc8e9a1edaf9f1c3e5ee2b74">setIrqFlags</a> (uint32_t irq)</td></tr>
<tr class="memdesc:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set interrupt on DIO1 to be sent on a specific IRQ bit (e.g. RxTimeout, CadDone). Must be implemented in module class.  <br /></td></tr>
<tr class="separator:af88dcb54dc8e9a1edaf9f1c3e5ee2b74 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer" id="r_ac282bb78da4f4da4661dce191cbd6d87"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ac282bb78da4f4da4661dce191cbd6d87">clearIrqFlags</a> (uint32_t irq)</td></tr>
<tr class="memdesc:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear interrupt on a specific IRQ bit (e.g. RxTimeout, CadDone). Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ac282bb78da4f4da4661dce191cbd6d87 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer" id="r_ae30dfbb5445bb674898fc54f5f90b2f9"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae30dfbb5445bb674898fc54f5f90b2f9">startChannelScan</a> ()</td></tr>
<tr class="memdesc:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. Interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:ae30dfbb5445bb674898fc54f5f90b2f9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer" id="r_a82a52062d9259c2c546d7bf8072b7a72"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a82a52062d9259c2c546d7bf8072b7a72">startChannelScan</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven channel activity detection method. interrupt will be activated when packet is detected. Must be implemented in module class.  <br /></td></tr>
<tr class="separator:a82a52062d9259c2c546d7bf8072b7a72 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer" id="r_a63979795a7b53557560bb95b65480906"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a63979795a7b53557560bb95b65480906">getChannelScanResult</a> ()</td></tr>
<tr class="memdesc:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the channel scan result.  <br /></td></tr>
<tr class="separator:a63979795a7b53557560bb95b65480906 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer" id="r_abd9e39cc745acbf084cfa0d3f4d10718"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#abd9e39cc745acbf084cfa0d3f4d10718">scanChannel</a> ()</td></tr>
<tr class="memdesc:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:abd9e39cc745acbf084cfa0d3f4d10718 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer" id="r_af788cf83ceb0222cd0fa4a1323b9041b"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af788cf83ceb0222cd0fa4a1323b9041b">scanChannel</a> (const <a class="el" href="union_channel_scan_config__t.html">ChannelScanConfig_t</a> &amp;config)</td></tr>
<tr class="memdesc:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the current communication channel is free or occupied. Performs CAD for LoRa modules, or RSSI measurement for FSK modules.  <br /></td></tr>
<tr class="separator:af788cf83ceb0222cd0fa4a1323b9041b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer" id="r_acd9171bd71aa80fb86113b612c42de53"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer" id="r_a76113e10481743094a1cd0280692b0a9"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer" id="r_a88a10657bd2215a11a2331f937414b55"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer" id="r_a8e378fe136a498ea485a9c10f5e15aab"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer" id="r_ab57182d32646861ef0d865e2740d6b26"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer" id="r_a429796eb2e7ea86781a2e8ca42af43f3"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>dropSync</b> ()</td></tr>
<tr class="memdesc:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcefully drop synchronization. <br /></td></tr>
<tr class="separator:a429796eb2e7ea86781a2e8ca42af43f3 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer" id="r_a4d5b30493c8d7fcfb784e128362d596c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a4d5b30493c8d7fcfb784e128362d596c">read</a> (bool drop=true)</td></tr>
<tr class="memdesc:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <br /></td></tr>
<tr class="separator:a4d5b30493c8d7fcfb784e128362d596c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer" id="r_ae11c191a7edf3116bf468b9153237260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae11c191a7edf3116bf468b9153237260">setChannelScanAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:ae11c191a7edf3116bf468b9153237260 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer" id="r_a169a4d04c5c50d3336e274d70930d9f6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a169a4d04c5c50d3336e274d70930d9f6">clearChannelScanAction</a> ()</td></tr>
<tr class="memdesc:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when a channel scan is finished.  <br /></td></tr>
<tr class="separator:a169a4d04c5c50d3336e274d70930d9f6 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer" id="r_a77415bf4ed34be18c92c0cf4b2de7149"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a77415bf4ed34be18c92c0cf4b2de7149">setModem</a> (ModemType_t modem)</td></tr>
<tr class="memdesc:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem for the radio to use. Will perform full reset and reconfigure the radio using its default parameters.  <br /></td></tr>
<tr class="separator:a77415bf4ed34be18c92c0cf4b2de7149 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer" id="r_af061879bf694735297593c048d04a196"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af061879bf694735297593c048d04a196">getModem</a> (ModemType_t *modem)</td></tr>
<tr class="memdesc:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get modem currently in use by the radio.  <br /></td></tr>
<tr class="separator:af061879bf694735297593c048d04a196 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer" id="r_a06fa3b844c6028a78e29b7dff58c7c79"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a06fa3b844c6028a78e29b7dff58c7c79">stageMode</a> (RadioModeType_t mode, <a class="el" href="union_radio_mode_config__t.html">RadioModeConfig_t</a> *cfg)</td></tr>
<tr class="memdesc:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stage mode of the radio to be launched later using launchMode.  <br /></td></tr>
<tr class="separator:a06fa3b844c6028a78e29b7dff58c7c79 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer" id="r_a5c5977bc9f54f21665b022a99e6c87cc"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a5c5977bc9f54f21665b022a99e6c87cc">launchMode</a> ()</td></tr>
<tr class="memdesc:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Launch previously staged mode.  <br /></td></tr>
<tr class="separator:a5c5977bc9f54f21665b022a99e6c87cc inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_attribs_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer" id="r_aa949616080a463a82bb6ad5075a9e16e"><td class="memItemLeft" align="right" valign="top">
float&#160;</td><td class="memItemRight" valign="bottom"><b>freqStep</b></td></tr>
<tr class="memdesc:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frequency step of the synthesizer in Hz. <br /></td></tr>
<tr class="separator:aa949616080a463a82bb6ad5075a9e16e inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer" id="r_a1c04f8fba5eef96e59972004e8abc623"><td class="memItemLeft" align="right" valign="top">
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>maxPacketLength</b></td></tr>
<tr class="memdesc:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of packet that can be received by the module. <br /></td></tr>
<tr class="separator:a1c04f8fba5eef96e59972004e8abc623 inherit pub_attribs_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Control class for CC1101 module. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6807e4254c4b55fa8d393b2bf8f2db3e" name="a6807e4254c4b55fa8d393b2bf8f2db3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6807e4254c4b55fa8d393b2bf8f2db3e">&#9670;&#160;</a></span>CC1101()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CC1101::CC1101 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">module</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> that will be used to communicate with the radio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a476adec156ae39974e70ef17b9af7db3" name="a476adec156ae39974e70ef17b9af7db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476adec156ae39974e70ef17b9af7db3">&#9670;&#160;</a></span>autoSetRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::autoSetRxBandwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculates and sets Rx bandwidth based on the freq, baud and freq uncertainty. Reimplement of atlas0fd00m's (RfCat) CalculatePktChanBw function. Modified for worse ppm with the <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a>, and adjusted for the supportted <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> bw. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ad86f23bb3d113d20f6238a671f18b565" name="ad86f23bb3d113d20f6238a671f18b565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86f23bb3d113d20f6238a671f18b565">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>RADIOLIB_CC1101_DEFAULT_FREQ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em> = <code>RADIOLIB_CC1101_DEFAULT_BR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em> = <code>RADIOLIB_CC1101_DEFAULT_FREQDEV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em> = <code>RADIOLIB_CC1101_DEFAULT_RXBW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>pwr</em> = <code>RADIOLIB_CC1101_DEFAULT_POWER</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>RADIOLIB_CC1101_DEFAULT_PREAMBLELEN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>Bit rate to be used in kbps. Defaults to 4.8 kbps. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation from carrier frequency in kHz Defaults to 5.0 kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Defaults to 135.0 kHz. </td></tr>
    <tr><td class="paramname">pwr</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Preamble Length in bits. Defaults to 16 bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afff1ff2e763a3ad598bdae535595db63" name="afff1ff2e763a3ad598bdae535595db63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff1ff2e763a3ad598bdae535595db63">&#9670;&#160;</a></span>beginFSK4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::beginFSK4 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em> = <code>RADIOLIB_CC1101_DEFAULT_FREQ</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em> = <code>RADIOLIB_CC1101_DEFAULT_BR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em> = <code>RADIOLIB_CC1101_DEFAULT_FREQDEV</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em> = <code>RADIOLIB_CC1101_DEFAULT_RXBW</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>pwr</em> = <code>RADIOLIB_CC1101_DEFAULT_POWER</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>preambleLength</em> = <code>RADIOLIB_CC1101_DEFAULT_PREAMBLELEN</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for 4-FSK modulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency in MHz. Defaults to 434 MHz. </td></tr>
    <tr><td class="paramname">br</td><td>Bit rate to be used in kbps. Defaults to 4.8 kbps. </td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation from carrier frequency in kHz Defaults to 5.0 kHz. </td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Defaults to 135.0 kHz. </td></tr>
    <tr><td class="paramname">pwr</td><td>Output power in dBm. Defaults to 10 dBm. </td></tr>
    <tr><td class="paramname">preambleLength</td><td>Preamble Length in bits. Defaults to 16 bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab500e75fcf63f123eb3945925f361bd0" name="ab500e75fcf63f123eb3945925f361bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab500e75fcf63f123eb3945925f361bd0">&#9670;&#160;</a></span>checkOutputPower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::checkOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>clipped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if output power is configurable. This method is needed for compatibility with <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536" title="Check if output power is configurable. Must be implemented in module class if the module supports it.">PhysicalLayer::checkOutputPower</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power in dBm. </td></tr>
    <tr><td class="paramname">clipped</td><td>Clipped output power value to what is possible within the module's range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1784cb227d04b3f2846625fda6797536">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa86c74ed4339b70be6950e9f92be1d81" name="aa86c74ed4339b70be6950e9f92be1d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86c74ed4339b70be6950e9f92be1d81">&#9670;&#160;</a></span>checkOutputPower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::checkOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>clipped</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>raw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if output power is configurable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>Output power in dBm. </td></tr>
    <tr><td class="paramname">clipped</td><td>Clipped output power value to what is possible within the module's range. </td></tr>
    <tr><td class="paramname">raw</td><td>Raw internal value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a0221c4fe494a590cc9714e4752675d61" name="a0221c4fe494a590cc9714e4752675d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0221c4fe494a590cc9714e4752675d61">&#9670;&#160;</a></span>clearPacketReceivedAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::clearPacketReceivedAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears interrupt service routine to call when a packet is received. </p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7edf27f03600b96f72f011fc82fa4ef9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2791ebc7fe71626407278de5852b492f" name="a2791ebc7fe71626407278de5852b492f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2791ebc7fe71626407278de5852b492f">&#9670;&#160;</a></span>clearPacketSentAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::clearPacketSentAction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears interrupt service routine to call when a packet is sent. </p>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a67ee4ec36f352d06dda0102260f6bfce">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9aee5df428d30b9c80b8a8700609a883" name="a9aee5df428d30b9c80b8a8700609a883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aee5df428d30b9c80b8a8700609a883">&#9670;&#160;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables address filtering. Calling this method will also erase previously set addresses. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a4f2dc4176b62a0636636088e31b8e85b" name="a4f2dc4176b62a0636636088e31b8e85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2dc4176b62a0636636088e31b8e85b">&#9670;&#160;</a></span>disableSyncWordFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::disableSyncWordFiltering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCarrierSense</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable preamble and sync word filtering and generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requireCarrierSense</td><td>Require carrier sense above threshold. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6fe55d0217bf5218865198ef8d6fdab4" name="a6fe55d0217bf5218865198ef8d6fdab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe55d0217bf5218865198ef8d6fdab4">&#9670;&#160;</a></span>enableSyncWordFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::enableSyncWordFiltering </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxErrBits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCarrierSense</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable sync word filtering and generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxErrBits</td><td>Maximum number of allowed error bits in sync word. </td></tr>
    <tr><td class="paramname">requireCarrierSense</td><td>Require carrier sense above threshold in addition to sync word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aebd7dac7d846ff25a86b5a3f6e196a6b" name="aebd7dac7d846ff25a86b5a3f6e196a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd7dac7d846ff25a86b5a3f6e196a6b">&#9670;&#160;</a></span>finishReceive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::finishReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after reception is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8d8997a3fdeaede52d9354d3bf310bf4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af70ea860154cd6d2b2e2a6962e161c8f" name="af70ea860154cd6d2b2e2a6962e161c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70ea860154cd6d2b2e2a6962e161c8f">&#9670;&#160;</a></span>finishTransmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::finishTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clean up after transmission is done. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1de26f68b939f5af79ec29cc34c7be18">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad25ad96cddf62273bffd601384d22275" name="ad25ad96cddf62273bffd601384d22275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25ad96cddf62273bffd601384d22275">&#9670;&#160;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>RADIOLIB_CC1101_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2a4c6e622dffd2788d8ac52d708b0705" name="a2a4c6e622dffd2788d8ac52d708b0705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4c6e622dffd2788d8ac52d708b0705">&#9670;&#160;</a></span>getChipVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::getChipVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read version SPI register. Should return CC1101_VERSION_LEGACY (0x04) or CC1101_VERSION_CURRENT (0x14) if <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is connected and working. </p>
<dl class="section return"><dt>Returns</dt><dd>Version register contents or <a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abe26fa310e973bf2b14750b9eae02124" name="abe26fa310e973bf2b14750b9eae02124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe26fa310e973bf2b14750b9eae02124">&#9670;&#160;</a></span>getFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::getFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets frequency deviation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">freqDev</td><td>Pointer to variable where to save the frequency deviation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a59ca9e8956e308159949638bf327e5fb" name="a59ca9e8956e308159949638bf327e5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ca9e8956e308159949638bf327e5fb">&#9670;&#160;</a></span>getLQI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CC1101::getLQI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets LQI (Link Quality Indicator) of the last received packet. </p>
<dl class="section return"><dt>Returns</dt><dd>Last packet LQI (lower is better). </dd></dl>

</div>
</div>
<a id="a122281f6a915b77ee9dafc9926e731a0" name="a122281f6a915b77ee9dafc9926e731a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a122281f6a915b77ee9dafc9926e731a0">&#9670;&#160;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t CC1101::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2fe95169b5cdc8cabe1f2af66cad6ef6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aeea78919ec14d940cda0f213e4fdced6" name="aeea78919ec14d940cda0f213e4fdced6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea78919ec14d940cda0f213e4fdced6">&#9670;&#160;</a></span>getPromiscuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CC1101::getPromiscuousMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the modem is in promiscuous mode: no packet filtering (e.g., no preamble, sync word, address, CRC). </p>
<dl class="section return"><dt>Returns</dt><dd>Whether the modem is in promiscuous mode. </dd></dl>

</div>
</div>
<a id="ab80835be83e5a43010afe4e8185114eb" name="ab80835be83e5a43010afe4e8185114eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80835be83e5a43010afe4e8185114eb">&#9670;&#160;</a></span>getRSSI()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float CC1101::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets RSSI (Recorded Signal Strength Indicator) of the last received packet. In direct or asynchronous direct mode, returns the current RSSI level. </p>
<dl class="section return"><dt>Returns</dt><dd>RSSI in dBm. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aabc94ab27a9ee6daaafa9b47dde5f75b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a13cf332824479442cc20fc1c6972b092" name="a13cf332824479442cc20fc1c6972b092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13cf332824479442cc20fc1c6972b092">&#9670;&#160;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t CC1101::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a1a5985308904261dd431f373d47ddee4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a11a92d885beefdf2db291301550a980c" name="a11a92d885beefdf2db291301550a980c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a92d885beefdf2db291301550a980c">&#9670;&#160;</a></span>readBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::readBit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to read and process data bit in direct reception mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin on which to read. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acda61fc99cfa373153c50c78380ed885">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a3563453988a83d22dd07d4691543a300" name="a3563453988a83d22dd07d4691543a300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3563453988a83d22dd07d4691543a300">&#9670;&#160;</a></span>readData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retrieved automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a8c79975a7bbe8a37f8214ecd1f69ba22" name="a8c79975a7bbe8a37f8214ecd1f69ba22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c79975a7bbe8a37f8214ecd1f69ba22">&#9670;&#160;</a></span>readData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data received after calling startReceive method. When the packet length is not known in advance, getPacketLength method must be called BEFORE calling readData! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be read. When set to 0, the packet length will be retreived automatically. When more bytes than received are requested, only the number of bytes requested will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a3563453988a83d22dd07d4691543a300">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae608fabef91defa1e33e6a6787c68ce8" name="ae608fabef91defa1e33e6a6787c68ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae608fabef91defa1e33e6a6787c68ce8">&#9670;&#160;</a></span>receive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Packet length, needed for some modules under special circumstances (e.g. LoRa implicit header mode). </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a4a7e12ef1eb2aaf9a5f39eeaa114e9f2" name="a4a7e12ef1eb2aaf9a5f39eeaa114e9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7e12ef1eb2aaf9a5f39eeaa114e9f2">&#9670;&#160;</a></span>receive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__typedefs.html#ga210f31dd2bff7fb80563275648a5bbbd">RadioLibTime_t</a>&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions. </td></tr>
    <tr><td class="paramname">timeout</td><td>Reception timeout in milliseconds. If set to 0, timeout period will be calculated automatically based on the radio configuration. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae608fabef91defa1e33e6a6787c68ce8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab053c185330519d58f364790108d29ac" name="ab053c185330519d58f364790108d29ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab053c185330519d58f364790108d29ac">&#9670;&#160;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts synchronous direct mode reception. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad9d1dbb2041e87af5a80e12f125a60e6">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9ec1ff1312d2caaae7e3e0389268fca2" name="a9ec1ff1312d2caaae7e3e0389268fca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec1ff1312d2caaae7e3e0389268fca2">&#9670;&#160;</a></span>receiveDirectAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::receiveDirectAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts asynchronous direct mode reception. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6fd22cdec29e1e34a92aa9854b90fdc9" name="a6fd22cdec29e1e34a92aa9854b90fdc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd22cdec29e1e34a92aa9854b90fdc9">&#9670;&#160;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets bit rate. Allowed values range from 0.025 to 600.0 kbps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>Bit rate to be set in kbps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aedd39ad84b45c6392087b12d59192d8c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="adc76af01dbc9171b3fdd7570624a4d4f" name="adc76af01dbc9171b3fdd7570624a4d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc76af01dbc9171b3fdd7570624a4d4f">&#9670;&#160;</a></span>setBitRateTolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setBitRateTolerance </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>brt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bit rate tolerance in BSCFG register. Allowed values are 0:(0%), 1(3,125%), 2:(6,25%) and 3:(12,5%). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">brt</td><td>Bit rate tolerance to be set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a60695681fc74a37f2a31a9638552e877" name="a60695681fc74a37f2a31a9638552e877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60695681fc74a37f2a31a9638552e877">&#9670;&#160;</a></span>setCrcFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setCrcFiltering </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable CRC filtering and generation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set or unset CRC generation and filtering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adf96e77f25b7e256891601bef04f35a6" name="adf96e77f25b7e256891601bef04f35a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf96e77f25b7e256891601bef04f35a6">&#9670;&#160;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets Gaussian filter bandwidth-time product that will be used for data shaping. Allowed value is RADIOLIB_SHAPING_0_5. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Gaussian shaping bandwidth-time product that will be used for data shaping. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aeba04366a0cf05ff3d8227c4f7c8e1e9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a544bb8d7be9c0e1ff7f7103b30925862" name="a544bb8d7be9c0e1ff7f7103b30925862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544bb8d7be9c0e1ff7f7103b30925862">&#9670;&#160;</a></span>setDIOMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setDIOMapping </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure DIO pin mapping to get a given signal on a DIO pin (if available). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin number onto which a signal is to be placed. </td></tr>
    <tr><td class="paramname">value</td><td>The value that indicates which function to place on that pin. See chip datasheet for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a349e8a22cd28ad89d45460fdeeefc05c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a24f4b059cc56238499c6117b88cd5505" name="a24f4b059cc56238499c6117b88cd5505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f4b059cc56238499c6117b88cd5505">&#9670;&#160;</a></span>setDirectAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setDirectAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set interrupt service routine function to call when data bit is receveid in direct mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Pointer to interrupt service routine. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#abf96cf4f3cb4c82d44be581dbe615966">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ab4b98eb6af33d006306bb7514ed216ea" name="ab4b98eb6af33d006306bb7514ed216ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b98eb6af33d006306bb7514ed216ea">&#9670;&#160;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Allowed values are RADIOLIB_ENCODING_NRZ, RADIOLIB_ENCODING_MANCHESTER, and RADIOLIB_ENCODING_WHITENING. Note that encoding on <a class="el" href="class_c_c1101.html" title="Control class for CC1101 module.">CC1101</a> is applied to the entire stream including preamble, sync word, and CRC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acb45b2342400a03a914a91d2ac7fb488">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad428d7e6fc9ac119101bb0716fa80bee" name="ad428d7e6fc9ac119101bb0716fa80bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad428d7e6fc9ac119101bb0716fa80bee">&#9670;&#160;</a></span>setFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets carrier frequency. Allowed values are in bands 300.0 to 348.0 MHz, 387.0 to 464.0 MHz and 779.0 to 928.0 MHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freq</td><td>Carrier frequency to be set in MHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a8a194b0fbb66b1a953288bf3b9478d6e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0d69713b9f20c9de354c13c3167b18b3" name="a0d69713b9f20c9de354c13c3167b18b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d69713b9f20c9de354c13c3167b18b3">&#9670;&#160;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets frequency deviation. Allowed values range from 1.587 to 380.8 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>Frequency deviation to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a2f4f9b428d9ea9af886ca85e5088ed7b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9bee13612cf4da067faeb57d18ee2eb7" name="a9bee13612cf4da067faeb57d18ee2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bee13612cf4da067faeb57d18ee2eb7">&#9670;&#160;</a></span>setGdo0Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setGdo0Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when GDO0 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
    <tr><td class="paramname">dir</td><td>Signal change direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad71efbe54590e4431f3286ab99536fe9" name="ad71efbe54590e4431f3286ab99536fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71efbe54590e4431f3286ab99536fe9">&#9670;&#160;</a></span>setGdo2Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setGdo2Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when GDO2 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
    <tr><td class="paramname">dir</td><td>Signal change direction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e62914790f132816134fc68c2bb5eb8" name="a6e62914790f132816134fc68c2bb5eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e62914790f132816134fc68c2bb5eb8">&#9670;&#160;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>numBroadcastAddrs</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets node and broadcast addresses. Calling this method will also enable address filtering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set. </td></tr>
    <tr><td class="paramname">numBroadcastAddrs</td><td>Number of broadcast addresses to be used. Can be set to 0 (no broadcast), 1 (broadcast at 0x00) or 2 (broadcast at 0x00 and 0xFF). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afa64d1ad4789d3146b38d14437234756" name="afa64d1ad4789d3146b38d14437234756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa64d1ad4789d3146b38d14437234756">&#9670;&#160;</a></span>setOOK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setOOK </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enableOOK</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/disables OOK modulation instead of FSK. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enableOOK</td><td>Enable (true) or disable (false) OOK. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5d6dce30fc7da668975b6da663784cdf" name="a5d6dce30fc7da668975b6da663784cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6dce30fc7da668975b6da663784cdf">&#9670;&#160;</a></span>setOutputPower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setOutputPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>pwr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets output power. Allowed values are -30, -20, -15, -10, 0, 5, 7 or 10 dBm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pwr</td><td>Output power to be set in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ad2286dc78dbf8e3084f38e9159b99ae5">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a29a16e8ed85432c6fae8d9e45399de6e" name="a29a16e8ed85432c6fae8d9e45399de6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a16e8ed85432c6fae8d9e45399de6e">&#9670;&#160;</a></span>setPacketReceivedAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setPacketReceivedAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aec928bb26f65752aa20cd236fbabb95c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a336999da23e554073a9fa628131883f5" name="a336999da23e554073a9fa628131883f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a336999da23e554073a9fa628131883f5">&#9670;&#160;</a></span>setPacketSentAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setPacketSentAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when a packet is sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a32b512b34f6575b2109ae3c3f35d1369">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae535dc268518c51d03c12defbaebe93e" name="ae535dc268518c51d03c12defbaebe93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae535dc268518c51d03c12defbaebe93e">&#9670;&#160;</a></span>setPreambleLength() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets preamble length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Preamble length to be set (in bits), allowed values: 16, 24, 32, 48, 64, 96, 128 and 192. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a85db1ff64e6c56e054f276c511194633">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae77c828c9c7cc12012fe011e8c4d3570" name="ae77c828c9c7cc12012fe011e8c4d3570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77c828c9c7cc12012fe011e8c4d3570">&#9670;&#160;</a></span>setPreambleLength() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>qualityThreshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets preamble length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set (in bits), allowed values: 16, 24, 32, 48, 64, 96, 128 and 192. </td></tr>
    <tr><td class="paramname">qualityThreshold</td><td>Preamble quality threshold (PQT) to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac1155543b27e46fa27aa4c9180da18bb" name="ac1155543b27e46fa27aa4c9180da18bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1155543b27e46fa27aa4c9180da18bb">&#9670;&#160;</a></span>setPromiscuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setPromiscuousMode </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCarrierSense</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in "sniff" mode: no packet filtering (e.g., no preamble, sync word, address, CRC). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set or unset promiscuous mode. </td></tr>
    <tr><td class="paramname">requireCarrierSense</td><td>Set carriersense required above threshold, defaults to false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5ef45183690bb1879f106af079b01140" name="a5ef45183690bb1879f106af079b01140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef45183690bb1879f106af079b01140">&#9670;&#160;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes: When idle both pins will be LOW, during TX the <code>txEn</code> pin will be HIGH, during RX the <code>rxPin</code> will be HIGH.   </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<p>When more than two pins or more control over the output values are needed, use the <a class="el" href="class_c_c1101.html#a7b401995be4bc136063a035ce1820634" title="Some modules contain external RF switch controlled by pins. This function gives RadioLib control over...">setRfSwitchTable()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin. </td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin.   </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b401995be4bc136063a035ce1820634" name="a7b401995be4bc136063a035ce1820634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b401995be4bc136063a035ce1820634">&#9670;&#160;</a></span>setRfSwitchTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CC1101::setRfSwitchTable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t(&amp;)&#160;</td>
          <td class="paramname"><em>pins</em>[Module::RFSWITCH_MAX_PINS], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a>&#160;</td>
          <td class="paramname"><em>table</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by pins. This function gives RadioLib control over those pins to automatically switch between various modes.   </p>
<p>Radiolib will automatically set the pin mode and value of these pins, so do not control them from the sketch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pins</td><td>A reference to an array of pins to control. This should always be an array of 3 elements. If you need less pins, use RADIOLIB_NC for the unused elements.</td></tr>
    <tr><td class="paramname">table</td><td>A reference to an array of pin values to use for each supported mode. Each element is an RfSwitchMode_T struct that lists the mode for which it applies and the values for each of the pins passed in the pins argument respectively.</td></tr>
  </table>
  </dd>
</dl>
<p>The <code>pins</code> array will be copied into the <a class="el" href="class_module.html" title="Implements all common low-level methods to control the wireless module. Every module class contains o...">Module</a> object, so the original array can be deallocated after this call. However, a reference to the <code>table</code> array will be stored, so that array must remain valid as long RadioLib is being used.</p>
<p>The <code>mode</code> field in each table row should normally use any of the <code>MODE_*</code> constants from the <a class="el" href="class_module.html#a5a67b3a63420d762ecba9448671c99bf" title="Constants to use in a mode table set be setRfSwitchTable. These constants work for most radios,...">Module::OpMode_t</a> enum. However, some radios support additional modes and will define their own OpMode_t enum.</p>
<p>The length of the table is variable (to support radios that add additional modes), so the table must always be terminated with the special END_OF_MODE_TABLE value.</p>
<p>Normally all modes should be listed in the table, but for some radios, modes can be omitted to indicate they are not supported (e.g. when a radio has a high power and low power TX mode but external circuitry only supports low power). If applicable, this is documented in the radio class itself.</p>
<h4>Example</h4>
<p>For example, on a board that has an RF switch with an enable pin connected to PA0 and a TX/RX select pin connected to PA1:</p>
<div class="fragment"><div class="line"><span class="comment">// In global scope, define the pin array and mode table</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t rfswitch_pins[] =</div>
<div class="line">                       {PA0,  PA1,  RADIOLIB_NC};</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code hl_struct" href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a> rfswitch_table[] = {</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a>,  {LOW,  LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a>,    {HIGH, LOW}},</div>
<div class="line">  {<a class="code hl_enumvalue" href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a>,    {HIGH, HIGH}},</div>
<div class="line">   Module::END_OF_MODE_TABLE,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> setup() {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Then somewhere in setup, pass them to radiolib</span></div>
<div class="line">  radio.setRfSwitchTable(rfswitch_pins, rfswitch_table);</div>
<div class="line">  ...</div>
<div class="line">}</div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa269f4bc8ba3eb3d8568feb7b2decf571">Module::MODE_TX</a></div><div class="ttdeci">@ MODE_TX</div><div class="ttdoc">Transmission mode.</div><div class="ttdef"><b>Definition</b> Module.h:119</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa505acc66c5e0faa83d2216aca5f3e671">Module::MODE_IDLE</a></div><div class="ttdeci">@ MODE_IDLE</div><div class="ttdoc">Idle mode.</div><div class="ttdef"><b>Definition</b> Module.h:113</div></div>
<div class="ttc" id="aclass_module_html_a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f"><div class="ttname"><a href="class_module.html#a5a67b3a63420d762ecba9448671c99bfa7664838bb0818663f55b3354fec8a18f">Module::MODE_RX</a></div><div class="ttdeci">@ MODE_RX</div><div class="ttdoc">Receive mode.</div><div class="ttdef"><b>Definition</b> Module.h:116</div></div>
<div class="ttc" id="astruct_module_1_1_rf_switch_mode__t_html"><div class="ttname"><a href="struct_module_1_1_rf_switch_mode__t.html">Module::RfSwitchMode_t</a></div><div class="ttdoc">Description of RF switch pin states for a single mode. See setRfSwitchTable for details.</div><div class="ttdef"><b>Definition</b> Module.h:89</div></div>
</div><!-- fragment -->   
</div>
</div>
<a id="a381d0059d7a0ccd8a2f54d7d3376f9b6" name="a381d0059d7a0ccd8a2f54d7d3376f9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381d0059d7a0ccd8a2f54d7d3376f9b6">&#9670;&#160;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets receiver bandwidth. Allowed values are 58, 68, 81, 102, 116, 135, 162, 203, 232, 270, 325, 406, 464, 541, 650 and 812 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth to be set in kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5345d819ea74f583e4e54f3496aa63eb" name="a5345d819ea74f583e4e54f3496aa63eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5345d819ea74f583e4e54f3496aa63eb">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxErrBits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCarrierSense</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets 1 or 2 bytes of sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>Pointer to the array of sync word bytes. </td></tr>
    <tr><td class="paramname">len</td><td>Sync word length in bytes. </td></tr>
    <tr><td class="paramname">maxErrBits</td><td>Maximum allowed number of bit errors in received sync word. Defaults to 0. </td></tr>
    <tr><td class="paramname">requireCarrierSense</td><td>Require carrier sense above threshold in addition to sync word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab299f0802f004c89ddab7c9192cd52ac" name="ab299f0802f004c89ddab7c9192cd52ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab299f0802f004c89ddab7c9192cd52ac">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>sync</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 1 or 2 bytes of sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sync</td><td>Pointer to the sync word. </td></tr>
    <tr><td class="paramname">len</td><td>Sync word length in bytes. Maximum length depends on the module used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a6c71cdc1238e1368274670758431a977">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a433f1a40b33be6c84d3665a1b4cd57d6" name="a433f1a40b33be6c84d3665a1b4cd57d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433f1a40b33be6c84d3665a1b4cd57d6">&#9670;&#160;</a></span>setSyncWord() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxErrBits</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>requireCarrierSense</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets 16-bit sync word as a two byte value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncH</td><td>MSB of the sync word. </td></tr>
    <tr><td class="paramname">syncL</td><td>LSB of the sync word. </td></tr>
    <tr><td class="paramname">maxErrBits</td><td>Maximum allowed number of bit errors in received sync word. Defaults to 0. </td></tr>
    <tr><td class="paramname">requireCarrierSense</td><td>Require carrier sense above threshold in addition to sync word. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a0ead6224d4378274df465f779199bc92" name="a0ead6224d4378274df465f779199bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ead6224d4378274df465f779199bc92">&#9670;&#160;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::sleep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to sleep mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af1bb9a5da26da8829795ebb72e9c666e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7612bf81e48086004c62548de2682266" name="a7612bf81e48086004c62548de2682266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7612bf81e48086004c62548de2682266">&#9670;&#160;</a></span>standby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby mode. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#acbcaf6aefcb77a354797e66222fe5018">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af374ad0ecd820a01baef7d177a30132a" name="af374ad0ecd820a01baef7d177a30132a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af374ad0ecd820a01baef7d177a30132a">&#9670;&#160;</a></span>standby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Standby mode to be used. No effect, implemented only for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a7d5da4311092e3df6b193ff303a0c5e8">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae71e947abf6a07b194c6c6d64fd3eb19" name="ae71e947abf6a07b194c6c6d64fd3eb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71e947abf6a07b194c6c6d64fd3eb19">&#9670;&#160;</a></span>startReceive() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::startReceive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. GDO0 will be activated when full packet is received. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#a18664ad615c5507ff1690baaca90b094">PhysicalLayer</a>.</p>

</div>
</div>
<a id="abf153c8fcf2a0d60439426b03692642e" name="abf153c8fcf2a0d60439426b03692642e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf153c8fcf2a0d60439426b03692642e">&#9670;&#160;</a></span>startReceive() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irqFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>irqMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven receive method, implemented for compatibility with <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Ignored. </td></tr>
    <tr><td class="paramname">irqFlags</td><td>Ignored. </td></tr>
    <tr><td class="paramname">irqMask</td><td>Ignored. </td></tr>
    <tr><td class="paramname">len</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ae93500dfbcfd39837e04c0f3eaa40d97">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27" name="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&#160;</a></span>startTransmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af79757dbbd62e080c1bad2e608ab940c" name="af79757dbbd62e080c1bad2e608ab940c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79757dbbd62e080c1bad2e608ab940c">&#9670;&#160;</a></span>startTransmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af79757dbbd62e080c1bad2e608ab940c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a6ff7e4066d189482c142e05384a38df0" name="a6ff7e4066d189482c142e05384a38df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff7e4066d189482c142e05384a38df0">&#9670;&#160;</a></span>startTransmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::startTransmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method for packets less than 64 bytes. Method blocks for packets longer than 64 bytes up to a 255 byte limit, until the last bytes are placed in the FIFO. Some limitations and issues apply; see discussion: <a href="https://github.com/jgromes/RadioLib/discussions/1138">https://github.com/jgromes/RadioLib/discussions/1138</a> Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#af79757dbbd62e080c1bad2e608ab940c">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534" name="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&#160;</a></span>transmit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted. </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ada508497ee2e70170da3afe078e2fe0e" name="ada508497ee2e70170da3afe078e2fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada508497ee2e70170da3afe078e2fe0e">&#9670;&#160;</a></span>transmit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted. </td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes). </td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a5086eb8a27aa842e94d1df54f385c39b" name="a5086eb8a27aa842e94d1df54f385c39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5086eb8a27aa842e94d1df54f385c39b">&#9670;&#160;</a></span>transmit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::transmit </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent. </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send. </td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#ada508497ee2e70170da3afe078e2fe0e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a240eef8fa7d838d76f3c11086dc50e46" name="a240eef8fa7d838d76f3c11086dc50e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240eef8fa7d838d76f3c11086dc50e46">&#9670;&#160;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts synchronous direct mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>Raw RF frequency value. Defaults to 0, required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Reimplemented from <a class="el" href="class_physical_layer.html#aa4c99ac794ee653c2061be4201724b65">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aef7c152858537a40e71cf133962cb893" name="aef7c152858537a40e71cf133962cb893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7c152858537a40e71cf133962cb893">&#9670;&#160;</a></span>transmitDirectAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::transmitDirectAsync </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts asynchronous direct mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>Raw RF frequency value. Defaults to 0, required for quick frequency shifts in RTTY. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a50b9e73d2d82a4cd03841f465825b73f" name="a50b9e73d2d82a4cd03841f465825b73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b9e73d2d82a4cd03841f465825b73f">&#9670;&#160;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t CC1101::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>RADIOLIB_CC1101_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxLen</td><td>Maximum packet length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/CC1101/<a class="el" href="_c_c1101_8h_source.html">CC1101.h</a></li>
<li>src/modules/CC1101/<b>CC1101.cpp</b></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_c_c1101.html">CC1101</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
