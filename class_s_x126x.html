<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RadioLib: SX126x Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RadioLib
   </div>
   <div id="projectbrief">Universal wireless communication library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_s_x126x.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_x126x-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SX126x Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for SX126x series. All derived classes for SX126x (e.g. <a class="el" href="class_s_x1262.html" title="Derived class for SX1262 modules.">SX1262</a> or <a class="el" href="class_s_x1268.html" title="Derived class for SX1268 modules.">SX1268</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes.  
 <a href="class_s_x126x.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_s_x126x_8h_source.html">SX126x.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SX126x:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_x126x.png" usemap="#SX126x_map" alt=""/>
  <map id="SX126x_map" name="SX126x_map">
<area href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN...." alt="PhysicalLayer" shape="rect" coords="103,0,196,24"/>
<area href="class_s_x1262.html" title="Derived class for SX1262 modules." alt="SX1262" shape="rect" coords="51,112,144,136"/>
<area href="class_s_x1268.html" title="Derived class for SX1268 modules." alt="SX1268" shape="rect" coords="154,112,247,136"/>
<area href="class_l_l_c_c68.html" title="Derived class for LLCC68 modules." alt="LLCC68" shape="rect" coords="0,168,93,192"/>
<area href="class_s_x1261.html" title="Derived class for SX1261 modules." alt="SX1261" shape="rect" coords="103,168,196,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaca5a8fa8a3e634dd1b5b4c2bb5058d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aaca5a8fa8a3e634dd1b5b4c2bb5058d8">SX126x</a> (<a class="el" href="class_module.html">Module</a> *mod)</td></tr>
<tr class="memdesc:aaca5a8fa8a3e634dd1b5b4c2bb5058d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_s_x126x.html#aaca5a8fa8a3e634dd1b5b4c2bb5058d8">More...</a><br /></td></tr>
<tr class="separator:aaca5a8fa8a3e634dd1b5b4c2bb5058d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97488c6887df2e0291bba1b852605e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a1b97488c6887df2e0291bba1b852605e">begin</a> (float bw, uint8_t sf, uint8_t cr, uint8_t syncWord, uint16_t preambleLength, float tcxoVoltage, bool useRegulatorLDO=false)</td></tr>
<tr class="memdesc:a1b97488c6887df2e0291bba1b852605e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for LoRa modem.  <a href="class_s_x126x.html#a1b97488c6887df2e0291bba1b852605e">More...</a><br /></td></tr>
<tr class="separator:a1b97488c6887df2e0291bba1b852605e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e500e5b6044ccab8f6b19af4ffa917c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a2e500e5b6044ccab8f6b19af4ffa917c">beginFSK</a> (float br, float freqDev, float rxBw, uint16_t preambleLength, float tcxoVoltage, bool useRegulatorLDO=false)</td></tr>
<tr class="memdesc:a2e500e5b6044ccab8f6b19af4ffa917c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization method for FSK modem.  <a href="class_s_x126x.html#a2e500e5b6044ccab8f6b19af4ffa917c">More...</a><br /></td></tr>
<tr class="separator:a2e500e5b6044ccab8f6b19af4ffa917c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aa6dd05dd32ef717a06cc8ba28ff71f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a9aa6dd05dd32ef717a06cc8ba28ff71f">reset</a> (bool verify=true)</td></tr>
<tr class="memdesc:a9aa6dd05dd32ef717a06cc8ba28ff71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset method. Will reset the chip to the default state using RST pin.  <a href="class_s_x126x.html#a9aa6dd05dd32ef717a06cc8ba28ff71f">More...</a><br /></td></tr>
<tr class="separator:a9aa6dd05dd32ef717a06cc8ba28ff71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab18364237ddac0c56aeaf63f08cf009"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aab18364237ddac0c56aeaf63f08cf009">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:aab18364237ddac0c56aeaf63f08cf009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_s_x126x.html#aab18364237ddac0c56aeaf63f08cf009">More...</a><br /></td></tr>
<tr class="separator:aab18364237ddac0c56aeaf63f08cf009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3db6b29c482d94eef8a43cd8b5751c0"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae3db6b29c482d94eef8a43cd8b5751c0">receive</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:ae3db6b29c482d94eef8a43cd8b5751c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_s_x126x.html#ae3db6b29c482d94eef8a43cd8b5751c0">More...</a><br /></td></tr>
<tr class="separator:ae3db6b29c482d94eef8a43cd8b5751c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921aa8afb8d33b2660731c1f8d67664b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a921aa8afb8d33b2660731c1f8d67664b">transmitDirect</a> (uint32_t frf=0) override</td></tr>
<tr class="memdesc:a921aa8afb8d33b2660731c1f8d67664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode transmission.  <a href="class_s_x126x.html#a921aa8afb8d33b2660731c1f8d67664b">More...</a><br /></td></tr>
<tr class="separator:a921aa8afb8d33b2660731c1f8d67664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a18aee2bf05793aa29b5cf6b47bb435"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a8a18aee2bf05793aa29b5cf6b47bb435">receiveDirect</a> () override</td></tr>
<tr class="memdesc:a8a18aee2bf05793aa29b5cf6b47bb435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as SX126x series does not support direct mode reception. Will always return ERR_UNKNOWN.  <a href="class_s_x126x.html#a8a18aee2bf05793aa29b5cf6b47bb435">More...</a><br /></td></tr>
<tr class="separator:a8a18aee2bf05793aa29b5cf6b47bb435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f24414bd684434c310df54b3558f21"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae9f24414bd684434c310df54b3558f21">scanChannel</a> ()</td></tr>
<tr class="memdesc:ae9f24414bd684434c310df54b3558f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs scan for LoRa transmission in the current channel. Detects both preamble and payload.  <a href="class_s_x126x.html#ae9f24414bd684434c310df54b3558f21">More...</a><br /></td></tr>
<tr class="separator:ae9f24414bd684434c310df54b3558f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5509f0705cdd971065251ed6b2fb4e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#afb5509f0705cdd971065251ed6b2fb4e">sleep</a> (bool retainConfig=true)</td></tr>
<tr class="memdesc:afb5509f0705cdd971065251ed6b2fb4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to sleep mode.  <a href="class_s_x126x.html#afb5509f0705cdd971065251ed6b2fb4e">More...</a><br /></td></tr>
<tr class="separator:afb5509f0705cdd971065251ed6b2fb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1579e2557c36a4a34b09039c0d0c71"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a7a1579e2557c36a4a34b09039c0d0c71">standby</a> () override</td></tr>
<tr class="memdesc:a7a1579e2557c36a4a34b09039c0d0c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator).  <a href="class_s_x126x.html#a7a1579e2557c36a4a34b09039c0d0c71">More...</a><br /></td></tr>
<tr class="separator:a7a1579e2557c36a4a34b09039c0d0c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7569396f09f3867dc1bd4d4a0613acd"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ad7569396f09f3867dc1bd4d4a0613acd">standby</a> (uint8_t mode)</td></tr>
<tr class="memdesc:ad7569396f09f3867dc1bd4d4a0613acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module to standby mode.  <a href="class_s_x126x.html#ad7569396f09f3867dc1bd4d4a0613acd">More...</a><br /></td></tr>
<tr class="separator:ad7569396f09f3867dc1bd4d4a0613acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da667fe702d7b4aafaa4bf7e69ea40d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a0da667fe702d7b4aafaa4bf7e69ea40d">setDio1Action</a> (void(*func)(void))</td></tr>
<tr class="memdesc:a0da667fe702d7b4aafaa4bf7e69ea40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets interrupt service routine to call when DIO1 activates.  <a href="class_s_x126x.html#a0da667fe702d7b4aafaa4bf7e69ea40d">More...</a><br /></td></tr>
<tr class="separator:a0da667fe702d7b4aafaa4bf7e69ea40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6848afe4c16a47edb3e0b342a86ecdfd"><td class="memItemLeft" align="right" valign="top"><a id="a6848afe4c16a47edb3e0b342a86ecdfd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a6848afe4c16a47edb3e0b342a86ecdfd">clearDio1Action</a> ()</td></tr>
<tr class="memdesc:a6848afe4c16a47edb3e0b342a86ecdfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears interrupt service routine to call when DIO1 activates. <br /></td></tr>
<tr class="separator:a6848afe4c16a47edb3e0b342a86ecdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab843614658a79db7aa24e48d5b6e84f1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ab843614658a79db7aa24e48d5b6e84f1">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0) override</td></tr>
<tr class="memdesc:ab843614658a79db7aa24e48d5b6e84f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>.  <a href="class_s_x126x.html#ab843614658a79db7aa24e48d5b6e84f1">More...</a><br /></td></tr>
<tr class="separator:ab843614658a79db7aa24e48d5b6e84f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5052dc09f4b10ee22e169129f368685f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a5052dc09f4b10ee22e169129f368685f">startReceive</a> (uint32_t timeout=SX126X_RX_TIMEOUT_INF)</td></tr>
<tr class="memdesc:a5052dc09f4b10ee22e169129f368685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method. DIO1 will be activated when full packet is received.  <a href="class_s_x126x.html#a5052dc09f4b10ee22e169129f368685f">More...</a><br /></td></tr>
<tr class="separator:a5052dc09f4b10ee22e169129f368685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc46b6adda2d0e82e25ed1fc78274136"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#adc46b6adda2d0e82e25ed1fc78274136">startReceiveDutyCycle</a> (uint32_t rxPeriod, uint32_t sleepPeriod)</td></tr>
<tr class="memdesc:adc46b6adda2d0e82e25ed1fc78274136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven receive method where the device mostly sleeps and periodically wakes to listen. Note that this function assumes the unit will take 500us + TCXO_delay to change state. See datasheet section 13.1.7, version 1.2.  <a href="class_s_x126x.html#adc46b6adda2d0e82e25ed1fc78274136">More...</a><br /></td></tr>
<tr class="separator:adc46b6adda2d0e82e25ed1fc78274136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b50cb78f02a3d93939437eb48489d3f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a6b50cb78f02a3d93939437eb48489d3f">startReceiveDutyCycleAuto</a> (uint16_t senderPreambleLength=0, uint16_t minSymbols=8)</td></tr>
<tr class="memdesc:a6b50cb78f02a3d93939437eb48489d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_s_x126x.html#adc46b6adda2d0e82e25ed1fc78274136">startReceiveDutyCycle</a> with rxPeriod and sleepPeriod set so the unit shouldn't miss any messages.  <a href="class_s_x126x.html#a6b50cb78f02a3d93939437eb48489d3f">More...</a><br /></td></tr>
<tr class="separator:a6b50cb78f02a3d93939437eb48489d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3350cbfab628956c1a456383ac7bb2b2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a3350cbfab628956c1a456383ac7bb2b2">readData</a> (uint8_t *data, size_t len) override</td></tr>
<tr class="memdesc:a3350cbfab628956c1a456383ac7bb2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data received after calling startReceive method.  <a href="class_s_x126x.html#a3350cbfab628956c1a456383ac7bb2b2">More...</a><br /></td></tr>
<tr class="separator:a3350cbfab628956c1a456383ac7bb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f60df59c80241d98ce078c0417a7f08"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a2f60df59c80241d98ce078c0417a7f08">setBandwidth</a> (float bw)</td></tr>
<tr class="memdesc:a2f60df59c80241d98ce078c0417a7f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa bandwidth. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0 and 500.0 kHz.  <a href="class_s_x126x.html#a2f60df59c80241d98ce078c0417a7f08">More...</a><br /></td></tr>
<tr class="separator:a2f60df59c80241d98ce078c0417a7f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5993359ace652fbdc862eb23fdd263d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae5993359ace652fbdc862eb23fdd263d">setSpreadingFactor</a> (uint8_t sf)</td></tr>
<tr class="memdesc:ae5993359ace652fbdc862eb23fdd263d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa spreading factor. Allowed values range from 5 to 12.  <a href="class_s_x126x.html#ae5993359ace652fbdc862eb23fdd263d">More...</a><br /></td></tr>
<tr class="separator:ae5993359ace652fbdc862eb23fdd263d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3113858966e878e9c67a1e710bd586"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#afd3113858966e878e9c67a1e710bd586">setCodingRate</a> (uint8_t cr)</td></tr>
<tr class="memdesc:afd3113858966e878e9c67a1e710bd586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa coding rate denominator. Allowed values range from 5 to 8.  <a href="class_s_x126x.html#afd3113858966e878e9c67a1e710bd586">More...</a><br /></td></tr>
<tr class="separator:afd3113858966e878e9c67a1e710bd586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d92dce566f8aefa836fe8f332e9560f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a9d92dce566f8aefa836fe8f332e9560f">setSyncWord</a> (uint8_t syncWord, uint8_t controlBits=0x44)</td></tr>
<tr class="memdesc:a9d92dce566f8aefa836fe8f332e9560f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets LoRa sync word.  <a href="class_s_x126x.html#a9d92dce566f8aefa836fe8f332e9560f">More...</a><br /></td></tr>
<tr class="separator:a9d92dce566f8aefa836fe8f332e9560f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f971dca834be7e0470a9a9f0c01854e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a8f971dca834be7e0470a9a9f0c01854e">setCurrentLimit</a> (float currentLimit)</td></tr>
<tr class="memdesc:a8f971dca834be7e0470a9a9f0c01854e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets current protection limit. Can be set in 0.25 mA steps.  <a href="class_s_x126x.html#a8f971dca834be7e0470a9a9f0c01854e">More...</a><br /></td></tr>
<tr class="separator:a8f971dca834be7e0470a9a9f0c01854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa668babb0bd129b2facee9fd280525ab"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aa668babb0bd129b2facee9fd280525ab">getCurrentLimit</a> ()</td></tr>
<tr class="memdesc:aa668babb0bd129b2facee9fd280525ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads current protection limit.  <a href="class_s_x126x.html#aa668babb0bd129b2facee9fd280525ab">More...</a><br /></td></tr>
<tr class="separator:aa668babb0bd129b2facee9fd280525ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00f765bbfbfaa8c693532ea3a90c29b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ab00f765bbfbfaa8c693532ea3a90c29b">setPreambleLength</a> (uint16_t preambleLength)</td></tr>
<tr class="memdesc:ab00f765bbfbfaa8c693532ea3a90c29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets preamble length for LoRa or FSK modem. Allowed values range from 1 to 65535.  <a href="class_s_x126x.html#ab00f765bbfbfaa8c693532ea3a90c29b">More...</a><br /></td></tr>
<tr class="separator:ab00f765bbfbfaa8c693532ea3a90c29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd95a5f2e39ae8fb1a3040e77fa21a3"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a7cd95a5f2e39ae8fb1a3040e77fa21a3">setFrequencyDeviation</a> (float freqDev) override</td></tr>
<tr class="memdesc:a7cd95a5f2e39ae8fb1a3040e77fa21a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK frequency deviation. Allowed values range from 0.0 to 200.0 kHz.  <a href="class_s_x126x.html#a7cd95a5f2e39ae8fb1a3040e77fa21a3">More...</a><br /></td></tr>
<tr class="separator:a7cd95a5f2e39ae8fb1a3040e77fa21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7deeef45d7f64a4018a3e56aaea4eb0e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a7deeef45d7f64a4018a3e56aaea4eb0e">setBitRate</a> (float br)</td></tr>
<tr class="memdesc:a7deeef45d7f64a4018a3e56aaea4eb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK bit rate. Allowed values range from 0.6 to 300.0 kbps.  <a href="class_s_x126x.html#a7deeef45d7f64a4018a3e56aaea4eb0e">More...</a><br /></td></tr>
<tr class="separator:a7deeef45d7f64a4018a3e56aaea4eb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d443c02d4620cda32c63a00c6bcc22"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a59d443c02d4620cda32c63a00c6bcc22">setRxBandwidth</a> (float rxBw)</td></tr>
<tr class="memdesc:a59d443c02d4620cda32c63a00c6bcc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz.  <a href="class_s_x126x.html#a59d443c02d4620cda32c63a00c6bcc22">More...</a><br /></td></tr>
<tr class="separator:a59d443c02d4620cda32c63a00c6bcc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8f4deb555844b24c2426dd86e69676"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a1d8f4deb555844b24c2426dd86e69676">setDataShaping</a> (uint8_t sh) override</td></tr>
<tr class="memdesc:a1d8f4deb555844b24c2426dd86e69676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping.  <a href="class_s_x126x.html#a1d8f4deb555844b24c2426dd86e69676">More...</a><br /></td></tr>
<tr class="separator:a1d8f4deb555844b24c2426dd86e69676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e6d7831f35893a5b8328c10a2901bf"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a38e6d7831f35893a5b8328c10a2901bf">setSyncWord</a> (uint8_t *syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a38e6d7831f35893a5b8328c10a2901bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK sync word in the form of array of up to 8 bytes.  <a href="class_s_x126x.html#a38e6d7831f35893a5b8328c10a2901bf">More...</a><br /></td></tr>
<tr class="separator:a38e6d7831f35893a5b8328c10a2901bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac594fbb30c5010658c970a64654c7162"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ac594fbb30c5010658c970a64654c7162">setSyncBits</a> (uint8_t *syncWord, uint8_t bitsLen)</td></tr>
<tr class="memdesc:ac594fbb30c5010658c970a64654c7162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK sync word in the form of array of up to 8 bytes.  <a href="class_s_x126x.html#ac594fbb30c5010658c970a64654c7162">More...</a><br /></td></tr>
<tr class="separator:ac594fbb30c5010658c970a64654c7162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514cabe74bbe3434d7e4f244c4077752"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a514cabe74bbe3434d7e4f244c4077752">setNodeAddress</a> (uint8_t nodeAddr)</td></tr>
<tr class="memdesc:a514cabe74bbe3434d7e4f244c4077752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets node address. Calling this method will also enable address filtering for node address only.  <a href="class_s_x126x.html#a514cabe74bbe3434d7e4f244c4077752">More...</a><br /></td></tr>
<tr class="separator:a514cabe74bbe3434d7e4f244c4077752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8eea7e468db3d6064c19d4934d5034"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#abd8eea7e468db3d6064c19d4934d5034">setBroadcastAddress</a> (uint8_t broadAddr)</td></tr>
<tr class="memdesc:abd8eea7e468db3d6064c19d4934d5034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address.  <a href="class_s_x126x.html#abd8eea7e468db3d6064c19d4934d5034">More...</a><br /></td></tr>
<tr class="separator:abd8eea7e468db3d6064c19d4934d5034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3a7a42c401b6c44e00cb6c5b9696f2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#afc3a7a42c401b6c44e00cb6c5b9696f2">disableAddressFiltering</a> ()</td></tr>
<tr class="memdesc:afc3a7a42c401b6c44e00cb6c5b9696f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables address filtering. Calling this method will also erase previously set addresses.  <a href="class_s_x126x.html#afc3a7a42c401b6c44e00cb6c5b9696f2">More...</a><br /></td></tr>
<tr class="separator:afc3a7a42c401b6c44e00cb6c5b9696f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95007639c2648a1dbb614493224606f1"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a95007639c2648a1dbb614493224606f1">setCRC</a> (uint8_t len, uint16_t initial=0x1D0F, uint16_t polynomial=0x1021, bool inverted=true)</td></tr>
<tr class="memdesc:a95007639c2648a1dbb614493224606f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets CRC configuration.  <a href="class_s_x126x.html#a95007639c2648a1dbb614493224606f1">More...</a><br /></td></tr>
<tr class="separator:a95007639c2648a1dbb614493224606f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67702de41ae866b9f9d73234fc9ae376"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a67702de41ae866b9f9d73234fc9ae376">setWhitening</a> (bool enabled, uint16_t initial=0x0100)</td></tr>
<tr class="memdesc:a67702de41ae866b9f9d73234fc9ae376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets FSK whitening parameters.  <a href="class_s_x126x.html#a67702de41ae866b9f9d73234fc9ae376">More...</a><br /></td></tr>
<tr class="separator:a67702de41ae866b9f9d73234fc9ae376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bee6f4b3a3b7ec646ac8de347ee0d6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a57bee6f4b3a3b7ec646ac8de347ee0d6">setTCXO</a> (float voltage, uint32_t delay=5000)</td></tr>
<tr class="memdesc:a57bee6f4b3a3b7ec646ac8de347ee0d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TCXO (Temperature Compensated Crystal Oscillator) configuration.  <a href="class_s_x126x.html#a57bee6f4b3a3b7ec646ac8de347ee0d6">More...</a><br /></td></tr>
<tr class="separator:a57bee6f4b3a3b7ec646ac8de347ee0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46e08d579f4acbad029b4cd4f4fffaf"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae46e08d579f4acbad029b4cd4f4fffaf">setDio2AsRfSwitch</a> (bool enable=true)</td></tr>
<tr class="memdesc:ae46e08d579f4acbad029b4cd4f4fffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set DIO2 to function as RF switch (default in Semtech example designs).  <a href="class_s_x126x.html#ae46e08d579f4acbad029b4cd4f4fffaf">More...</a><br /></td></tr>
<tr class="separator:ae46e08d579f4acbad029b4cd4f4fffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe2d75b1e2df8bcc58c4fd9d8e6e4f9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#acbe2d75b1e2df8bcc58c4fd9d8e6e4f9">getDataRate</a> () const</td></tr>
<tr class="memdesc:acbe2d75b1e2df8bcc58c4fd9d8e6e4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets effective data rate for the last transmitted packet. The value is calculated only for payload bytes.  <a href="class_s_x126x.html#acbe2d75b1e2df8bcc58c4fd9d8e6e4f9">More...</a><br /></td></tr>
<tr class="separator:acbe2d75b1e2df8bcc58c4fd9d8e6e4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5f0032a91686b9673a48c908eb1925"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a0e5f0032a91686b9673a48c908eb1925">getRSSI</a> ()</td></tr>
<tr class="memdesc:a0e5f0032a91686b9673a48c908eb1925"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets RSSI (Recorded Signal Strength Indicator) of the last received packet.  <a href="class_s_x126x.html#a0e5f0032a91686b9673a48c908eb1925">More...</a><br /></td></tr>
<tr class="separator:a0e5f0032a91686b9673a48c908eb1925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36823d3539667bdf7d2f073bd4fa1ca"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae36823d3539667bdf7d2f073bd4fa1ca">getSNR</a> ()</td></tr>
<tr class="memdesc:ae36823d3539667bdf7d2f073bd4fa1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem.  <a href="class_s_x126x.html#ae36823d3539667bdf7d2f073bd4fa1ca">More...</a><br /></td></tr>
<tr class="separator:ae36823d3539667bdf7d2f073bd4fa1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ef8c8751a3c09d64e431684840c987"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ac4ef8c8751a3c09d64e431684840c987">getPacketLength</a> (bool update=true) override</td></tr>
<tr class="memdesc:ac4ef8c8751a3c09d64e431684840c987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query modem for the packet length of received payload.  <a href="class_s_x126x.html#ac4ef8c8751a3c09d64e431684840c987">More...</a><br /></td></tr>
<tr class="separator:ac4ef8c8751a3c09d64e431684840c987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa768ce757a0f7ee66cdd72cab7a855fa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aa768ce757a0f7ee66cdd72cab7a855fa">fixedPacketLengthMode</a> (uint8_t len=SX126X_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:aa768ce757a0f7ee66cdd72cab7a855fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in fixed packet length mode. Available in FSK mode only.  <a href="class_s_x126x.html#aa768ce757a0f7ee66cdd72cab7a855fa">More...</a><br /></td></tr>
<tr class="separator:aa768ce757a0f7ee66cdd72cab7a855fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11ab2c6f4488daf2ece93288e05c504"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aa11ab2c6f4488daf2ece93288e05c504">variablePacketLengthMode</a> (uint8_t maxLen=SX126X_MAX_PACKET_LENGTH)</td></tr>
<tr class="memdesc:aa11ab2c6f4488daf2ece93288e05c504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set modem in variable packet length mode. Available in FSK mode only.  <a href="class_s_x126x.html#aa11ab2c6f4488daf2ece93288e05c504">More...</a><br /></td></tr>
<tr class="separator:aa11ab2c6f4488daf2ece93288e05c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e342ddbef84cf845bef8f4448b8da10"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a7e342ddbef84cf845bef8f4448b8da10">getTimeOnAir</a> (size_t len)</td></tr>
<tr class="memdesc:a7e342ddbef84cf845bef8f4448b8da10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get expected time-on-air for a given size of payload.  <a href="class_s_x126x.html#a7e342ddbef84cf845bef8f4448b8da10">More...</a><br /></td></tr>
<tr class="separator:a7e342ddbef84cf845bef8f4448b8da10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae36664f9c605a8fe74b2f357e0ec3323"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae36664f9c605a8fe74b2f357e0ec3323">getRSSIInst</a> ()</td></tr>
<tr class="memdesc:ae36664f9c605a8fe74b2f357e0ec3323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instantaneous RSSI value during recption of the packet. Should switch to FSK receive mode for LBT implementation.  <a href="class_s_x126x.html#ae36664f9c605a8fe74b2f357e0ec3323">More...</a><br /></td></tr>
<tr class="separator:ae36664f9c605a8fe74b2f357e0ec3323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec09cba71494bd927ad1da786606ca6"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#adec09cba71494bd927ad1da786606ca6">implicitHeader</a> (size_t len)</td></tr>
<tr class="memdesc:adec09cba71494bd927ad1da786606ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set implicit header mode for future reception/transmission.  <a href="class_s_x126x.html#adec09cba71494bd927ad1da786606ca6">More...</a><br /></td></tr>
<tr class="separator:adec09cba71494bd927ad1da786606ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3765f534418d4e0540c179621c019138"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a3765f534418d4e0540c179621c019138">explicitHeader</a> ()</td></tr>
<tr class="memdesc:a3765f534418d4e0540c179621c019138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set explicit header mode for future reception/transmission.  <a href="class_s_x126x.html#a3765f534418d4e0540c179621c019138">More...</a><br /></td></tr>
<tr class="separator:a3765f534418d4e0540c179621c019138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c263ce1a339faa74c568d9afb81cd2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a21c263ce1a339faa74c568d9afb81cd2">setRegulatorLDO</a> ()</td></tr>
<tr class="memdesc:a21c263ce1a339faa74c568d9afb81cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set regulator mode to LDO.  <a href="class_s_x126x.html#a21c263ce1a339faa74c568d9afb81cd2">More...</a><br /></td></tr>
<tr class="separator:a21c263ce1a339faa74c568d9afb81cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae69309ca0cf5f13c60f2d162916ff8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a5ae69309ca0cf5f13c60f2d162916ff8">setRegulatorDCDC</a> ()</td></tr>
<tr class="memdesc:a5ae69309ca0cf5f13c60f2d162916ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set regulator mode to DC-DC.  <a href="class_s_x126x.html#a5ae69309ca0cf5f13c60f2d162916ff8">More...</a><br /></td></tr>
<tr class="separator:a5ae69309ca0cf5f13c60f2d162916ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3eb51117558c58384b03de4b7bfe60"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a2b3eb51117558c58384b03de4b7bfe60">setEncoding</a> (uint8_t encoding) override</td></tr>
<tr class="memdesc:a2b3eb51117558c58384b03de4b7bfe60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets transmission encoding. Available in FSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <a href="class_s_x126x.html#a2b3eb51117558c58384b03de4b7bfe60">More...</a><br /></td></tr>
<tr class="separator:a2b3eb51117558c58384b03de4b7bfe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288257242e483cb3eb6944333179dd26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a288257242e483cb3eb6944333179dd26">setRfSwitchPins</a> (RADIOLIB_PIN_TYPE rxEn, RADIOLIB_PIN_TYPE txEn)</td></tr>
<tr class="memdesc:a288257242e483cb3eb6944333179dd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some modules contain external RF switch controlled by two pins. This function gives RadioLib control over those two pins to automatically switch Rx and Tx state. When using automatic RF switch control, DO NOT change the pin mode of rxEn or txEn from Arduino sketch!  <a href="class_s_x126x.html#a288257242e483cb3eb6944333179dd26">More...</a><br /></td></tr>
<tr class="separator:a288257242e483cb3eb6944333179dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420c23bb1861646e29f44c0f4c646ee8"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a420c23bb1861646e29f44c0f4c646ee8">forceLDRO</a> (bool enable)</td></tr>
<tr class="memdesc:a420c23bb1861646e29f44c0f4c646ee8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forces LoRa low data rate optimization. Only available in LoRa mode. After calling this method, LDRO will always be set to the provided value, regardless of symbol length. To re-enable automatic LDRO configuration, call <a class="el" href="class_s_x126x.html#ab9ce38cfeaa36ddcc2d82b2974d7088c" title="Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method,...">SX126x::autoLDRO()</a>  <a href="class_s_x126x.html#a420c23bb1861646e29f44c0f4c646ee8">More...</a><br /></td></tr>
<tr class="separator:a420c23bb1861646e29f44c0f4c646ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ce38cfeaa36ddcc2d82b2974d7088c"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ab9ce38cfeaa36ddcc2d82b2974d7088c">autoLDRO</a> ()</td></tr>
<tr class="memdesc:ab9ce38cfeaa36ddcc2d82b2974d7088c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method, LDRO will be enabled automatically when symbol length exceeds 16 ms.  <a href="class_s_x126x.html#ab9ce38cfeaa36ddcc2d82b2974d7088c">More...</a><br /></td></tr>
<tr class="separator:ab9ce38cfeaa36ddcc2d82b2974d7088c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819bb3ced0f184a63cbfbef408a68561"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a819bb3ced0f184a63cbfbef408a68561">randomByte</a> ()</td></tr>
<tr class="memdesc:a819bb3ced0f184a63cbfbef408a68561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get one truly random byte from RSSI noise.  <a href="class_s_x126x.html#a819bb3ced0f184a63cbfbef408a68561">More...</a><br /></td></tr>
<tr class="separator:a819bb3ced0f184a63cbfbef408a68561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf8b4623da8c2caa83a8c3d35a44d0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#abbf8b4623da8c2caa83a8c3d35a44d0a">setDirectAction</a> (void(*func)(void))</td></tr>
<tr class="memdesc:abbf8b4623da8c2caa83a8c3d35a44d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy method, to ensure <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <a href="class_s_x126x.html#abbf8b4623da8c2caa83a8c3d35a44d0a">More...</a><br /></td></tr>
<tr class="separator:abbf8b4623da8c2caa83a8c3d35a44d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff80db65e546934980feac7e6c81dd80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aff80db65e546934980feac7e6c81dd80">readBit</a> (RADIOLIB_PIN_TYPE pin)</td></tr>
<tr class="memdesc:aff80db65e546934980feac7e6c81dd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy method, to ensure <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility.  <a href="class_s_x126x.html#aff80db65e546934980feac7e6c81dd80">More...</a><br /></td></tr>
<tr class="separator:aff80db65e546934980feac7e6c81dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139a34e03a6fd5a781cd54da21d308f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ab139a34e03a6fd5a781cd54da21d308f">transmit</a> (__FlashStringHelper *fstr, uint8_t addr=0)</td></tr>
<tr class="memdesc:ab139a34e03a6fd5a781cd54da21d308f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino Flash String transmit method.  <a href="class_s_x126x.html#ab139a34e03a6fd5a781cd54da21d308f">More...</a><br /></td></tr>
<tr class="separator:ab139a34e03a6fd5a781cd54da21d308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62c5a521aafc1e0525c58e9364482b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#aeb62c5a521aafc1e0525c58e9364482b">transmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:aeb62c5a521aafc1e0525c58e9364482b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String transmit method.  <a href="class_s_x126x.html#aeb62c5a521aafc1e0525c58e9364482b">More...</a><br /></td></tr>
<tr class="separator:aeb62c5a521aafc1e0525c58e9364482b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_s_x126x.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81565ee82ef9a7de9c5663c745f4ef7"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#af81565ee82ef9a7de9c5663c745f4ef7">transmit</a> (uint8_t *data, size_t len, uint8_t addr=0)=0</td></tr>
<tr class="memdesc:af81565ee82ef9a7de9c5663c745f4ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary transmit method. Must be implemented in module class.  <a href="class_s_x126x.html#af81565ee82ef9a7de9c5663c745f4ef7">More...</a><br /></td></tr>
<tr class="separator:af81565ee82ef9a7de9c5663c745f4ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#afb1b090348d9091bfa3a0b5ba3d85b36">receive</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String receive method.  <a href="class_s_x126x.html#afb1b090348d9091bfa3a0b5ba3d85b36">More...</a><br /></td></tr>
<tr class="separator:afb1b090348d9091bfa3a0b5ba3d85b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a2ad4c6a8ac267f8ac590260414ffcda3">receive</a> (uint8_t *data, size_t len)=0</td></tr>
<tr class="memdesc:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary receive method. Must be implemented in module class.  <a href="class_s_x126x.html#a2ad4c6a8ac267f8ac590260414ffcda3">More...</a><br /></td></tr>
<tr class="separator:a2ad4c6a8ac267f8ac590260414ffcda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068e6e862c99e39d0261a7971dd56db"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#af068e6e862c99e39d0261a7971dd56db">startTransmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:af068e6e862c99e39d0261a7971dd56db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_s_x126x.html#af068e6e862c99e39d0261a7971dd56db">More...</a><br /></td></tr>
<tr class="separator:af068e6e862c99e39d0261a7971dd56db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_s_x126x.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#a41a1de0ebffe7b65de6fd8cceb9a5123">startTransmit</a> (uint8_t *data, size_t len, uint8_t addr=0)=0</td></tr>
<tr class="memdesc:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven binary transmit method.  <a href="class_s_x126x.html#a41a1de0ebffe7b65de6fd8cceb9a5123">More...</a><br /></td></tr>
<tr class="separator:a41a1de0ebffe7b65de6fd8cceb9a5123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eed0e888a7c8742e89d2b850977de2"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae8eed0e888a7c8742e89d2b850977de2">readData</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:ae8eed0e888a7c8742e89d2b850977de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_s_x126x.html#ae8eed0e888a7c8742e89d2b850977de2">More...</a><br /></td></tr>
<tr class="separator:ae8eed0e888a7c8742e89d2b850977de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b6c756eb4b92855433ca389d73c632"><td class="memItemLeft" align="right" valign="top">virtual int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_x126x.html#ae8b6c756eb4b92855433ca389d73c632">readData</a> (uint8_t *data, size_t len)=0</td></tr>
<tr class="memdesc:ae8b6c756eb4b92855433ca389d73c632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_s_x126x.html#ae8b6c756eb4b92855433ca389d73c632">More...</a><br /></td></tr>
<tr class="separator:ae8b6c756eb4b92855433ca389d73c632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_physical_layer"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_physical_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_physical_layer.html">PhysicalLayer</a></td></tr>
<tr class="memitem:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a5e02457f1d519cf81b1590a182321c62">PhysicalLayer</a> (float freqStep, size_t maxPacketLength)</td></tr>
<tr class="memdesc:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="class_physical_layer.html#a5e02457f1d519cf81b1590a182321c62">More...</a><br /></td></tr>
<tr class="separator:a5e02457f1d519cf81b1590a182321c62 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f">transmit</a> (__FlashStringHelper *fstr, uint8_t addr=0)</td></tr>
<tr class="memdesc:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino Flash String transmit method.  <a href="class_physical_layer.html#ab139a34e03a6fd5a781cd54da21d308f">More...</a><br /></td></tr>
<tr class="separator:ab139a34e03a6fd5a781cd54da21d308f inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#aeb62c5a521aafc1e0525c58e9364482b">transmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String transmit method.  <a href="class_physical_layer.html#aeb62c5a521aafc1e0525c58e9364482b">More...</a><br /></td></tr>
<tr class="separator:aeb62c5a521aafc1e0525c58e9364482b inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">transmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">C-string transmit method.  <a href="class_physical_layer.html#a492b2d057dd803c3884fa1adc8e22534">More...</a><br /></td></tr>
<tr class="separator:a492b2d057dd803c3884fa1adc8e22534 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36">receive</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arduino String receive method.  <a href="class_physical_layer.html#afb1b090348d9091bfa3a0b5ba3d85b36">More...</a><br /></td></tr>
<tr class="separator:afb1b090348d9091bfa3a0b5ba3d85b36 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#af068e6e862c99e39d0261a7971dd56db">startTransmit</a> (String &amp;str, uint8_t addr=0)</td></tr>
<tr class="memdesc:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#af068e6e862c99e39d0261a7971dd56db">More...</a><br /></td></tr>
<tr class="separator:af068e6e862c99e39d0261a7971dd56db inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">startTransmit</a> (const char *str, uint8_t addr=0)</td></tr>
<tr class="memdesc:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes.  <a href="class_physical_layer.html#a923654706eff5118ef6e84214e837f27">More...</a><br /></td></tr>
<tr class="separator:a923654706eff5118ef6e84214e837f27 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ae8eed0e888a7c8742e89d2b850977de2">readData</a> (String &amp;str, size_t len=0)</td></tr>
<tr class="memdesc:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data that was received after calling startReceive method.  <a href="class_physical_layer.html#ae8eed0e888a7c8742e89d2b850977de2">More...</a><br /></td></tr>
<tr class="separator:ae8eed0e888a7c8742e89d2b850977de2 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">getFreqStep</a> () const</td></tr>
<tr class="memdesc:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the module frequency step size that was set in constructor.  <a href="class_physical_layer.html#a977e5236693960bb1c79090a201e9e1c">More...</a><br /></td></tr>
<tr class="separator:a977e5236693960bb1c79090a201e9e1c inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">random</a> (int32_t max)</td></tr>
<tr class="memdesc:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range 0 - max.  <a href="class_physical_layer.html#acd9171bd71aa80fb86113b612c42de53">More...</a><br /></td></tr>
<tr class="separator:acd9171bd71aa80fb86113b612c42de53 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">random</a> (int32_t min, int32_t max)</td></tr>
<tr class="memdesc:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get truly random number in range min - max.  <a href="class_physical_layer.html#a76113e10481743094a1cd0280692b0a9">More...</a><br /></td></tr>
<tr class="separator:a76113e10481743094a1cd0280692b0a9 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">startDirect</a> ()</td></tr>
<tr class="memdesc:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure module parameters for direct modes. Must be called prior to "ham" modes like RTTY or AX.25. Only available in FSK mode.  <a href="class_physical_layer.html#a88a10657bd2215a11a2331f937414b55">More...</a><br /></td></tr>
<tr class="separator:a88a10657bd2215a11a2331f937414b55 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">setDirectSyncWord</a> (uint32_t syncWord, uint8_t len)</td></tr>
<tr class="memdesc:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sync word to be used to determine start of packet in direct reception mode.  <a href="class_physical_layer.html#a8e378fe136a498ea485a9c10f5e15aab">More...</a><br /></td></tr>
<tr class="separator:a8e378fe136a498ea485a9c10f5e15aab inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">available</a> ()</td></tr>
<tr class="memdesc:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of direct mode bytes currently available in buffer.  <a href="class_physical_layer.html#ab57182d32646861ef0d865e2740d6b26">More...</a><br /></td></tr>
<tr class="separator:ab57182d32646861ef0d865e2740d6b26 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_physical_layer.html#a929662904e9af2611e098dc13b91c977">read</a> ()</td></tr>
<tr class="memdesc:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get data from direct mode buffer.  <a href="class_physical_layer.html#a929662904e9af2611e098dc13b91c977">More...</a><br /></td></tr>
<tr class="separator:a929662904e9af2611e098dc13b91c977 inherit pub_methods_class_physical_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for SX126x series. All derived classes for SX126x (e.g. <a class="el" href="class_s_x1262.html" title="Derived class for SX1262 modules.">SX1262</a> or <a class="el" href="class_s_x1268.html" title="Derived class for SX1268 modules.">SX1268</a>) inherit from this base class. This class should not be instantiated directly from Arduino sketch, only from its derived classes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaca5a8fa8a3e634dd1b5b4c2bb5058d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaca5a8fa8a3e634dd1b5b4c2bb5058d8">&#9670;&nbsp;</a></span>SX126x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SX126x::SX126x </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_module.html">Module</a> *&#160;</td>
          <td class="paramname"><em>mod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mod</td><td>Instance of <a class="el" href="class_module.html" title="Implements all common low-level SPI/UART methods to control the wireless module. Every module class c...">Module</a> that will be used to communicate with the radio. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab9ce38cfeaa36ddcc2d82b2974d7088c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ce38cfeaa36ddcc2d82b2974d7088c">&#9670;&nbsp;</a></span>autoLDRO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::autoLDRO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method, LDRO will be enabled automatically when symbol length exceeds 16 ms. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1b97488c6887df2e0291bba1b852605e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97488c6887df2e0291bba1b852605e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::begin </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRegulatorLDO</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for LoRa modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa bandwidth in kHz. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0 and 500.0 kHz.</td></tr>
    <tr><td class="paramname">sf</td><td>LoRa spreading factor. Allowed values are in range 5 to 12.</td></tr>
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator. Allowed values range from 5 to 8.</td></tr>
    <tr><td class="paramname">syncWord</td><td>1-byte LoRa sync word.</td></tr>
    <tr><td class="paramname">preambleLength</td><td>LoRa preamble length in symbols. Allowed values range from 1 to 65535.</td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set on DIO3. Defaults to 1.6 V, set to 0 to skip.</td></tr>
    <tr><td class="paramname">useRegulatorLDO</td><td>use the LDO instead of DC-DC converter (default false). This is necessary for some modules such as the LAMBDA from RF solutions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2e500e5b6044ccab8f6b19af4ffa917c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e500e5b6044ccab8f6b19af4ffa917c">&#9670;&nbsp;</a></span>beginFSK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::beginFSK </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tcxoVoltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRegulatorLDO</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialization method for FSK modem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>FSK bit rate in kbps. Allowed values range from 0.6 to 300.0 kbps.</td></tr>
    <tr><td class="paramname">freqDev</td><td>Frequency deviation from carrier frequency in kHz. Allowed values range from 0.0 to 200.0 kHz.</td></tr>
    <tr><td class="paramname">rxBw</td><td>Receiver bandwidth in kHz. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz.</td></tr>
    <tr><td class="paramname">preambleLength</td><td>FSK preamble length in bits. Allowed values range from 0 to 65535.</td></tr>
    <tr><td class="paramname">tcxoVoltage</td><td>TCXO reference voltage to be set on DIO3. Defaults to 1.6 V, set to 0 to skip.</td></tr>
    <tr><td class="paramname">useRegulatorLDO</td><td>use the LDO instead of DC-DC converter (default false). This is necessary for some modules such as the LAMBDA from RF solutions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afc3a7a42c401b6c44e00cb6c5b9696f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3a7a42c401b6c44e00cb6c5b9696f2">&#9670;&nbsp;</a></span>disableAddressFiltering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::disableAddressFiltering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables address filtering. Calling this method will also erase previously set addresses. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a3765f534418d4e0540c179621c019138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3765f534418d4e0540c179621c019138">&#9670;&nbsp;</a></span>explicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::explicitHeader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set explicit header mode for future reception/transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aa768ce757a0f7ee66cdd72cab7a855fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa768ce757a0f7ee66cdd72cab7a855fa">&#9670;&nbsp;</a></span>fixedPacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::fixedPacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>SX126X_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in fixed packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Packet length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a420c23bb1861646e29f44c0f4c646ee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420c23bb1861646e29f44c0f4c646ee8">&#9670;&nbsp;</a></span>forceLDRO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::forceLDRO </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forces LoRa low data rate optimization. Only available in LoRa mode. After calling this method, LDRO will always be set to the provided value, regardless of symbol length. To re-enable automatic LDRO configuration, call <a class="el" href="class_s_x126x.html#ab9ce38cfeaa36ddcc2d82b2974d7088c" title="Re-enables automatic LDRO configuration. Only available in LoRa mode. After calling this method,...">SX126x::autoLDRO()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Force LDRO to be always enabled (true) or disabled (false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aa668babb0bd129b2facee9fd280525ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa668babb0bd129b2facee9fd280525ab">&#9670;&nbsp;</a></span>getCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX126x::getCurrentLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads current protection limit. </p>
<dl class="section return"><dt>Returns</dt><dd>Currently configured overcurrent protection limit in mA. </dd></dl>

</div>
</div>
<a id="acbe2d75b1e2df8bcc58c4fd9d8e6e4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe2d75b1e2df8bcc58c4fd9d8e6e4f9">&#9670;&nbsp;</a></span>getDataRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX126x::getDataRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets effective data rate for the last transmitted packet. The value is calculated only for payload bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>Effective data rate in bps. </dd></dl>

</div>
</div>
<a id="ac4ef8c8751a3c09d64e431684840c987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ef8c8751a3c09d64e431684840c987">&#9670;&nbsp;</a></span>getPacketLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SX126x::getPacketLength </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query modem for the packet length of received payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update</td><td>Update received packet length. Will return cached value when set to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of last received packet in bytes. </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a0bd6046e068ef63e3f2b6bead48e02a7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0e5f0032a91686b9673a48c908eb1925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5f0032a91686b9673a48c908eb1925">&#9670;&nbsp;</a></span>getRSSI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX126x::getRSSI </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets RSSI (Recorded Signal Strength Indicator) of the last received packet. </p>
<dl class="section return"><dt>Returns</dt><dd>RSSI of the last received packet in dBm. </dd></dl>

</div>
</div>
<a id="ae36664f9c605a8fe74b2f357e0ec3323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36664f9c605a8fe74b2f357e0ec3323">&#9670;&nbsp;</a></span>getRSSIInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX126x::getRSSIInst </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get instantaneous RSSI value during recption of the packet. Should switch to FSK receive mode for LBT implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>Instantaneous RSSI value in dBm, in steps of 0.5dBm </dd></dl>

</div>
</div>
<a id="ae36823d3539667bdf7d2f073bd4fa1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae36823d3539667bdf7d2f073bd4fa1ca">&#9670;&nbsp;</a></span>getSNR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SX126x::getSNR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets SNR (Signal to Noise Ratio) of the last received packet. Only available for LoRa modem. </p>
<dl class="section return"><dt>Returns</dt><dd>SNR of the last received packet in dB. </dd></dl>

</div>
</div>
<a id="a7e342ddbef84cf845bef8f4448b8da10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e342ddbef84cf845bef8f4448b8da10">&#9670;&nbsp;</a></span>getTimeOnAir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SX126x::getTimeOnAir </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get expected time-on-air for a given size of payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Payload length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expected time-on-air in microseconds. </dd></dl>

</div>
</div>
<a id="adec09cba71494bd927ad1da786606ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec09cba71494bd927ad1da786606ca6">&#9670;&nbsp;</a></span>implicitHeader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::implicitHeader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set implicit header mode for future reception/transmission. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a819bb3ced0f184a63cbfbef408a68561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819bb3ced0f184a63cbfbef408a68561">&#9670;&nbsp;</a></span>randomByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t SX126x::randomByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get one truly random byte from RSSI noise. </p>
<dl class="section return"><dt>Returns</dt><dd>TRNG byte. </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a34543b885aa57ade08a4c659991e523e">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aff80db65e546934980feac7e6c81dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff80db65e546934980feac7e6c81dd80">&#9670;&nbsp;</a></span>readBit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX126x::readBit </td>
          <td>(</td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy method, to ensure <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_physical_layer.html#a9b720e7776ad7ea805932578907b0058">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae8eed0e888a7c8742e89d2b850977de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8eed0e888a7c8742e89d2b850977de2">&#9670;&nbsp;</a></span>readData() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String to save the received data.</td></tr>
    <tr><td class="paramname">len</td><td>Expected number of characters in the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a3350cbfab628956c1a456383ac7bb2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3350cbfab628956c1a456383ac7bb2b2">&#9670;&nbsp;</a></span>readData() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::readData </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads data received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#ae8b6c756eb4b92855433ca389d73c632">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ae8b6c756eb4b92855433ca389d73c632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b6c756eb4b92855433ca389d73c632">&#9670;&nbsp;</a></span>readData() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::readData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data that was received after calling startReceive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afb1b090348d9091bfa3a0b5ba3d85b36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1b090348d9091bfa3a0b5ba3d85b36">&#9670;&nbsp;</a></span>receive() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino String receive method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String to save the received data.</td></tr>
    <tr><td class="paramname">len</td><td>Expected number of characters in the message. Leave as 0 if expecting a unknown size packet</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae3db6b29c482d94eef8a43cd8b5751c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3db6b29c482d94eef8a43cd8b5751c0">&#9670;&nbsp;</a></span>receive() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::receive </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary receive method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a2ad4c6a8ac267f8ac590260414ffcda3">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2ad4c6a8ac267f8ac590260414ffcda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad4c6a8ac267f8ac590260414ffcda3">&#9670;&nbsp;</a></span>receive() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::receive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary receive method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to array to save the received binary data.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes that will be received. Must be known in advance for binary transmissions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a8a18aee2bf05793aa29b5cf6b47bb435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a18aee2bf05793aa29b5cf6b47bb435">&#9670;&nbsp;</a></span>receiveDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::receiveDirect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode reception. Only implemented for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, as SX126x series does not support direct mode reception. Will always return ERR_UNKNOWN. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a46b22145b33e97cf6065ed826799b6b4">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a9aa6dd05dd32ef717a06cc8ba28ff71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aa6dd05dd32ef717a06cc8ba28ff71f">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::reset </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verify</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset method. Will reset the chip to the default state using RST pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verify</td><td>Whether correct module startup should be verified. When set to true, RadioLib will attempt to verify the module has started correctly by repeatedly issuing setStandby command. Enabled by default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae9f24414bd684434c310df54b3558f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f24414bd684434c310df54b3558f21">&#9670;&nbsp;</a></span>scanChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::scanChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs scan for LoRa transmission in the current channel. Detects both preamble and payload. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a2f60df59c80241d98ce078c0417a7f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f60df59c80241d98ce078c0417a7f08">&#9670;&nbsp;</a></span>setBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa bandwidth. Allowed values are 7.8, 10.4, 15.6, 20.8, 31.25, 41.7, 62.5, 125.0, 250.0 and 500.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bw</td><td>LoRa bandwidth to be set in kHz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7deeef45d7f64a4018a3e56aaea4eb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7deeef45d7f64a4018a3e56aaea4eb0e">&#9670;&nbsp;</a></span>setBitRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setBitRate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>br</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK bit rate. Allowed values range from 0.6 to 300.0 kbps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">br</td><td>FSK bit rate to be set in kbps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abd8eea7e468db3d6064c19d4934d5034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8eea7e468db3d6064c19d4934d5034">&#9670;&nbsp;</a></span>setBroadcastAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setBroadcastAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>broadAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets broadcast address. Calling this method will also enable address filtering for node and broadcast address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">broadAddr</td><td>Node address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afd3113858966e878e9c67a1e710bd586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3113858966e878e9c67a1e710bd586">&#9670;&nbsp;</a></span>setCodingRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setCodingRate </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa coding rate denominator. Allowed values range from 5 to 8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>LoRa coding rate denominator to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a95007639c2648a1dbb614493224606f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95007639c2648a1dbb614493224606f1">&#9670;&nbsp;</a></span>setCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setCRC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x1D0F</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>polynomial</em> = <code>0x1021</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inverted</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets CRC configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>CRC length in bytes, Allowed values are 1 or 2, set to 0 to disable CRC.</td></tr>
    <tr><td class="paramname">initial</td><td>Initial CRC value. FSK only. Defaults to 0x1D0F (CCIT CRC).</td></tr>
    <tr><td class="paramname">polynomial</td><td>Polynomial for CRC calculation. FSK only. Defaults to 0x1021 (CCIT CRC).</td></tr>
    <tr><td class="paramname">inverted</td><td>Invert CRC bytes. FSK only. Defaults to true (CCIT CRC).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a8f971dca834be7e0470a9a9f0c01854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f971dca834be7e0470a9a9f0c01854e">&#9670;&nbsp;</a></span>setCurrentLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setCurrentLimit </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>currentLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets current protection limit. Can be set in 0.25 mA steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentLimit</td><td>current protection limit to be set in mA.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a1d8f4deb555844b24c2426dd86e69676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8f4deb555844b24c2426dd86e69676">&#9670;&nbsp;</a></span>setDataShaping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setDataShaping </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets time-bandwidth product of Gaussian filter applied for shaping. Allowed values are RADIOLIB_SHAPING_0_3, RADIOLIB_SHAPING_0_5, RADIOLIB_SHAPING_0_7 or RADIOLIB_SHAPING_1_0. Set to RADIOLIB_SHAPING_NONE to disable data shaping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sh</td><td>Time-bandwidth product of Gaussian filter to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#ab643a814dce48f71a13bf6ea23f44cbd">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a0da667fe702d7b4aafaa4bf7e69ea40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da667fe702d7b4aafaa4bf7e69ea40d">&#9670;&nbsp;</a></span>setDio1Action()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX126x::setDio1Action </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets interrupt service routine to call when DIO1 activates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>ISR to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae46e08d579f4acbad029b4cd4f4fffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46e08d579f4acbad029b4cd4f4fffaf">&#9670;&nbsp;</a></span>setDio2AsRfSwitch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setDio2AsRfSwitch </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set DIO2 to function as RF switch (default in Semtech example designs). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="abbf8b4623da8c2caa83a8c3d35a44d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf8b4623da8c2caa83a8c3d35a44d0a">&#9670;&nbsp;</a></span>setDirectAction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SX126x::setDirectAction </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dummy method, to ensure <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="class_physical_layer.html#ab76fe7d3e0f453a807b205161c980086">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a2b3eb51117558c58384b03de4b7bfe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3eb51117558c58384b03de4b7bfe60">&#9670;&nbsp;</a></span>setEncoding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setEncoding </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets transmission encoding. Available in FSK mode only. Serves only as alias for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>Encoding to be used. Set to 0 for NRZ, and 2 for whitening.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a7d3419227d201d6912b77784636d437d">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a7cd95a5f2e39ae8fb1a3040e77fa21a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd95a5f2e39ae8fb1a3040e77fa21a3">&#9670;&nbsp;</a></span>setFrequencyDeviation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setFrequencyDeviation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>freqDev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets FSK frequency deviation. Allowed values range from 0.0 to 200.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">freqDev</td><td>FSK frequency deviation to be set in kHz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#ab9060e8ab7a2da192b3bf53b3501553b">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a514cabe74bbe3434d7e4f244c4077752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514cabe74bbe3434d7e4f244c4077752">&#9670;&nbsp;</a></span>setNodeAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setNodeAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nodeAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets node address. Calling this method will also enable address filtering for node address only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeAddr</td><td>Node address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab00f765bbfbfaa8c693532ea3a90c29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00f765bbfbfaa8c693532ea3a90c29b">&#9670;&nbsp;</a></span>setPreambleLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>preambleLength</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets preamble length for LoRa or FSK modem. Allowed values range from 1 to 65535. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">preambleLength</td><td>Preamble length to be set in symbols (LoRa) or bits (FSK).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5ae69309ca0cf5f13c60f2d162916ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae69309ca0cf5f13c60f2d162916ff8">&#9670;&nbsp;</a></span>setRegulatorDCDC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setRegulatorDCDC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set regulator mode to DC-DC. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a21c263ce1a339faa74c568d9afb81cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c263ce1a339faa74c568d9afb81cd2">&#9670;&nbsp;</a></span>setRegulatorLDO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setRegulatorLDO </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set regulator mode to LDO. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a288257242e483cb3eb6944333179dd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288257242e483cb3eb6944333179dd26">&#9670;&nbsp;</a></span>setRfSwitchPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SX126x::setRfSwitchPins </td>
          <td>(</td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>rxEn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RADIOLIB_PIN_TYPE&#160;</td>
          <td class="paramname"><em>txEn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some modules contain external RF switch controlled by two pins. This function gives RadioLib control over those two pins to automatically switch Rx and Tx state. When using automatic RF switch control, DO NOT change the pin mode of rxEn or txEn from Arduino sketch! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxEn</td><td>RX enable pin.</td></tr>
    <tr><td class="paramname">txEn</td><td>TX enable pin. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59d443c02d4620cda32c63a00c6bcc22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d443c02d4620cda32c63a00c6bcc22">&#9670;&nbsp;</a></span>setRxBandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setRxBandwidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rxBw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK receiver bandwidth. Allowed values are 4.8, 5.8, 7.3, 9.7, 11.7, 14.6, 19.5, 23.4, 29.3, 39.0, 46.9, 58.6, 78.2, 93.8, 117.3, 156.2, 187.2, 234.3, 312.0, 373.6 and 467.0 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FSK</td><td>receiver bandwidth to be set in kHz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ae5993359ace652fbdc862eb23fdd263d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5993359ace652fbdc862eb23fdd263d">&#9670;&nbsp;</a></span>setSpreadingFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setSpreadingFactor </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa spreading factor. Allowed values range from 5 to 12. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sf</td><td>LoRa spreading factor to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ac594fbb30c5010658c970a64654c7162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac594fbb30c5010658c970a64654c7162">&#9670;&nbsp;</a></span>setSyncBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setSyncBits </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitsLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK sync word in the form of array of up to 8 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>FSK sync word to be set.</td></tr>
    <tr><td class="paramname">bitsLen</td><td>FSK sync word length in bits. If length is not divisible by 8, least significant bits of syncWord will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a38e6d7831f35893a5b8328c10a2901bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e6d7831f35893a5b8328c10a2901bf">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK sync word in the form of array of up to 8 bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>FSK sync word to be set.</td></tr>
    <tr><td class="paramname">len</td><td>FSK sync word length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a9d92dce566f8aefa836fe8f332e9560f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d92dce566f8aefa836fe8f332e9560f">&#9670;&nbsp;</a></span>setSyncWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setSyncWord </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>syncWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>controlBits</em> = <code>0x44</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets LoRa sync word. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">syncWord</td><td>LoRa sync word to be set.</td></tr>
    <tr><td class="paramname">controlBits</td><td>Undocumented control bits, required for compatibility purposes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a57bee6f4b3a3b7ec646ac8de347ee0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57bee6f4b3a3b7ec646ac8de347ee0d6">&#9670;&nbsp;</a></span>setTCXO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setTCXO </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>voltage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>delay</em> = <code>5000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TCXO (Temperature Compensated Crystal Oscillator) configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TCXO</td><td>reference voltage in volts. Allowed values are 1.6, 1.7, 1.8, 2.2. 2.4, 2.7, 3.0 and 3.3 V. Set to 0 to disable TCXO. NOTE: After setting this parameter to 0, the module will be reset (since there's no other way to disable TCXO).</td></tr>
    <tr><td class="paramname">TCXO</td><td>timeout in us. Defaults to 5000 us.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a67702de41ae866b9f9d73234fc9ae376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67702de41ae866b9f9d73234fc9ae376">&#9670;&nbsp;</a></span>setWhitening()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::setWhitening </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>initial</em> = <code>0x0100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets FSK whitening parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True = Whitening enabled</td></tr>
    <tr><td class="paramname">initial</td><td>Initial value used for the whitening LFSR in FSK mode. Defaults to 0x0100, use 0x01FF for <a class="el" href="class_s_x127x.html" title="Base class for SX127x series. All derived classes for SX127x (e.g. SX1278 or SX1272) inherit from thi...">SX127x</a> compatibility.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="afb5509f0705cdd971065251ed6b2fb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5509f0705cdd971065251ed6b2fb4e">&#9670;&nbsp;</a></span>sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::sleep </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>retainConfig</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to sleep mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">retainConfig</td><td>Set to true to retain configuration of the currently active modem ("warm start") or to false to discard current configuration ("cold start"). Defaults to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a7a1579e2557c36a4a34b09039c0d0c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1579e2557c36a4a34b09039c0d0c71">&#9670;&nbsp;</a></span>standby() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::standby </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the module to standby mode (overload for <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a> compatibility, uses 13 MHz RC oscillator). </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a0e77da761a2cbb5c9535df0bdea993f9">PhysicalLayer</a>.</p>

</div>
</div>
<a id="ad7569396f09f3867dc1bd4d4a0613acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7569396f09f3867dc1bd4d4a0613acd">&#9670;&nbsp;</a></span>standby() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::standby </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module to standby mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Oscillator to be used in standby mode. Can be set to SX126X_STANDBY_RC (13 MHz RC oscillator) or SX126X_STANDBY_XOSC (32 MHz external crystal oscillator).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a5052dc09f4b10ee22e169129f368685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5052dc09f4b10ee22e169129f368685f">&#9670;&nbsp;</a></span>startReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::startReceive </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>SX126X_RX_TIMEOUT_INF</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven receive method. DIO1 will be activated when full packet is received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>Raw timeout value, expressed as multiples of 15.625 us. Defaults to SX126X_RX_TIMEOUT_INF for infinite timeout (Rx continuous mode), set to SX126X_RX_TIMEOUT_NONE for no timeout (Rx single mode).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="adc46b6adda2d0e82e25ed1fc78274136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc46b6adda2d0e82e25ed1fc78274136">&#9670;&nbsp;</a></span>startReceiveDutyCycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::startReceiveDutyCycle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rxPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sleepPeriod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven receive method where the device mostly sleeps and periodically wakes to listen. Note that this function assumes the unit will take 500us + TCXO_delay to change state. See datasheet section 13.1.7, version 1.2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rxPeriod</td><td>The duration the receiver will be in Rx mode, in microseconds.</td></tr>
    <tr><td class="paramname">sleepPeriod</td><td>The duration the receiver will not be in Rx mode, in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a6b50cb78f02a3d93939437eb48489d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b50cb78f02a3d93939437eb48489d3f">&#9670;&nbsp;</a></span>startReceiveDutyCycleAuto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::startReceiveDutyCycleAuto </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>senderPreambleLength</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>minSymbols</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_s_x126x.html#adc46b6adda2d0e82e25ed1fc78274136">startReceiveDutyCycle</a> with rxPeriod and sleepPeriod set so the unit shouldn't miss any messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senderPreambleLength</td><td>Expected preamble length of the messages to receive. If set to zero, the currently configured preamble length will be used. Defaults to zero.</td></tr>
    <tr><td class="paramname">minSymbols</td><td>Parameters will be chosen to ensure that the unit will catch at least this many symbols of any preamble of the specified length. Defaults to 8. According to Semtech, receiver requires 8 symbols to reliably latch a preamble. This makes this method redundant when transmitter preamble length is less than 17 (2*minSymbols + 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a923654706eff5118ef6e84214e837f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923654706eff5118ef6e84214e837f27">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="af068e6e862c99e39d0261a7971dd56db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af068e6e862c99e39d0261a7971dd56db">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven Arduino String transmit method. Unlike the standard transmit method, this one is non-blocking. Interrupt pin will be activated when transmission finishes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino String that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab843614658a79db7aa24e48d5b6e84f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab843614658a79db7aa24e48d5b6e84f1">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::startTransmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send.</td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a41a1de0ebffe7b65de6fd8cceb9a5123">PhysicalLayer</a>.</p>

</div>
</div>
<a id="a41a1de0ebffe7b65de6fd8cceb9a5123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a1de0ebffe7b65de6fd8cceb9a5123">&#9670;&nbsp;</a></span>startTransmit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::startTransmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt-driven binary transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="ab139a34e03a6fd5a781cd54da21d308f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab139a34e03a6fd5a781cd54da21d308f">&#9670;&nbsp;</a></span>transmit() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino Flash String transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Pointer to Arduino Flash String that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a492b2d057dd803c3884fa1adc8e22534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492b2d057dd803c3884fa1adc8e22534">&#9670;&nbsp;</a></span>transmit() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C-string transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>C-string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aeb62c5a521aafc1e0525c58e9364482b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb62c5a521aafc1e0525c58e9364482b">&#9670;&nbsp;</a></span>transmit() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arduino String transmit method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Address of Arduino string that will be transmitted.</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="aab18364237ddac0c56aeaf63f08cf009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab18364237ddac0c56aeaf63f08cf009">&#9670;&nbsp;</a></span>transmit() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::transmit </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocking binary transmit method. Overloads for string-based transmissions are implemented in <a class="el" href="class_physical_layer.html" title="Provides common interface for protocols that run on LoRa/FSK modules, such as RTTY or LoRaWAN....">PhysicalLayer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data to be sent.</td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to send.</td></tr>
    <tr><td class="paramname">addr</td><td>Address to send the data to. Will only be added if address filtering was enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#af81565ee82ef9a7de9c5663c745f4ef7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="af81565ee82ef9a7de9c5663c745f4ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81565ee82ef9a7de9c5663c745f4ef7">&#9670;&nbsp;</a></span>transmit() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int16_t PhysicalLayer::transmit</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary transmit method. Must be implemented in module class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Binary data that will be transmitted.</td></tr>
    <tr><td class="paramname">len</td><td>Length of binary data to transmit (in bytes).</td></tr>
    <tr><td class="paramname">addr</td><td>Node address to transmit the packet to. Only used in FSK mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<a id="a921aa8afb8d33b2660731c1f8d67664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921aa8afb8d33b2660731c1f8d67664b">&#9670;&nbsp;</a></span>transmitDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::transmitDirect </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frf</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Starts direct mode transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frf</td><td>Raw RF frequency value. Defaults to 0, required for quick frequency shifts in RTTY.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

<p>Implements <a class="el" href="class_physical_layer.html#a4b04eb6155b06d8ef400131c647d54e7">PhysicalLayer</a>.</p>

</div>
</div>
<a id="aa11ab2c6f4488daf2ece93288e05c504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11ab2c6f4488daf2ece93288e05c504">&#9670;&nbsp;</a></span>variablePacketLengthMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t SX126x::variablePacketLengthMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>SX126X_MAX_PACKET_LENGTH</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set modem in variable packet length mode. Available in FSK mode only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Maximum packet length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html">Status Codes</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/modules/SX126x/<a class="el" href="_s_x126x_8h_source.html">SX126x.h</a></li>
<li>src/modules/SX126x/SX126x.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_s_x126x.html">SX126x</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
